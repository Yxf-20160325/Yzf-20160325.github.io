<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿·å®«å†’é™© - 1.7.1</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            overflow: hidden;
        }
        
        /* ä¸»èœå•æ ·å¼ */
        .main-menu {
            text-align: center;
            margin-top: 100px;
            
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .menu-title {
            font-size: 60px;
            margin-bottom: 40px;
            color: #4CAF50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
            letter-spacing: 3px;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .menu-button {
            display: block;
            width: 250px;
            margin: 25px auto;
            padding: 18px;
            font-size: 22px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .menu-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            background: linear-gradient(135deg, #66BB6A, #388E3C);
        }
        
        /* å…³å¡é€‰æ‹©æ ·å¼ */
        .level-select {
            text-align: center;
            margin-top: 20px;
            animation: slideIn 0.8s ease-out;
            position: relative;
            padding-top: 80px;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-50px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
.level-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 700px;
    margin: 30px auto;
    margin-top: 60px;
    max-height: calc(100vh - 200px);
    overflow-y: auto;
    padding: 20px;
    box-sizing: border-box;
    -webkit-overflow-scrolling: touch; /* iOSæ»‘åŠ¨æµç•… */
    touch-action: pan-y; /* ä¼˜åŒ–è§¦æ§è¡Œä¸º */
    overscroll-behavior: contain; /* é˜²æ­¢æ»šåŠ¨ä¼ æ’­åˆ°å¤–å±‚ */
}
        
        .level-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .level-container::-webkit-scrollbar-thumb {
            background: rgba(76, 175, 80, 0.5);
            border-radius: 4px;
        }
        
        .level-container::-webkit-scrollbar-thumb:hover {
            background: rgba(76, 175, 80, 0.8);
        }
        
        .level-button {
            width: 60px;
            height: 60px;
            margin: 12px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .level-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }
        
        .level-button.locked {
            background: linear-gradient(135deg, #555, #333);
            cursor: not-allowed;
        }
        
        .level-button.completed {
            background: linear-gradient(135deg, #FFC107, #FF9800);
        }

        .level-button.unsolvable {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            position: relative;
            overflow: hidden;
        }
        
        .level-button.unsolvable::after {
            content: "?";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: rgba(255,255,255,0.7);
        }
        
        /* æ¸¸æˆç”»å¸ƒæ ·å¼ */
        #gameCanvas {
            display: block;
            margin: 20px auto;
            background-color: #111;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
        }
        
        /* æ¸¸æˆä¿¡æ¯æ ·å¼ */
        .game-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-family: monospace;
            z-index: 10;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-width: 300px;
            transition: all 0.3s ease;
        }
        
        .game-info-item {
            display: flex;
            align-items: center;
            padding: 5px;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 4px;
            min-width: 80px;
        }
        
        /* é€šå…³æç¤ºæ ·å¼ */
        .level-complete {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            width: 400px;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.5);
            border: 2px solid #4CAF50;
            animation: popIn 0.5s ease-out;
        }
        
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        .level-complete h2 {
            font-size: 36px;
            margin-bottom: 25px;
            color: #4CAF50;
        }
        
        .level-complete p {
            font-size: 22px;
            margin-bottom: 30px;
            font-family: monospace;
        }
        
        .level-complete button {
            margin: 0 10px;
            padding: 12px 25px;
            font-size: 18px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .level-complete button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        /* è¿”å›æŒ‰é’®æ ·å¼ */
        .back-button {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 8px 16px;
            font-size: 16px;
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            z-index: 20;
        }
        
        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0,0,0,0.4);
        }
        
        /* å¤šäººæ¸¸æˆè®¾ç½®æ ·å¼ */
        .multiplayer-setup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            width: 400px;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
            border: 2px solid #4CAF50;
        }
        
        .multiplayer-setup h2 {
            font-size: 32px;
            margin-bottom: 30px;
            color: #4CAF50;
        }
        
        .setup-input {
            margin: 15px 0;
            padding: 12px 15px;
            width: 100%;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid #4CAF50;
            border-radius: 5px;
            outline: none;
        }
        
        .setup-input:focus {
            border-color: #8BC34A;
            box-shadow: 0 0 10px rgba(139, 195, 74, 0.5);
        }
        
        /* å¤šäººæ¸¸æˆç•Œé¢æ ·å¼ */
        .player-list {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            min-width: 180px;
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
        }
        
        .player-list h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #4CAF50;
            text-align: center;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        .player-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .player-color {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .connection-status {
            position: absolute;
            bottom: 15px;
            right: 15px;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-family: monospace;
            z-index: 10;
        }
        
        .connected {
            background: rgba(76, 175, 80, 0.8);
        }
        
        .disconnected {
            background: rgba(244, 67, 54, 0.8);
        }
        
        /* éšè—ç±» */
        .hidden {
            display: none !important;
        }
        
        /* æ¸¸æˆè¯´æ˜å¼¹çª— */
        .instructions-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 600px;
            z-index: 1000;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.7);
            border: 2px solid #4CAF50;
        }
        
        .instructions-modal h2 {
            color: #4CAF50;
            text-align: center;
            margin-top: 0;
        }
        
        .instructions-modal p {
            line-height: 1.6;
            margin-bottom: 20px;
            font-family: monospace;
        }
        
        .instructions-modal ul {
            text-align: left;
            padding-left: 20px;
        }
        
        .instructions-modal li {
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        .instructions-modal button {
            display: block;
            margin: 20px auto 0;
            padding: 10px 25px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        /* æ–¹å‘é”®æ§åˆ¶é¢æ¿ */
        .controls-panel {
            position: fixed;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            z-index: 10;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            width: 150px;
            height: 150px;
            box-sizing: border-box;
        }

        .control-button {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #4CAF50;
            border-radius: 5px;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-button:hover {
            background: rgba(76, 175, 80, 0.3);
            transform: scale(1.05);
        }

        .control-button:active {
            background: rgba(76, 175, 80, 0.5);
            transform: scale(0.95);
        }

        .control-up {
            grid-column: 2;
            grid-row: 1;
        }

        .control-left {
            grid-column: 1;
            grid-row: 2;
        }

        .control-right {
            grid-column: 3;
            grid-row: 2;
        }

        .control-down {
            grid-column: 2;
            grid-row: 3;
        }
        
        /* å…³å¡å†…æ§åˆ¶æŒ‰é’® */
        .level-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }
        
        .level-control-button {
            padding: 10px 20px;
            font-size: 16px;
            background: linear-gradient(135deg, #2196F3, #0D47A1);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        
        .level-control-button.reset {
            background: linear-gradient(135deg, #FF9800, #F57C00);
        }
        
        .level-control-button.exit {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }
        
        .level-control-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }
        
        /* å…³å¡é€‰æ‹©æ ‡é¢˜æ ·å¼ */
        .level-select-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            z-index: 10;
            width: 100%;
            text-align: center;
        }
        
        /* è¿½é€è€…æ ·å¼ */
        .enemy-info {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 16px;
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
            white-space: nowrap;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(244, 67, 54, 0.5); }
            50% { box-shadow: 0 0 20px rgba(244, 67, 54, 0.8); }
            100% { box-shadow: 0 0 5px rgba(244, 67, 54, 0.5); }
        }
        
        /* é’¥åŒ™å’Œé—¨æ ·å¼ */
        .key-info {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 16px;
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
            white-space: nowrap;
            animation: glow 1.5s infinite alternate;
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
            to { box-shadow: 0 0 15px rgba(255, 215, 0, 0.8); }
        }
        
        .unlock-timer {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 16px;
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
            white-space: nowrap;
            animation: glow 1.5s infinite alternate;
        }
        
        /* æ§åˆ¶å°æ ·å¼ */
        .console-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            width: 500px;
            max-width: 90%;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.7);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            font-family: 'Courier New', monospace;
        }
        
        .console-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #4CAF50;
            margin-bottom: 10px;
        }
        
        .console-title {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .console-close {
            background: none;
            border: none;
            color: #f44336;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }
        
        .console-close:hover {
            background: rgba(244, 67, 54, 0.2);
        }
        
        .console-output {
            background: rgba(20, 20, 30, 0.9);
            height: 200px;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            overflow-y: auto;
            font-size: 14px;
            color: #ccc;
            white-space: pre-wrap;
        }
        
        .console-input-group {
            display: flex;
        }
        
        .console-prompt {
            color: #4CAF50;
            padding: 8px 10px 8px 0;
            font-weight: bold;
        }
        
        .console-input {
            flex: 1;
            background: rgba(30, 30, 40, 0.9);
            border: 1px solid #4CAF50;
            border-radius: 5px;
            padding: 8px 12px;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            outline: none;
        }
        
        .console-input:focus {
            border-color: #8BC34A;
            box-shadow: 0 0 8px rgba(139, 195, 74, 0.5);
        }
        
        .console-status {
            margin-top: 10px;
            padding: 5px 10px;
            background: rgba(30, 30, 40, 0.9);
            border-radius: 5px;
            font-size: 12px;
            color: #aaa;
        }
        
        .console-hidden {
            display: none;
        }
        
        /* æ§åˆ¶å°æç¤º */
        .console-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-family: monospace;
            border: 1px solid #4CAF50;
            z-index: 100;
            animation: fadeInHint 0.5s;
        }
        
        @keyframes fadeInHint {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .console-hint.hidden {
            display: none;
        }
        
        /* UIè®¾ç½®é¢æ¿æ ·å¼ */
        .settings-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 500px;
            z-index: 1000;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.7);
            border: 2px solid #4CAF50;
        }

        .settings-modal h2 {
            color: #4CAF50;
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .setting-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #4CAF50;
        }

        .setting-group h3 {
            color: #8BC34A;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }

        .setting-row label {
            width: 80px;
            margin-right: 15px;
            color: white;
        }

        .setting-row select, 
        .setting-row input[type="range"] {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #4CAF50;
            color: white;
            padding: 8px;
            border-radius: 5px;
        }

        .setting-row input[type="range"] {
            padding: 0;
        }
        
        .setting-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .setting-checkbox input {
            margin-right: 10px;
        }

        .buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .buttons button {
            padding: 10px 25px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .buttons button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }

        /* è®¾ç½®æŒ‰é’®æ ·å¼ */
        .settings-button {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 20;
            transition: all 0.3s;
        }

        .settings-button:hover {
            background: rgba(76, 175, 80, 0.8);
            transform: scale(1.1);
        }
        
        /* æ¸¸æˆä¿¡æ¯è®¾ç½® */
        .info-settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .drag-handle {
            width: 100%;
            height: 20px;
            background: rgba(76, 175, 80, 0.2);
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
            cursor: move;
            position: absolute;
            top: -20px;
            left: 0;
            z-index: 1;
        }
        
        .controls-panel.draggable {
            cursor: grabbing;
        }
#controlsPanel {
    position: fixed;
    /* åˆå§‹ä½ç½®ï¼ˆä¼šè¢«JSè¦†ç›–ï¼‰ */
    left: 20px;
    bottom: 20px;
    /* å¹³æ»‘ç§»åŠ¨æ•ˆæœ */
    transition: left 0.2s, top 0.2s;
    /* é˜²æ­¢è§¦æ‘¸é«˜äº® */
    -webkit-tap-highlight-color: transparent;
}

#dragHandle {
    width: 100%;
    height: 30px;
    /* è§¦æ‘¸ä¼˜åŒ– */
    touch-action: none;
    cursor: grab;
}
.level-control-button.next {
    background: linear-gradient(135deg, #4CAF50, #2E7D32);
}

.level-control-button.skip {
    background: linear-gradient(135deg, #FF9800, #F57C00);
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 5px rgba(255, 152, 0, 0.7); }
    50% { box-shadow: 0 0 15px rgba(255, 152, 0, 0.9); }
    100% { box-shadow: 0 0 5px rgba(255, 152, 0, 0.7); }
}

        /* æ–°å¢æ ·å¼ï¼šè¸¢å‡ºæŒ‰é’® */
        .kick-button {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 5px;
        }
        
        .kick-button:hover {
            background: linear-gradient(135deg, #ff5252, #ff1744);
        }
        
        /* æˆ¿é—´è®¾ç½®æ ·å¼ */
        .room-settings {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #4CAF50;
        }
        
        .room-settings h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #8BC34A;
        }
/* æ›´å¤šæŒ‘æˆ˜æ ·å¼ */
.challenges-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    max-width: 600px;
    margin: 30px auto;
    padding: 20px;
}

.challenge-card {
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #4CAF50;
    border-radius: 15px;
    padding: 25px;
    width: 100%;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: left;
}

.challenge-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(76, 175, 80, 0.3);
    background: rgba(0, 0, 0, 0.8);
}

.challenge-card h3 {
    color: #4CAF50;
    margin-top: 0;
    font-size: 24px;
}

.challenge-card p {
    color: #ccc;
    margin-bottom: 15px;
}

.challenge-stats {
    color: #8BC34A;
    font-size: 14px;
}

/* æˆå°±ç³»ç»Ÿæ ·å¼ */
.achievements-container {
    max-width: 600px;
    margin: 30px auto;
    padding: 20px;
}

.achievement-item {
    display: flex;
    align-items: center;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #333;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}

.achievement-item.completed {
    border-color: #FFD700;
    background: rgba(255, 215, 0, 0.1);
}

.achievement-icon {
    font-size: 32px;
    margin-right: 15px;
}

.achievement-info {
    flex: 1;
}

.achievement-info h3 {
    color: #fff;
    margin: 0 0 5px 0;
    font-size: 18px;
}

.achievement-info p {
    color: #ccc;
    margin: 0 0 10px 0;
    font-size: 14px;
}

.achievement-progress {
    display: flex;
    align-items: center;
    gap: 10px;
}
.special-challenges {
    margin-top: 30px;
    border-top: 1px solid #4CAF50;
    padding-top: 20px;
}

.challenge-button {
    background: rgba(76, 175, 80, 0.2);
    border: 1px dashed #4CAF50;
    border-radius: 8px;
    padding: 15px;
    width: 100%;
    display: flex;
    align-items: center;
    cursor: pointer;
    transition: all 0.3s;
}

.challenge-button:hover {
    background: rgba(76, 175, 80, 0.4);
}

.challenge-icon {
    font-size: 30px;
    margin-right: 15px;
}
.progress-bar {
    flex: 1;
    height: 8px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(135deg, #4CAF50, #8BC34A);
    border-radius: 4px;
    transition: width 0.3s ease;
}

.achievement-status {
    padding: 5px 10px;
    background: #333;
    border-radius: 15px;
    font-size: 12px;
    color: #ccc;
}

.achievement-item.completed .achievement-status {
    background: #FFD700;
    color: #000;
    font-weight: bold;
}

/* æ—¶é—´æŒ‘æˆ˜æç¤º */
.time-challenge-info {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(244, 67, 54, 0.9);
    color: white;
    padding: 10px 15px;
    border-radius: 8px;
    font-family: monospace;
    z-index: 10;
    animation: pulse 1.5s infinite;
}
.replay-list {
    max-height: 400px;
    overflow-y: auto;
    margin: 15px 0;
    border: 1px solid #333;
    border-radius: 5px;
}

.replay-item {
    padding: 12px;
    border-bottom: 1px solid #444;
    cursor: pointer;
    transition: background 0.2s;
}

.replay-item:hover {
    background: rgba(76, 175, 80, 0.1);
}

.replay-meta {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
}

.player-container {
    margin-top: 20px;
    background: #111;
    padding: 15px;
    border-radius: 5px;
}

.player-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 15px;
}

.speed-control {
    margin-left: auto;
}
/* äº‹ä»¶é€šçŸ¥æ ·å¼ */
#event-notifications {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
}

.event-notification {
  background: rgba(0,0,0,0.8);
  color: #fff;
  padding: 10px 15px;
  border-radius: 5px;
  border-left: 4px solid #FF9800;
  margin-bottom: 5px;
  animation: fadeIn 0.3s;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}
/* å•†åº—æ¨¡æ€æ¡†æ ·å¼ */
.shop-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.shop-content {
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border: 2px solid #4CAF50;
    border-radius: 15px;
    padding: 25px;
    width: 90%;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 0 40px rgba(76, 175, 80, 0.5);
}

.shop-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #4CAF50;
}

.shop-header h2 {
    color: #4CAF50;
    margin: 0;
}

.shop-close-btn {
    background: none;
    border: none;
    color: #f44336;
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.3s;
}

.shop-close-btn:hover {
    background: rgba(244, 67, 54, 0.2);
}

.shop-items {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.shop-item {
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid #4CAF50;
    border-radius: 10px;
    padding: 15px;
    display: flex;
    align-items: center;
    transition: all 0.3s ease;
}

.shop-item:hover {
    background: rgba(76, 175, 80, 0.1);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.4);
}

.item-icon {
    font-size: 40px;
    margin-right: 20px;
}

.item-info {
    flex: 1;
}

.item-info h3 {
    color: #8BC34A;
    margin: 0 0 5px 0;
    font-size: 20px;
}

.item-info p {
    color: #ccc;
    margin: 0;
    font-size: 14px;
}

.item-price {
    display: flex;
    align-items: center;
    margin: 0 20px;
}

.coin-icon {
    color: gold;
    font-size: 20px;
    margin-right: 5px;
}

.price-amount {
    color: gold;
    font-weight: bold;
    font-size: 18px;
}

.buy-btn {
    padding: 8px 20px;
    background: linear-gradient(135deg, #FFC107, #FF9800);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s;
}

.buy-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 3px 10px rgba(255, 152, 0, 0.5);
}

/* å½“é‡‘å¸ä¸è¶³æ—¶ï¼ŒæŒ‰é’®å˜ç°ä¸”ä¸å¯ç‚¹å‡» */
.buy-btn:disabled {
    background: #555;
    cursor: not-allowed;
    transform: scale(1);
}

    </style>
</head>

<body>
    <div id="shopModal" class="shop-modal hidden">
        <div class="shop-content">
            <div class="shop-header">
                <h2>æ¸¸æˆå•†åº—</h2>
                <button class="shop-close-btn" onclick="closeShop()">Ã—</button>
            </div>
            <div class="shop-items">
                <!-- é“å…·1ï¼šæ•ˆæœæ¸…é™¤ -->
                <div class="shop-item" data-item="clear-events">
                    <div class="item-icon">âœ¨</div>
                    <div class="item-info">
                        <h3>æ•ˆæœæ¸…é™¤</h3>
                        <p>æ¸…é™¤å½“å‰è§¦å‘çš„æ‰€æœ‰éšæœºäº‹ä»¶ï¼ˆå¦‚æ§åˆ¶åè½¬ï¼‰ã€‚</p>
                    </div>
                    <div class="item-price">
                        <span class="coin-icon">ğŸª™</span>
                        <span class="price-amount">20</span>
                    </div>
                    <button class="buy-btn" onclick="buyItem('clear-events')">è´­ä¹°</button>
                </div>
                
                <!-- é“å…·3ï¼šä¼ é€ -->
                <div class="shop-item" data-item="teleport">
                    <div class="item-icon">ğŸŒ€</div>
                    <div class="item-info">
                        <h3>ä¼ é€</h3>
                        <p>åœ¨å•äººæ¸¸æˆä¸­ï¼Œè®©ä½ ä¼ é€åˆ°åœ°å›¾ä¸Šçš„ä»»æ„ä½ç½®ã€‚</p>
                        <p class="item-note" style="color: #888; font-size: 12px;">*ä»…é™å•äººæ¸¸æˆ</p>
                    </div>
                    <div class="item-price">
                        <span class="coin-icon">ğŸª™</span>
                        <span class="price-amount">25</span>
                    </div>
                    <button class="buy-btn" onclick="buyItem('teleport')">è´­ä¹°</button>
                </div>
            </div>
        </div>
    </div>
    <!-- ä¸»èœå• -->
    <div id="mainMenu" class="main-menu">
        <h1 class="menu-title">è¿·å®«å†’é™©</h1>
        <button class="menu-button" onclick="showScreen('singlePlayerLevelSelect')">å•äººæ¸¸æˆ</button>
        <button class="menu-button" onclick="showScreen('multiplayerSetup')">å±€åŸŸç½‘å¤šäººæ¸¸æˆ iOSè¯·ç¡®ä¿æœåŠ¡å™¨å¼€å¯</button>
        <button class="menu-button" onclick="showInstructions()">æ¸¸æˆè¯´æ˜</button>
        <button class="menu-button" onclick="showScreen('achievementsScreen')">æˆå°±ç³»ç»Ÿ</button>
        <!-- <button class="menu-button" onclick="showScreen('moreChallengesScreen')">æ›´å¤šæŒ‘æˆ˜</button> -->
        <!-- <button class="menu-button" onclick="showSaveLoadMenu()">å­˜æ¡£/è¯»æ¡£</button> -->
        <button class="menu-button" onclick="showUISettings()">UIè®¾ç½®</button>
        <button class="menu-button" onclick="openShop()">æ¸¸æˆå•†åº—</button>
        
        <!-- æ–°å¢ç©å®¶å·¥åŠæŒ‰é’® -->
        <button id="workshopBtn" class="menu-btn highlight">
            ç©å®¶å·¥åŠ
            <span class="badge" id="newLevelsBadge">12</span>
        </button>
        
        <button id="playBtn" class="menu-btn">
            <i class="icon-play"></i> å¼€å§‹æ¸¸æˆ
        </button>
        </div>
    
    <div id="moreChallengesScreen" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">è¿”å›</button>
        <h2 class="level-select-title">æ›´å¤šæŒ‘æˆ˜</h2>
        <div class="challenges-container">
            <div class="challenge-card" onclick="startTimeChallenge()">
                <h3>æ—¶é—´æŒ‘æˆ˜</h3>
                <p>åœ¨60ç§’å†…å°½å¯èƒ½é€šè¿‡æ›´å¤šå…³å¡ï¼</p>
                <div class="challenge-stats">æœ€ä½³è®°å½•: <span id="timeChallengeBest">0</span>ç§’</div>
            </div>
            <div class="challenge-card" onclick="startPuzzleMode()">
                <h3>è§£è°œæ¨¡å¼</h3>
                <p>è§£å¼€ç²¾å¿ƒè®¾è®¡çš„è°œé¢˜å…³å¡ã€‚</p>
                <div class="challenge-stats">å·²å®Œæˆ: <span id="puzzleCompleted">0</span>/10</div>
            </div>
        </div>
    </div>
    <!-- æˆå°±ç³»ç»Ÿç•Œé¢ -->
    <div id="achievementsScreen" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">è¿”å›</button>
        <h2 class="level-select-title">æˆå°±ç³»ç»Ÿ</h2>
        
        <div class="achievements-container">
            <div class="achievement-item" id="achievement1">
                <div class="achievement-icon">ğŸ†</div>
                <div class="achievement-info">
                    <h3>è¿·å®«å¤§å¸ˆ</h3>
                    <p>é€šå…³æ‰€æœ‰å…³å¡</p>
                    <div class="achievement-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress1"></div>
                        </div>
                        <span id="progressText1">0/80</span>
                    </div>
                </div>
                <div class="achievement-status" id="status1">æœªå®Œæˆ</div>
            </div>
            
            <div class="achievement-item" id="achievement2">
                <div class="achievement-icon">ğŸ‘¥</div>
                <div class="achievement-info">
                    <h3>ç¤¾äº¤è¾¾äºº</h3>
                    <p>é€šå…³10æ¬¡å¤šäººè”æœºæŒ‘æˆ˜</p>
                    <div class="achievement-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress2"></div>
                        </div>
                        <span id="progressText2">0/10</span>
                    </div>
                </div>
                <div class="achievement-status" id="status2">æœªå®Œæˆ</div>
            </div>
            
            <div class="achievement-item" id="achievement3">
                <div class="achievement-icon">ğŸ’¥</div>
                <div class="achievement-info">
                    <h3>é™·é˜±ä¸“å®¶</h3>
                    <p>èµ°åˆ°é™·é˜±30æ¬¡</p>
                    <div class="achievement-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress3"></div>
                        </div>
                        <span id="progressText3">0/30</span>
                    </div>
                </div>
                <div class="achievement-status" id="status3">æœªå®Œæˆ</div>
            </div>
        </div>
    </div>
    <!-- å•äººæ¸¸æˆç•Œé¢ -->
    <div id="singlePlayerLevelSelect" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">è¿”å›</button>
        <h2 class="level-select-title">é€‰æ‹©å…³å¡</h2>
        <div class="level-container" id="levelContainer"></div>
    </div>

    <div id="singlePlayerGame" class="hidden">
        <button class="settings-button" onclick="showUISettings()">âš™ï¸</button>
        <div class="game-info" id="gameInfo">
            <div class="game-info-item" id="levelDisplay">å…³å¡: 1</div>
            <div class="game-info-item" id="timeDisplay">æ—¶é—´: 0:00</div>
            <div class="game-info-item" id="moveCount">ç§»åŠ¨: 0</div>
            <div class="game-info-item" id="keyStatus">é’¥åŒ™: æœªè·å¾—</div>
        </div>
        <div id="enemyInfo" class="enemy-info hidden">ç§»åŠ¨æ•Œäººæ­£åœ¨è¿½é€ä½ ï¼</div>
        <div id="keyInfo" class="key-info hidden">æ‰¾åˆ°é’¥åŒ™æ‰èƒ½å¼€é—¨ï¼</div>
        <div id="unlockTimer" class="unlock-timer hidden">å¼€é—¨å€’è®¡æ—¶: 10ç§’</div>
        <canvas id="singlePlayerCanvas"></canvas>
        <div class="level-controls">
            <button class="level-control-button reset" onclick="resetSinglePlayerLevel()">é‡ç½®å…³å¡</button>
            <button id="regularNextButton" class="level-control-button next" style="display:none;" onclick="loadNextLevel()">ä¸‹ä¸€å…³</button>
            <button id="unsolvableNextButton" class="level-control-button skip" style="display:none;" onclick="loadNextLevel()">è·³è¿‡æ— è§£å…³å¡</button>
            <!-- <button class="level-control-button exit" onclick="showExitConfirmation()">é€€å‡ºå…³å¡</button> -->
            <button class="level-control-button exit" onclick="showScreen('mainMenu')">é€€å‡ºå…³å¡</button>
            <button class="level-control-button shop-trigger" onclick="openShop()">ğŸ›’ å•†åº—</button>
        </div>
        <!-- æ–¹å‘é”®æ§åˆ¶é¢æ¿ -->
        <div class="controls-panel hidden" id="singlePlayerControls">
            <div class="control-button control-up" onclick="handleControlButtonClick('ArrowUp')">â†‘</div>
            <div class="control-button control-left" onclick="handleControlButtonClick('ArrowLeft')">â†</div>
            <div class="control-button control-right" onclick="handleControlButtonClick('ArrowRight')">â†’</div>
            <div class="control-button control-down" onclick="handleControlButtonClick('ArrowDown')">â†“</div>
        </div>
    </div>

    <div id="singlePlayerComplete" class="level-complete hidden">
        <h2>å…³å¡å®Œæˆ!</h2>
        <p id="singlePlayerCompleteTime">ç”¨æ—¶: 0:00</p>
        <p id="singlePlayerCompleteMoves">ç§»åŠ¨æ¬¡æ•°: 0</p>
        <button onclick="loadNextLevel()">ä¸‹ä¸€å…³</button>
        <button onclick="showScreen('singlePlayerLevelSelect')">é€‰æ‹©å…³å¡</button>
    </div>

    <!-- å¤šäººæ¸¸æˆç•Œé¢ -->
    <div id="multiplayerSetup" class="hidden">
        <div class="multiplayer-setup">
            <h2>å¤šäººæ¸¸æˆè®¾ç½®</h2>
            <div>
                <input type="text" id="playerName" class="setup-input" placeholder="ä½ çš„åå­—" maxlength="10" value="ç©å®¶">
            </div>
            <div>
                <input type="text" id="roomCode" class="setup-input" placeholder="æˆ¿é—´ä»£ç  (ç•™ç©ºåˆ›å»ºæ–°æˆ¿é—´)">
            </div>
            <div class="room-settings">
                <h4>æˆ¿é—´è®¾ç½® (ä»…åˆ›å»ºæˆ¿é—´æ—¶æœ‰æ•ˆ)</h4>
                <div class="setting-row">
                    <label for="maxPlayers">æœ€å¤§äººæ•°:</label>
                    <select id="maxPlayers" class="setup-input">
                        <option value="2">2äºº</option>
                        <option value="3">3äºº</option>
                        <option value="4">4äºº</option>
                        <option value="5">5äºº</option>
                        <option value="6">6äºº</option>
                        <option value="7">7äºº</option>
                        <option value="8">8äºº</option>
                    </select>
                </div>
            </div>
                <button class="menu-button" onclick="connectToMultiplayerGame()">å¼€å§‹æ¸¸æˆ</button>
                <button class="menu-button" onclick="showScreen('mainMenu')">è¿”å›</button>
            </div>
        </div>
    </div>

    <div id="multiplayerGame" class="hidden">
        <button class="settings-button" onclick="showUISettings()">âš™ï¸</button>
        <div class="player-list" id="playerList">
            <h3>ç©å®¶åˆ—è¡¨</h3>
            <div id="playersContainer"></div>
        </div>
        <div class="game-info" id="multiplayerGameInfo">
            <div class="game-info-item" id="multiplayerRoomCode">æˆ¿é—´: </div>
            <div class="game-info-item" id="multiplayerTimeDisplay">æ—¶é—´: 0:00</div>
            <div class="game-info-item" id="multiplayerMoveCount">ç§»åŠ¨: 0</div>
            <div class="game-info-item" id="multiplayerPlayerCount">ç©å®¶: 0/0</div>
        </div>
        <div id="connectionStatus" class="connection-status connected">å·²è¿æ¥</div>
        <canvas id="multiplayerCanvas"></canvas>
        <div class="level-controls">
            <button class="level-control-button reset" onclick="resetMultiplayerPlayer()">é‡ç½®ä½ç½®</button>
            <button class="level-control-button exit" onclick="disconnectMultiplayer()">é€€å‡ºæ¸¸æˆ</button>
        </div>
        <!-- æ–¹å‘é”®æ§åˆ¶é¢æ¿ -->
        <div class="controls-panel hidden" id="multiplayerControls">
            <div class="control-button control-up" onclick="handleControlButtonClick('ArrowUp')">â†‘</div>
            <div class="control-button control-left" onclick="handleControlButtonClick('ArrowLeft')">â†</div>
            <div class="control-button control-right" onclick="handleControlButtonClick('ArrowRight')">â†’</div>
            <div class="control-button control-down" onclick="handleControlButtonClick('ArrowDown')">â†“</div>
        </div>
    </div>

    <!-- æ¸¸æˆè¯´æ˜å¼¹çª— -->
    <div id="instructionsModal" class="instructions-modal hidden">
        <h2>æ¸¸æˆè¯´æ˜</h2>
        <p><strong>å•äººæ¨¡å¼ï¼š</strong>80ä¸ªç‹¬ç‰¹å…³å¡ï¼Œéš¾åº¦é€’å¢ã€‚ä½¿ç”¨æ–¹å‘é”®ç§»åŠ¨è§’è‰²ï¼Œé¿å¼€é™·é˜±ï¼Œæ‰¾åˆ°å‡ºå£ã€‚</p>
        <p><strong>å¤šäººæ¨¡å¼ï¼š</strong>ä¸æœ‹å‹åˆä½œæˆ–ç«äº‰ã€‚åˆ›å»ºæˆ¿é—´æˆ–åŠ å…¥å·²æœ‰æˆ¿é—´ï¼Œå…±åŒå®Œæˆè¿·å®«æŒ‘æˆ˜ã€‚</p>
        <p><strong>è¿·å®«å…ƒç´ ï¼š</strong></p>
        <ul>
            <li>ç»¿è‰²ï¼šç©å®¶</li>
            <li>çº¢è‰²ï¼šå‡ºå£</li>
            <li>é»„è‰²ï¼šé™·é˜±ï¼ˆè§¦ç¢°åå›åˆ°èµ·ç‚¹ï¼‰</li>
            <li>é’è‰²ï¼šä¼ é€é—¨ï¼ˆéšæœºä¼ é€åˆ°å¦ä¸€ä¸ªä¼ é€é—¨ï¼‰</li>
            <li>ç´«è‰²ï¼šç§»åŠ¨é™·é˜±ï¼ˆä¼šç§»åŠ¨çš„å±é™©åŒºåŸŸï¼‰</li>
            <li><span style="color: #f44336">çº¢è‰²é—ªçƒè­¦å‘Š</span>ï¼šç§»åŠ¨æ•Œäººæ­£åœ¨è¿½é€ä½ ï¼</li>
            <li><span style="color: gold">é‡‘è‰²</span>ï¼šé’¥åŒ™ï¼ˆç‰¹æ®Šå…³å¡éœ€è¦é’¥åŒ™æ‰èƒ½å¼€é—¨ï¼‰</li>
            <li><span style="color: #8B4513">æ£•è‰²</span>ï¼šé—¨ï¼ˆéœ€è¦é’¥åŒ™æ‰èƒ½æ‰“å¼€ï¼‰</li>
        </ul>
        <p><strong>ç‰¹æ®Šå…³å¡ï¼š</strong></p>
        <ul>
            <li>ç¬¬30å…³å’Œ60å…³ä¸ºèºæ—‹è¿·å®«ï¼Œä¸­å¿ƒæ˜¯å‡ºå£ï¼Œå¹¶æœ‰ç§»åŠ¨æ•Œäººè¿½é€ç©å®¶ï¼</li>
            <li>ç‰¹æ®Šå…³å¡éœ€è¦æ‰¾åˆ°é’¥åŒ™æ‰èƒ½å¼€é—¨ï¼Œæ‹¿åˆ°é’¥åŒ™åéœ€è¦10ç§’å€’è®¡æ—¶æ‰èƒ½å¼€é—¨</li>
        </ul>
        <button onclick="document.getElementById('instructionsModal').classList.add('hidden')">å…³é—­</button>
    </div>
    
    <!-- UIè®¾ç½®é¢æ¿ -->
    <div id="uiSettingsModal" class="settings-modal hidden">
        <h2>UIè®¾ç½®</h2>
        
        <div class="setting-group">
            <h3>æ§åˆ¶é¢æ¿</h3>
            <label>
                <input type="checkbox" id="showControlsCheckbox"> æ˜¾ç¤ºæ§åˆ¶é¢æ¿
            </label>
            
            <div class="setting-row">
                <label>ä½ç½®:</label>
                <select id="controlsPosition">
                    <option value="bottom-left">å·¦ä¸‹è§’</option>
                    <option value="bottom-right">å³ä¸‹è§’</option>
                    <option value="top-left">å·¦ä¸Šè§’</option>
                    <option value="top-right">å³ä¸Šè§’</option>
                    <option value="custom">è‡ªå®šä¹‰ï¼ˆå®éªŒæ€§åŠŸèƒ½ï¼Œæ‹–åŠ¨ç»¿è‰²æ¡ç§»åŠ¨ï¼‰</option>
                </select>
            </div>
            
            <div class="setting-row">
                <label>å¤§å°:</label>
                <input type="range" id="controlsSize" min="80" max="150" value="100">
            </div>
            
            <div class="setting-row">
                <label>é€æ˜åº¦:</label>
                <input type="range" id="controlsOpacity" min="30" max="100" value="60">
            </div>
        </div>
        
        <div class="setting-group">
            <h3>æ¸¸æˆä¿¡æ¯</h3>
            <label>
                <input type="checkbox" id="showGameInfoCheckbox" checked> æ˜¾ç¤ºæ¸¸æˆä¿¡æ¯
            </label>
            
            <div class="info-settings">
                <div class="setting-checkbox">
                    <input type="checkbox" id="showLevelInfo" checked>
                    <label for="showLevelInfo">å…³å¡ä¿¡æ¯</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showTimeInfo" checked>
                    <label for="showTimeInfo">æ—¶é—´ä¿¡æ¯</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showMoveInfo" checked>
                    <label for="showMoveInfo">ç§»åŠ¨æ¬¡æ•°</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showKeyInfo" checked>
                    <label for="showKeyInfo">é’¥åŒ™çŠ¶æ€</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showRoomInfo" checked>
                    <label for="showRoomInfo">æˆ¿é—´ä»£ç </label>
                </div>
            </div>
        </div>
        <div class="setting-group">
            <h3>å¤šäººæ¸¸æˆè®¾ç½®</h3>
            <label>
                <input type="checkbox" id="showPlayerListCheckbox" checked>
                æ˜¾ç¤ºç©å®¶åˆ—è¡¨
            </label>
        </div>

        <div class="buttons">
            <button onclick="saveUISettings()">ä¿å­˜</button>
            <button onclick="document.getElementById('uiSettingsModal').classList.add('hidden')">å–æ¶ˆ</button>
            <button onclick="checkServerVersion()">æ£€æŸ¥ç‰ˆæœ¬</button>
        </div>
    </div>
    
    <!-- å¼€å‘è€…æ§åˆ¶å° -->
    <div id="console" class="console-container console-hidden">
        <div class="console-header">
            <div class="console-title">å¼€å‘è€…æ§åˆ¶å°</div>
            <button class="console-close" onclick="toggleConsole()">Ã—</button>
        </div>
        <div class="console-output" id="consoleOutput">> æ¬¢è¿ä½¿ç”¨å¼€å‘è€…æ§åˆ¶å°
> è¾“å…¥ 'help' æŸ¥çœ‹å¯ç”¨å‘½ä»¤</div>
        <div class="console-input-group">
            <div class="console-prompt">></div>
            <input type="text"class="console-input"id="consoleInput"placeholder="è¾“å…¥å‘½ä»¤...">
        </div>
    </div>
    <div id="replayModal" class="modal hidden">
        <div class="modal-content" style="max-width:800px">
            <div class="modal-header">
                <h2>æ¸¸æˆå›æ”¾åº“</h2>
                <button class="close-btn" onclick="closeReplayModal()">Ã—</button>
            </div>
            
            <div class="replay-controls">
                <div class="filter-group">
                    <select id="replayFilter">
                        <option value="all">å…¨éƒ¨å½•åƒ</option>
                        <option value="recent">æœ€è¿‘ä¸€å‘¨</option>
                        <option value="best">æœ€ä½³é€šå…³</option>
                    </select>
                </div>
            </div>
            
            <div class="replay-list" id="replayList">
                <!-- åŠ¨æ€ç”Ÿæˆå½•åƒåˆ—è¡¨ -->
            </div>
            
            <div class="player-container hidden" id="playerContainer">
                <div class="player-header">
                    <h3 id="replayTitle">å…³å¡1 - 2023-07-15</h3>
                    <button onclick="exitPlayer()">è¿”å›åˆ—è¡¨</button>
                </div>
                
                <div class="video-container">
                    <canvas id="replayCanvas"></canvas>
                    
                    <div class="player-controls">
                        <button onclick="seekBack()">âª 5ç§’</button>
                        <button onclick="togglePlay()" id="playBtn">â–¶ï¸ æ’­æ”¾</button>
                        <button onclick="seekForward()">â© 5ç§’</button>
                        <span id="timeDisplay">00:00 / 02:30</span>
                        
                        <div class="speed-control">
                            <select id="playbackSpeed">
                                <option value="0.5">0.5Ã—</option>
                                <option value="1" selected>1Ã—</option>
                                <option value="2">2Ã—</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="progress-container">
                        <progress id="replayProgress" value="0" max="100"></progress>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="event-notifications"></div>
    <script>
const CLIENT_VERSION = "1.7.1";
const GAME_SERVER_URL = '/'; // æœåŠ¡å™¨URLï¼Œæ ¹æ®å®é™…æƒ…å†µä¿®æ”¹
async function checkServerVersion() {
    const button = event.target; // è·å–è¢«ç‚¹å‡»çš„æŒ‰é’®æœ¬èº«
    const originalText = button.textContent;
    
    // ç¦ç”¨æŒ‰é’®å¹¶æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    button.disabled = true;
    button.textContent = 'æ£€æŸ¥ä¸­...';
    
    showNotification('æ­£åœ¨æ£€æŸ¥æœåŠ¡å™¨è¿æ¥...', 3000);

    try {
        const fullUrl = window.location.origin + GAME_SERVER_URL + 'api/version-check';

        // ===== ä¿®æ”¹ç‚¹ï¼šåœ¨ fetch è¯·æ±‚ä¸­æ·»åŠ è‡ªå®šä¹‰å¤´ä¿¡æ¯ =====
        const response = await fetch(fullUrl, {
            method: 'GET', // GET è¯·æ±‚ä¹Ÿå¯ä»¥å¸¦ headers
            headers: {
                // 'Content-Type': 'application/json', // GET è¯·æ±‚é€šå¸¸ä¸éœ€è¦è¿™ä¸ª
                'Client-Version': CLIENT_VERSION // è‡ªå®šä¹‰çš„è¯·æ±‚å¤´ï¼Œé”®ä¸º 'Client-Version', å€¼ä¸ºæˆ‘ä»¬çš„ç‰ˆæœ¬å·
            }
        });

        if (!response.ok) {
            throw new Error(`æœåŠ¡å™¨è¿”å›é”™è¯¯: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        console.log('æœåŠ¡å™¨ç‰ˆæœ¬æ£€æŸ¥ç»“æœ:', data);

        // æ ¹æ®è¿”å›çš„çŠ¶æ€å¤„ç†ç»“æœ
        switch(data.status) {
            case 'ok':
                showNotification(`âœ… ç‰ˆæœ¬æ£€æŸ¥æˆåŠŸï¼å½“å‰ç‰ˆæœ¬: ${data.version}`, 4000);
                break;
            case 'outdated':
                 // å¦‚æœéœ€è¦ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ˜¾ç¤ºæ›´è¯¦ç»†çš„æœåŠ¡å™¨ç‰ˆæœ¬
                 const serverVerMsg = data.serverVersion ? `\næœåŠ¡å™¨æœ€æ–°ç‰ˆæœ¬: ${data.serverVersion}` : '';
                 const message = `âš ï¸ æç¤º: æ‚¨çš„æ¸¸æˆç‰ˆæœ¬å·²è¿‡æ—¶ï¼${serverVerMsg}\n\nè¯·åˆ·æ–°é¡µé¢æˆ–è”ç³»ç®¡ç†å‘˜æ›´æ–°æ¸¸æˆã€‚`;
                 alert(message);
                 showNotification('è¯·ç«‹å³æ›´æ–°æ¸¸æˆä»¥ä¿è¯ä½“éªŒï¼', 7000);
                 break;
            case 'error':
            default:
                 showNotification(`âŒ é”™è¯¯: ${data.message || 'æœåŠ¡å™¨è¿”å›äº†é”™è¯¯ä¿¡æ¯'}`, 5000);
        }

    } catch (error) {
        console.error('ç‰ˆæœ¬æ£€æŸ¥è¯·æ±‚å¤±è´¥:', error);
        showNotification(`âŒ æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼\nè¯·ç¡®ä¿æœåŠ¡å™¨æ­£åœ¨è¿è¡Œä¸”IPåœ°å€æ­£ç¡®ã€‚`, 6000);
    } finally {
        button.disabled = false;
        button.textContent = originalText;
    }
}
let teleportSelectionMode = false;
const modal = document.createElement('div');
window.addEventListener('load', function() {
    const levelContainer = document.getElementById('levelContainer');
    let startY = 0;
    let isScrolling = false;
    // è§¦æ‘¸å¼€å§‹äº‹ä»¶
    levelContainer.addEventListener('touchstart', function(e) {
        startY = e.touches[0].clientY;
        isScrolling = true;
    }, { passive: true }); // ä½¿ç”¨passiveæ”¹å–„æ»šåŠ¨æ€§èƒ½
    // è§¦æ‘¸ç§»åŠ¨äº‹ä»¶
    levelContainer.addEventListener('touchmove', function(e) {
        if (!isScrolling) return;
        
        const y = e.touches[0].clientY;
        const scrollTop = levelContainer.scrollTop;
        const scrollerHeight = levelContainer.scrollHeight;
        const containerHeight = levelContainer.clientHeight;
        
        // é˜²æ­¢åœ¨é¡¶éƒ¨ä¸‹æ‹‰æˆ–åº•éƒ¨ä¸Šæ‹‰
        if ((scrollTop <= 0 && y > startY) || 
            (scrollTop >= scrollerHeight - containerHeight && y < startY)) {
            e.preventDefault();
        }
        
        startY = y;
    }, { passive: false });
    // è§¦æ‘¸ç»“æŸäº‹ä»¶
    levelContainer.addEventListener('touchend', function() {
        isScrolling = false;
    }, { passive: true });
});
        let singlePlayerGame = {
            canvas: null,
            ctx: null,
            maze: [],
            player: { x: 1, y: 1 },
            exit: { x: 0, y: 0 },
            cellSize: 30,
            startTime: 0,
            timerInterval: null,
            moveCount: 0,
            teleporters: [],
            movingTraps: [],
            movingEnemies: [],
            difficultySettings: [
                { size: 7, wallDensity: 0.3, traps: 0, movingTraps: 0, oneWayPaths: 0 },
                { size: 9, wallDensity: 0.35, traps: 1, movingTraps: 0, oneWayPaths: 0 },
                { size: 11, wallDensity: 0.4, traps: 2, movingTraps: 1, oneWayPaths: 0 },
                { size: 13, wallDensity: 0.45, traps: 4, movingTraps: 1, oneWayPaths: 1 },
                { size: 15, wallDensity: 0.5, traps: 6, movingTraps: 2, oneWayPaths: 1 },
                { size: 17, wallDensity: 0.55, traps: 8, movingTraps: 3, oneWayPaths: 2 },
                { size: 19, wallDensity: 0.6, traps: 10, movingTraps: 4, oneWayPaths: 3 },
                { size: 21, wallDensity: 0.65, traps: 12, movingTraps: 5, oneWayPaths: 4 },
                { size: 23, wallDensity: 0.7, traps: 14, movingTraps: 6, oneWayPaths: 5 },
                { size: 25, wallDensity: 0.75, traps: 16, movingTraps: 7, oneWayPaths: 6 }
            ],
            hasKey: false,
            doorPosition: null,
            keyPosition: null,
            isUnlocking: false,
            unlockTimeLeft: 0,
            unlockTimer: null
        };

        class Random {
            constructor(seed) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
        }
let consoleVisible = false;
let consoleHistory = [];
let historyIndex = -1;
        // æ¸¸æˆçŠ¶æ€ç®¡ç†
        const gameState = {
            coins: 0, // ç©å®¶æŒæœ‰çš„é‡‘å¸æ•°é‡
            currentScreen: 'mainMenu',
            unlockedLevel: parseInt(localStorage.getItem('unlockedLevel')) || 1,
            completedLevels: JSON.parse(localStorage.getItem('completedLevels')) || [],
            currentLevel: 1,
            playerName: 'ç©å®¶' + Math.floor(Math.random() * 1000),
            unsolvableLevels: [15, 20, 25, 34, 35, 38, 40, 41, 49, 52, 55, 65,73], // æ— è§£å…³å¡åˆ—è¡¨
            specialLevels: [20, 30, 60], // éœ€è¦é’¥åŒ™çš„ç‰¹æ®Šå…³å¡
            controlsReversed: false,
            playerData: {
                coins: 0,
            },
            multiplayer: {
                connected: false,
                peer: null,
                connections: {},
                players: {},
                currentPlayerId: null,
                roomCode: null,
                isHost: false,
                maze: [],
                startTime: 0,
                timerInterval: null,
                moveCount: 0,
                maxPlayers: 2, // é»˜è®¤æœ€å¤§äººæ•°
                protectedPlayers: {}, // å—ä¿æŠ¤ç©å®¶åˆ—è¡¨
                showPlayerList: true,
                unlockTimeLeft:10
            },
            devMode: false,
            uiSettings: JSON.parse(localStorage.getItem('uiSettings')) || {
                showControls: true,
                controlsPosition: 'bottom-left',
                controlsSize: 100,
                controlsOpacity: 60,
                showGameInfo: true,
                showLevelInfo: true,
                showTimeInfo: true,
                showMoveInfo: true,
                showKeyInfo: true,
                showRoomInfo: true,
                // æ·»åŠ è‡ªå®šä¹‰ä½ç½®çš„xå’Œyåæ ‡
                customX: null,
                customY: null
            },
            // æ–°åŠŸèƒ½çŠ¶æ€
            achievements: JSON.parse(localStorage.getItem('achievements')) || {
                allLevelsCompleted: false,
                multiplayerWins: 0,
                trapHits: 0
            },
            
            gameStats: JSON.parse(localStorage.getItem('gameStats')) || {
                timeChallengeBest: 0,
                puzzleLevelsCompleted: 0,
                totalLevelsCompleted: 0
            },
            
            settings: JSON.parse(localStorage.getItem('gameSettings')) || {
                autoSave: true
            },
            
            currentChallenge: null, // 'time' æˆ– 'puzzle'
            saveSlots: JSON.parse(localStorage.getItem('saveSlots')) || [{}, {}, {}],
            currentSaveSlot: 0,
            autoSave: false
            
        };
// å¢™å£æ¶ˆå¤±æ¨¡å¼
let wallRemovalMode = false;
function startWallRemovalMode() {
    if (gameState.currentScreen !== 'singlePlayerGame') {
        showNotification('è¯·åœ¨å•äººæ¸¸æˆä¸­ä½¿ç”¨æ­¤é“å…·ï¼');
        return;
    }
    wallRemovalMode = true;
    showNotification('å¢™å£æ¶ˆå¤±æ¨¡å¼å·²æ¿€æ´»ï¼Œç‚¹å‡»åœ°å›¾ä¸Šçš„å¢™å£æ¥ç§»é™¤å®ƒã€‚');
    document.getElementById('singlePlayerCanvas').style.cursor = 'crosshair';
}

// æ‰“å¼€å•†åº—
function openShop() {
    document.getElementById('shopModal').classList.remove('hidden');
    // æ‰“å¼€å•†åº—æ—¶æ›´æ–°æ‰€æœ‰æŒ‰é’®çš„çŠ¶æ€
    updateShopButtons();
}

// å…³é—­å•†åº—
function closeShop() {
    document.getElementById('shopModal').classList.add('hidden');
}

// æ›´æ–°å•†åº—æŒ‰é’®çš„å¯ç”¨çŠ¶æ€
function updateShopButtons() {
    const buttons = document.querySelectorAll('.buy-btn');
    buttons.forEach(btn => {
        const itemKey = btn.parentElement.dataset.item;
        const item = SHOP_ITEMS[itemKey];
        if (item && gameState.coins < item.price) {
            btn.disabled = true;
            btn.textContent = 'é‡‘å¸ä¸è¶³';
        } else {
            btn.disabled = false;
            btn.textContent = 'è´­ä¹°';
        }
    });
}

// å•†åº—ç‰©å“é…ç½®
const SHOP_ITEMS = {
    'clear-events': { price: 20, name: 'æ•ˆæœæ¸…é™¤' },
    'remove-wall': { price: 15, name: 'å¢™å£æ¶ˆå¤±' },
    'teleport': { price: 25, name: 'ä¼ é€é—¨' }
};

// è´­ä¹°ç‰©å“
function buyItem(itemKey) {
    const item = SHOP_ITEMS[itemKey];
    if (!item) return;

    if (gameState.coins >= item.price) {
        gameState.coins -= item.price;
        gameState.playerData.coins = gameState.coins;
        updateCoinDisplay();
        updateShopButtons(); // æ›´æ–°æŒ‰é’®çŠ¶æ€
        showNotification(`æˆåŠŸè´­ä¹° ${item.name}ï¼`);
        
        // é“å…·æ·»åŠ åˆ°èƒŒåŒ…ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œç›´æ¥æ¿€æ´»æ•ˆæœ
        // åœ¨å®é™…ä¸­ï¼Œä½ å¯èƒ½éœ€è¦ä¸€ä¸ªèƒŒåŒ…ç³»ç»Ÿæ¥å­˜å‚¨é“å…·
        activateItem(itemKey);
        
    } else {
        showNotification('é‡‘å¸ä¸è¶³ï¼Œæ— æ³•è´­ä¹°ï¼');
    }
}

// æ¿€æ´»é“å…·æ•ˆæœ
function activateItem(itemKey) {
    switch(itemKey) {
        case 'clear-events':
            if (Object.keys(EventSystem.activeEvents).length > 0) {
                // è°ƒç”¨æ‰€æœ‰äº‹ä»¶çš„æ¸…ç†å‡½æ•°
                Object.values(EventSystem.activeEvents).forEach(event => {
                    if (event.cleanup) event.cleanup();
                });
                EventSystem.activeEvents = {}; // æ¸…ç©ºäº‹ä»¶
                showNotification('æ‰€æœ‰éšæœºäº‹ä»¶å·²æ¸…é™¤ï¼');
            } else {
                showNotification('å½“å‰æ²¡æœ‰è§¦å‘çš„éšæœºäº‹ä»¶ã€‚');
            }
            break;
            
        case 'remove-wall':
            startWallRemovalMode();
            break;
            
        case 'teleport':
            if (gameState.currentScreen === 'singlePlayerGame') {
                startTeleportSelectionMode();
            } else {
                showNotification('æ­¤é“å…·ä»…åœ¨å•äººæ¸¸æˆä¸­å¯ç”¨ï¼');
            }
            break;
    }
}

function createCoinDisplay() {
    const coinDisplay = document.createElement('div');
    coinDisplay.id = 'coinDisplay';
    coinDisplay.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: gold;
        padding: 10px 15px;
        border-radius: 8px;
        font-family: monospace;
        font-size: 18px;
        font-weight: bold;
        z-index: 100;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        display: none; /* é»˜è®¤éšè— */
    `;
    coinDisplay.innerHTML = `
        <span style="color: gold;">ğŸª™</span>
        <span id="coinCount">0</span>
    `;
    document.body.appendChild(coinDisplay);
}

// æ˜¾ç¤ºé‡‘å¸UI
function showCoinDisplay() {
    document.getElementById('coinDisplay').style.display = 'block';
}

// éšè—é‡‘å¸UI
function hideCoinDisplay() {
    document.getElementById('coinDisplay').style.display = 'none';
}

// æ›´æ–°é‡‘å¸æ•°é‡
function updateCoinDisplay() {
    document.getElementById('coinCount').textContent = gameState.coins;
}
function startTeleportSelectionMode(targetPlayerId = null) {
    // ä¿å­˜å½“å‰æ¸¸æˆçŠ¶æ€å’Œç›®æ ‡ç©å®¶
    gameState.mapSelectionMode = true;
    gameState.mapSelectionTarget = targetPlayerId;
    
    // æ·»åŠ åœ°å›¾ç‚¹å‡»äº‹ä»¶ç›‘å¬
    if (gameState.currentScreen === 'singlePlayerGame') {
        singlePlayerGame.canvas.addEventListener('click', handleMapClick);
        document.getElementById('consoleOutput').innerHTML += 
            '\nåœ°å›¾é€‰æ‹©æ¨¡å¼å·²æ¿€æ´»ï¼Œç‚¹å‡»åœ°å›¾ä¸Šçš„ä½ç½®è¿›è¡Œä¼ é€';
            console.log('åœ°å›¾é€‰æ‹©æ¨¡å¼å·²æ¿€æ´»');
            showNotification('åœ°å›¾é€‰æ‹©æ¨¡å¼å·²æ¿€æ´»ï¼Œç‚¹å‡»åœ°å›¾ä¸Šçš„ä½ç½®è¿›è¡Œä¼ é€');
    } else {
        document.getElementById('consoleOutput').innerHTML += 
            '\nåœ°å›¾é€‰æ‹©æ¨¡å¼åªèƒ½åœ¨å•äººæ¸¸æˆä¸­è¿›è¡Œ';
        gameState.mapSelectionMode = false;
    }
}
// æ·»åŠ é‡‘å¸
function addCoins(amount) {
    gameState.coins += amount;
    // åŒæ—¶ä¹Ÿæ›´æ–° playerData ä¸­çš„ï¼Œä»¥ä¾¿äºä¿å­˜
    gameState.playerData.coins = gameState.coins;
    updateCoinDisplay();
    
    // æ˜¾ç¤ºè·å¾—é‡‘å¸çš„æç¤º
    showNotification(`è·å¾— ${amount} ä¸ªé‡‘å¸ï¼`);
}

// åœ¨é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–é‡‘å¸æ˜¾ç¤º
window.addEventListener('load', () => {
    createCoinDisplay();
    // ä» localStorage åŠ è½½é‡‘å¸ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆå§‹åŒ–ä¸º0
    gameState.coins = parseInt(localStorage.getItem('playerCoins')) || 0;
    gameState.playerData.coins = gameState.coins;
    // åˆå§‹ä¸æ˜¾ç¤ºï¼Œåœ¨æ¸¸æˆå¼€å§‹æ—¶å†æ˜¾ç¤º
});

const EventSystem = {
  events: [],
  activeEvents: {},
  cooldowns: {},

  init() {
    setInterval(() => this.checkEvents(), 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
  },

  register(event) {
    this.events.push(event);
  },

  checkEvents() {
    if (gameState.currentScreen !== 'singlePlayerGame') return;

    this.events.forEach(event => {
      if (this.shouldTrigger(event)) {
        this.trigger(event);
      }
    });
  },

  shouldTrigger(event) {
    // æ£€æŸ¥å†·å´
    if (this.cooldowns[event.id] > Date.now()) return false;
    // æ£€æŸ¥æ¦‚ç‡
    return Math.random() < (event.probability || 0.1);
  },

  trigger(event) {
    // æ‰§è¡Œæ•ˆæœ
    const cleanup = event.effect();
    
    // è®¾ç½®å†·å´
    this.cooldowns[event.id] = Date.now() + (event.cooldown || 60000);
    if (!event || typeof event.effect !== 'function') {
        console.error('é”™è¯¯çš„äº‹ä»¶:', event);
        return; // ç›´æ¥è¿”å›ï¼Œé˜²æ­¢æŠ¥é”™
    }
    // å­˜å‚¨æ¸…ç†å‡½æ•°
    if (cleanup) {
      this.activeEvents[event.id] = {
        endTime: Date.now() + (event.duration || 10000),
        cleanup
      };
    }

    // æ˜¾ç¤ºé€šçŸ¥
    this.showNotification(event.name, event.description);
  },

  showNotification(title, text) {
    const div = document.createElement('div');
    div.className = 'event-notification';
    div.innerHTML = `<b>${title}</b>: ${text}`;
    document.getElementById('event-notifications').appendChild(div);
    setTimeout(() => div.remove(), 5000);
  },

  update() {
    const now = Date.now();
    Object.keys(this.activeEvents).forEach(id => {
      if (now >= this.activeEvents[id].endTime) {
        this.activeEvents[id].cleanup();
        delete this.activeEvents[id];
      }
    });
  },
  triggerById(eventId) {
    const event = this.events.find(e => 
    e.id.toLowerCase() === eventId.toLowerCase()
    );
    if (!event) {
      console.error(`äº‹ä»¶ä¸å­˜åœ¨: ${eventId}`);
      return;
    }
    // æ‰§è¡Œæ•ˆæœ
    const cleanup = event.effect();
    
    // è®¾ç½®å†·å´ï¼ˆå³ä½¿å¼ºåˆ¶è§¦å‘ä¹Ÿä»ç„¶åº”ç”¨å†·å´ï¼‰
    this.cooldowns[event.id] = Date.now() + (event.cooldown || 60000);
    
    // å­˜å‚¨æ¸…ç†å‡½æ•°
    if (cleanup) {
      this.activeEvents[event.id] = {
        endTime: Date.now() + (event.duration || 10000),
        cleanup
      };
    }
    // æ˜¾ç¤ºé€šçŸ¥
    this.showNotification(event.name, `[å¼ºåˆ¶è§¦å‘] ${event.description}`);
    }
}
// åˆå§‹åŒ–
EventSystem.init();
// æ§åˆ¶åè½¬äº‹ä»¶
// ä¿®æ”¹åçš„åè½¬æ§åˆ¶äº‹ä»¶
EventSystem.register({
  id: 'reverse-controls',
  name: 'æ–¹å‘æ··ä¹±',
  description: 'æ§åˆ¶æ–¹å‘æš‚æ—¶åè½¬!æŒç»­æ—¶é—´: 20ç§’',
  probability: 0.1,  // 10%æ¦‚ç‡è§¦å‘
  cooldown: 30000,   // 30ç§’å†·å´
  effect: () => {
    const originalHandler = handleSinglePlayerKeyDown;
    
    // æ˜¾ç¤ºæç¤º
    const notification = document.createElement('div');
    notification.className = 'event-notification';
    notification.innerHTML = '<b>æ–¹å‘æ··ä¹±ï¼</b> æ–¹å‘æ§åˆ¶å·²æš‚æ—¶åè½¬';
    document.getElementById('event-notifications').appendChild(notification);
    setTimeout(() => notification.remove(), 3000);
    
    // åè½¬æ§åˆ¶çŠ¶æ€
    gameState.controlsReversed = true;
    
    // 50ç§’åè‡ªåŠ¨æ¢å¤
    setTimeout(() => {
      gameState.controlsReversed = false;
      const endNotification = document.createElement('div');
      endNotification.className = 'event-notification';
      endNotification.innerHTML = '<b>æ–¹å‘æ¢å¤æ­£å¸¸</b>';
      document.getElementById('event-notifications').appendChild(endNotification);
      setTimeout(() => endNotification.remove(), 3000);
    }, 20000);

    return () => {
      
      gameState.controlsReversed = false;
    };
  }
});

// è§£è°œæ¨¡å¼çŠ¶æ€
gameState.puzzleMode = {
    buttons: [], // æŒ‰é’®ä½ç½®æ•°ç»„ [{x, y, id, pressed, color}]
    correctSequence: [], // æ­£ç¡®é¡ºåº [buttonId1, buttonId2, ...]
    currentSequence: [], // å½“å‰ç©å®¶æŒ‰ä¸‹çš„é¡ºåº
    doorPosition: null, // å¤§é—¨ä½ç½®
    doorOpened: false // å¤§é—¨æ˜¯å¦å·²æ‰“å¼€
};
// éšæœºäº‹ä»¶ç³»ç»Ÿ

// è§£è°œæ¨¡å¼
function startPuzzleMode() {
    gameState.currentChallenge = 'puzzle';
    gameState.currentLevel = 1;
    showScreen('singlePlayerGame');
    
    // åˆå§‹åŒ–è§£è°œæ¨¡å¼
    initPuzzleMode();
}

// åˆå§‹åŒ–è§£è°œæ¨¡å¼
function initPuzzleMode() {
    // æ˜¾ç¤ºè§£è°œæ¨¡å¼UI
    document.getElementById('puzzleInfo').classList.remove('hidden');
    document.getElementById('sequenceDisplay').classList.remove('hidden');
    
    // é‡ç½®è§£è°œçŠ¶æ€
    gameState.puzzleMode = {
        buttons: [],
        correctSequence: [],
        currentSequence: [],
        doorPosition: null,
        doorOpened: false
    };
    
    // ç”Ÿæˆè§£è°œè¿·å®«
    generatePuzzleMaze();
    
    // æ›´æ–°åºåˆ—æ˜¾ç¤º
    updateSequenceDisplay();
}


// ç”Ÿæˆè§£è°œè¿·å®«
function generatePuzzleMaze() {
    const size = 15;
    singlePlayerGame.maze = Array(size).fill().map(() => Array(size).fill(1));
    
    // ä½¿ç”¨Primç®—æ³•ç”ŸæˆåŸºæœ¬è¿·å®«
    const walls = [];
    singlePlayerGame.maze[1][1] = 0;
    walls.push(...getCellWalls(1, 1, singlePlayerGame.maze));
    
    while (walls.length > 0) {
        const wallIndex = Math.floor(Math.random() * walls.length);
        const wall = walls[wallIndex];
        walls.splice(wallIndex, 1);
        
        const opposite = getOppositeCell(wall, singlePlayerGame.maze);
        
        if (opposite.x > 0 && opposite.x < size-1 && 
            opposite.y > 0 && opposite.y < size-1 && 
            singlePlayerGame.maze[opposite.y][opposite.x] === 1) {
            
            singlePlayerGame.maze[wall.y][wall.x] = 0;
            singlePlayerGame.maze[opposite.y][opposite.x] = 0;
            walls.push(...getCellWalls(opposite.x, opposite.y, singlePlayerGame.maze));
        }
    }
    
    // è®¾ç½®èµ·ç‚¹å’Œå‡ºå£
    singlePlayerGame.player = { x: 1, y: 1 };
    singlePlayerGame.exit = { x: size-2, y: size-2 };
    
    // æ·»åŠ æŒ‰é’®ï¼ˆ4-5ä¸ªæŒ‰é’®ï¼‰
    const buttonCount = 4 + Math.floor(Math.random() * 2);
    const buttonColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
    
    for (let i = 0; i < buttonCount; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(Math.random() * (size-4)) + 2;
            y = Math.floor(Math.random() * (size-4)) + 2;
            attempts++;
        } while ((singlePlayerGame.maze[y][x] !== 0 || 
                  isNearPlayer(x, y) ||
                  gameState.puzzleMode.buttons.some(b => b.x === x && b.y === y)) && 
                 attempts < 50);
        
        if (attempts < 50) {
            singlePlayerGame.maze[y][x] = 10 + i; // 10-14 è¡¨ç¤ºæŒ‰é’®
            gameState.puzzleMode.buttons.push({
                x, y, 
                id: i,
                pressed: false,
                color: buttonColors[i]
            });
        }
    }
    
    // è®¾ç½®æ­£ç¡®é¡ºåºï¼ˆéšæœºæ‰“ä¹±ï¼‰
    gameState.puzzleMode.correctSequence = [];
    for (let i = 0; i < buttonCount; i++) {
        gameState.puzzleMode.correctSequence.push(i);
    }
    // éšæœºæ‰“ä¹±é¡ºåº
    gameState.puzzleMode.correctSequence.sort(() => Math.random() - 0.5);
    
    // æ·»åŠ å¤§é—¨
    let doorX = singlePlayerGame.exit.x;
    let doorY = singlePlayerGame.exit.y;
    
    // åœ¨å‡ºå£å‰æ”¾ç½®é—¨
    if (doorX < size-1 && singlePlayerGame.maze[doorY][doorX+1] === 0) {
        doorX++;
    } else if (doorX > 0 && singlePlayerGame.maze[doorY][doorX-1] === 0) {
        doorX--;
    } else if (doorY < size-1 && singlePlayerGame.maze[doorY+1][doorX] === 0) {
        doorY++;
    } else if (doorY > 0 && singlePlayerGame.maze[doorY-1][doorX] === 0) {
        doorY--;
    }
    
    singlePlayerGame.maze[doorY][doorX] = 9; // 9 è¡¨ç¤ºé—¨
    gameState.puzzleMode.doorPosition = {x: doorX, y: doorY};
    
    // è°ƒæ•´ç”»å¸ƒå¤§å°å¹¶ç»˜åˆ¶
    resizeSinglePlayerCanvas();
    drawSinglePlayerMaze();
}

// æ£€æŸ¥æ˜¯å¦é è¿‘ç©å®¶èµ·ç‚¹
function isNearPlayer(x, y) {
    return Math.abs(x - 1) <= 2 && Math.abs(y - 1) <= 2;
}

// å¤„ç†æŒ‰é’®æŒ‰ä¸‹
function handleButtonPress(buttonId) {
    const button = gameState.puzzleMode.buttons.find(b => b.id === buttonId);
    if (!button || button.pressed) return;
    
    // æ·»åŠ åˆ°å½“å‰åºåˆ—
    gameState.puzzleMode.currentSequence.push(buttonId);
    
    // æ ‡è®°æŒ‰é’®ä¸ºå·²æŒ‰ä¸‹
    button.pressed = true;
    
    // æ›´æ–°æ˜¾ç¤º
    updateSequenceDisplay();
    
    // æ£€æŸ¥åºåˆ—æ˜¯å¦æ­£ç¡®
    checkSequence();
    
    // é‡æ–°ç»˜åˆ¶è¿·å®«ä»¥æ˜¾ç¤ºæŒ‰ä¸‹çš„æŒ‰é’®
    drawSinglePlayerMaze();
}

// æ›´æ–°åºåˆ—æ˜¾ç¤º
function updateSequenceDisplay() {
    const display = document.getElementById('sequenceDisplay');
    let sequenceText = 'å½“å‰é¡ºåº: ';
    
    if (gameState.puzzleMode.currentSequence.length === 0) {
        sequenceText += 'æ— ';
        display.className = 'sequence-display';
    } else {
        sequenceText += gameState.puzzleMode.currentSequence.map(id => {
            const button = gameState.puzzleMode.buttons.find(b => b.id === id);
            return `<span style="color:${button.color}">â—</span>`;
        }).join(' ');
        
        // æ£€æŸ¥å½“å‰åºåˆ—æ˜¯å¦æ­£ç¡®
        const isCorrectSoFar = gameState.puzzleMode.currentSequence.every((id, index) => 
            id === gameState.puzzleMode.correctSequence[index]
        );
        
        if (isCorrectSoFar) {
            display.className = 'sequence-display sequence-correct';
        } else {
            display.className = 'sequence-display sequence-wrong';
        }
    }
    
    display.innerHTML = sequenceText;
}

// æ£€æŸ¥åºåˆ—
function checkSequence() {
    const current = gameState.puzzleMode.currentSequence;
    const correct = gameState.puzzleMode.correctSequence;
    
    // æ£€æŸ¥æ˜¯å¦å®Œå…¨æ­£ç¡®
    if (current.length === correct.length && 
        current.every((id, index) => id === correct[index])) {
        
        // åºåˆ—æ­£ç¡®ï¼Œæ‰“å¼€å¤§é—¨
        openPuzzleDoor();
    } else if (current.length > 0) {
        // æ£€æŸ¥å½“å‰éƒ¨åˆ†æ˜¯å¦æ­£ç¡®
        const isCorrectSoFar = current.every((id, index) => id === correct[index]);
        
        if (!isCorrectSoFar) {
            // åºåˆ—é”™è¯¯ï¼Œé‡ç½®
            setTimeout(() => {
                resetPuzzleSequence();
                alert('é¡ºåºé”™è¯¯ï¼è¯·é‡æ–°å¼€å§‹ã€‚');
            }, 500);
        }
    }
}

// æ‰“å¼€è§£è°œå¤§é—¨
function openPuzzleDoor() {
    gameState.puzzleMode.doorOpened = true;
    
    // å°†é—¨å˜ä¸ºé€šè·¯
    singlePlayerGame.maze[gameState.puzzleMode.doorPosition.y][gameState.puzzleMode.doorPosition.x] = 0;
    
    // æ˜¾ç¤ºæˆåŠŸä¿¡æ¯
    document.getElementById('sequenceDisplay').innerHTML = 
        '<span style="color:#4CAF50">âœ“ åºåˆ—æ­£ç¡®ï¼å¤§é—¨å·²æ‰“å¼€</span>';
    
    // é‡æ–°ç»˜åˆ¶è¿·å®«
    drawSinglePlayerMaze();
    
    alert('æ­å–œï¼é¡ºåºæ­£ç¡®ï¼Œå¤§é—¨å·²ç»æ‰“å¼€ï¼');
}

// é‡ç½®è§£è°œåºåˆ—
function resetPuzzleSequence() {
    // é‡ç½®æ‰€æœ‰æŒ‰é’®çŠ¶æ€
    gameState.puzzleMode.buttons.forEach(button => {
        button.pressed = false;
    });
    
    // æ¸…ç©ºå½“å‰åºåˆ—
    gameState.puzzleMode.currentSequence = [];
    
    // æ›´æ–°æ˜¾ç¤º
    updateSequenceDisplay();
    
    // é‡æ–°ç»˜åˆ¶è¿·å®«
    drawSinglePlayerMaze();
}

// ä¿®æ”¹ç»˜åˆ¶å‡½æ•°ä»¥æ˜¾ç¤ºæŒ‰é’®
function drawSinglePlayerMaze() {
    const ctx = singlePlayerGame.ctx;
    ctx.clearRect(0, 0, singlePlayerGame.canvas.width, singlePlayerGame.canvas.height);
    
    // ç»˜åˆ¶è¿·å®«ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
    for (let y = 0; y < singlePlayerGame.maze.length; y++) {
        for (let x = 0; x < singlePlayerGame.maze[y].length; x++) {
            const cellValue = singlePlayerGame.maze[y][x];
            let fillStyle = '#111';
            
            switch(cellValue) {
                case 1: fillStyle = '#333'; break; // å¢™
                case 2: fillStyle = '#FF0'; break; // é™·é˜±
                case 3: fillStyle = '#0FF'; break; // ä¼ é€é—¨
                case 9: fillStyle = '#8B4513'; break; // é—¨
                default: 
                    if (cellValue >= 10 && cellValue <= 20) {
                        // æŒ‰é’®
                        const buttonId = cellValue - 10;
                        const button = gameState.puzzleMode.buttons.find(b => b.id === buttonId);
                        if (button) {
                            fillStyle = button.pressed ? '#666' : button.color;
                        }
                    }
            }
            
            ctx.fillStyle = fillStyle;
            ctx.fillRect(x * singlePlayerGame.cellSize, y * singlePlayerGame.cellSize, 
                        singlePlayerGame.cellSize, singlePlayerGame.cellSize);
            
            // ç»˜åˆ¶æŒ‰é’®ç¼–å·ï¼ˆå¦‚æœæ˜¯è§£è°œæ¨¡å¼ï¼‰
            if (cellValue >= 10 && cellValue <= 20) {
                const buttonId = cellValue - 10;
                ctx.fillStyle = '#000';
                ctx.font = 'bold ' + (singlePlayerGame.cellSize/3) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((buttonId + 1).toString(), 
                    x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                    y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2
                );
            }
        }
    }
    
    // ç»˜åˆ¶å‡ºå£å’Œç©å®¶ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
    ctx.fillStyle = '#F00';
    ctx.fillRect(singlePlayerGame.exit.x * singlePlayerGame.cellSize, 
                singlePlayerGame.exit.y * singlePlayerGame.cellSize, 
                singlePlayerGame.cellSize, singlePlayerGame.cellSize);
    
    ctx.fillStyle = '#4CAF50';
    ctx.beginPath();
    ctx.arc(
        singlePlayerGame.player.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
        singlePlayerGame.player.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
        singlePlayerGame.cellSize/2 - 2,
        0,
        Math.PI * 2
    );
    ctx.fill();
}



        // åº”ç”¨UIè®¾ç½®
        function applyUISettings() {
            const settings = gameState.uiSettings;
            
            // åº”ç”¨æ§åˆ¶é¢æ¿è®¾ç½®
            const controlsPanel = document.getElementById('singlePlayerControls') || 
                                 document.getElementById('multiplayerControls');
            
            if (controlsPanel) {
                controlsPanel.classList.toggle('hidden', !settings.showControls);
                
                // è®¾ç½®ä½ç½®
                controlsPanel.style.position = 'fixed';
                controlsPanel.style.left = '';
                controlsPanel.style.right = '';
                controlsPanel.style.top = '';
                controlsPanel.style.bottom = '';
                
                if (settings.controlsPosition === 'custom' && settings.customX !== null && settings.customY !== null) {
                    controlsPanel.style.left = settings.customX + 'px';
                    controlsPanel.style.top = settings.customY + 'px';
                } else {
                    switch(settings.controlsPosition) {
                        case 'bottom-left':
                            controlsPanel.style.left = '20px';
                            controlsPanel.style.bottom = '20px';
                            break;
                        case 'bottom-right':
                            controlsPanel.style.right = '20px';
                            controlsPanel.style.bottom = '20px';
                            break;
                        case 'top-left':
                            controlsPanel.style.left = '20px';
                            controlsPanel.style.top = '20px';
                            break;
                        case 'top-right':
                            controlsPanel.style.right = '20px';
                            controlsPanel.style.top = '20px';
                            break;
                    }
                }
            }
            
            // åº”ç”¨æ¸¸æˆä¿¡æ¯è®¾ç½®
            const gameInfo = document.getElementById('gameInfo');
            const multiplayerGameInfo = document.getElementById('multiplayerGameInfo');
            
            if (gameInfo) {
                gameInfo.style.display = settings.showGameInfo ? 'flex' : 'none';
                // éšè—/æ˜¾ç¤ºå„ä¸ªä¿¡æ¯é¡¹
                const infoItems = ['levelDisplay', 'timeDisplay', 'moveCount', 'keyStatus'];
                infoItems.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = settings[`show${id.charAt(0).toUpperCase() + id.slice(1).replace('Display', 'Info').replace('Count', 'Info')}`] ? 'flex' : 'none';
                    }
                });
            }
            
            if (multiplayerGameInfo) {
                multiplayerGameInfo.style.display = settings.showGameInfo ? 'flex' : 'none';
                // éšè—/æ˜¾ç¤ºå„ä¸ªä¿¡æ¯é¡¹
                const multiplayerInfoItems = ['multiplayerRoomCode', 'multiplayerTimeDisplay', 'multiplayerMoveCount', 'multiplayerPlayerCount'];
                multiplayerInfoItems.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = settings[`show${id.includes('Room') ? 'Room' : id.includes('Time') ? 'Time' : id.includes('Move') ? 'Move' : 'Room'}Info`] ? 'flex' : 'none';
                    }
                });
            }
            
            // åº”ç”¨ç©å®¶åˆ—è¡¨è®¾ç½®
            const playerList = document.getElementById('playerList');
            if (playerList) {
                playerList.style.display = gameState.uiSettings.showPlayerList ? 'block' : 'none';
            }
        } 
        function showScreen(screenId) {
            // éšè—æ‰€æœ‰å±å¹•
            const screens = [
                'mainMenu', 'singlePlayerLevelSelect', 'singlePlayerGame', 
                'singlePlayerComplete', 'multiplayerSetup', 'multiplayerGame',
                'achievementsScreen', 'moreChallengesScreen'
            ];
            
            screens.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.classList.add('hidden');
                }
            });
            
            // æ˜¾ç¤ºè¯·æ±‚çš„å±å¹•
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.remove('hidden');
            }
            
            gameState.currentScreen = screenId;
            
            // æ‰§è¡Œå±å¹•ç‰¹å®šçš„åˆå§‹åŒ–
            switch(screenId) {
                case 'singlePlayerLevelSelect':
                    generateLevelButtons();
                    break;
                case 'singlePlayerGame':
                    initSinglePlayerGame();
                    EventSystem.init();
                    break;
                case 'multiplayerSetup':
                    document.getElementById('playerName').value = gameState.playerName;
                    break;
                case 'multiplayerGame':
                    break;
                case 'moreChallengesScreen':
                    updateChallengesStats();
                    break;
                case 'achievementsScreen':
                    updateAchievementProgress();
                    break;
            }

            // æ˜¾ç¤º/éšè—æ§åˆ¶é¢æ¿
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const singlePlayerControls = document.getElementById('singlePlayerControls');
            const multiplayerControls = document.getElementById('multiplayerControls');
            
            if (singlePlayerControls) {
                singlePlayerControls.classList.toggle('hidden', screenId !== 'singlePlayerGame' || !isMobile);
            }
            if (multiplayerControls) {
                multiplayerControls.classList.toggle('hidden', screenId !== 'multiplayerGame' || !isMobile);
            }
            
            // åº”ç”¨UIè®¾ç½®
            applyUISettings();
        }     
        // æ˜¾ç¤ºæ¸¸æˆè¯´æ˜
        function showInstructions() {
            document.getElementById('instructionsModal').classList.remove('hidden');
        }
        
        // æ˜¾ç¤ºUIè®¾ç½®é¢æ¿
        function showUISettings() {
            // åŠ è½½ä¿å­˜çš„è®¾ç½®
            const settings = gameState.uiSettings;
            
            document.getElementById('showControlsCheckbox').checked = settings.showControls;
            document.getElementById('controlsPosition').value = settings.controlsPosition;
            document.getElementById('controlsSize').value = settings.controlsSize;
            document.getElementById('controlsOpacity').value = settings.controlsOpacity;
            
            document.getElementById('showGameInfoCheckbox').checked = settings.showGameInfo;
            document.getElementById('showLevelInfo').checked = settings.showLevelInfo;
            document.getElementById('showTimeInfo').checked = settings.showTimeInfo;
            document.getElementById('showMoveInfo').checked = settings.showMoveInfo;
            document.getElementById('showKeyInfo').checked = settings.showKeyInfo;
            document.getElementById('showRoomInfo').checked = settings.showRoomInfo;
            
            document.getElementById('uiSettingsModal').classList.remove('hidden');
        }
        
        // ä¿å­˜UIè®¾ç½®
        function saveUISettings() {
            gameState.uiSettings = {
                showControls: document.getElementById('showControlsCheckbox').checked,
                controlsPosition: document.getElementById('controlsPosition').value,
                controlsSize: parseInt(document.getElementById('controlsSize').value),
                controlsOpacity: parseInt(document.getElementById('controlsOpacity').value),
                showGameInfo: document.getElementById('showGameInfoCheckbox').checked,
                showLevelInfo: document.getElementById('showLevelInfo').checked,
                showTimeInfo: document.getElementById('showTimeInfo').checked,
                showMoveInfo: document.getElementById('showMoveInfo').checked,
                showKeyInfo: document.getElementById('showKeyInfo').checked,
                showRoomInfo: document.getElementById('showRoomInfo').checked,
                showPlayerList: document.getElementById('showPlayerListCheckbox').checked,
                // ä¿ç•™è‡ªå®šä¹‰ä½ç½®åæ ‡
                customX: gameState.uiSettings.customX,
                customY: gameState.uiSettings.customY
            };
            localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
            document.getElementById('uiSettingsModal').classList.add('hidden');
            applyUISettings();
        }
class LevelEditor {
    constructor() {
        this.currentLevel = null;
        this.isTesting = false;
        this.initEditor();
    }
    
    initEditor() {
        // åˆ›å»ºCanvas
        this.canvas = document.createElement('canvas');
        this.canvas.width = 800;
        this.canvas.height = 600;
        document.getElementById('editorContainer').appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');
        
        // ç½‘æ ¼ç»˜åˆ¶
        this.cellSize = 32;
        this.drawGrid();
        
        // å·¥å…·é€‰æ‹©
        this.selectedTool = 'wall';
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.selectedTool = btn.dataset.tool;
            });
        });
        
        // ç”»å¸ƒäº¤äº’
        this.canvas.addEventListener('mousedown', this.handleCanvasClick.bind(this));
    }
    
    startNewLevel() {
        const creator = prompt("è¾“å…¥ä½ çš„åˆ›ä½œè€…åç§°:");
        if(!creator || creator.length < 2) {
            alert("åˆ›ä½œè€…åç§°è‡³å°‘éœ€è¦2ä¸ªå­—ç¬¦");
            return;
        }
        
        const levelName = prompt("è¾“å…¥å…³å¡åç§°:");
        if(!levelName) {
            alert("å¿…é¡»è¾“å…¥å…³å¡åç§°");
            return;
        }
        
        this.currentLevel = {
            meta: {
                version: 2,
                creator: creator,
                name: levelName,
                created: Date.now(),
                verified: false
            },
            data: {
                tiles: Array(20).fill().map(() => Array(20).fill(0)), // 20x20ç©ºç½‘æ ¼
                entities: [],
                start: { x: 1, y: 1 },
                end: { x: 15, y: 15 }
            }
        };
        
        this.renderMap();
    }
    
    handleCanvasClick(e) {
        if(!this.currentLevel || this.isTesting) return;
        
        const rect = this.canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / this.cellSize);
        const y = Math.floor((e.clientY - rect.top) / this.cellSize);
        
        // è¾¹ç•Œæ£€æŸ¥
        if(x < 0 || y < 0 || x >= 20 || y >= 20) return;
        
        switch(this.selectedTool) {
            case 'wall':
                this.currentLevel.data.tiles[y][x] = 1;
                break;
            case 'start':
                this.currentLevel.data.start = { x, y };
                break;
            case 'spike':
                this.currentLevel.data.entities.push({
                    type: 'spike',
                    x, y,
                    damage: 1
                });
                break;
            // å…¶ä»–å·¥å…·...
        }
        
        this.renderMap();
    }
    
    renderMap() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // ç»˜åˆ¶ç½‘æ ¼
        this.drawGrid();
        
        // ç»˜åˆ¶åœ°å—
        for(let y = 0; y < 20; y++) {
            for(let x = 0; x < 20; x++) {
                if(this.currentLevel.data.tiles[y][x] === 1) {
                    this.ctx.fillStyle = '#886644';
                    this.ctx.fillRect(
                        x * this.cellSize, 
                        y * this.cellSize, 
                        this.cellSize, 
                        this.cellSize
                    );
                }
            }
        }
        
        // ç»˜åˆ¶å®ä½“
        this.currentLevel.data.entities.forEach(entity => {
            switch(entity.type) {
                case 'spike':
                    this.drawSpike(entity.x, entity.y);
                    break;
                // å…¶ä»–å®ä½“...
            }
        });
        
        // ç»˜åˆ¶èµ·ç‚¹ç»ˆç‚¹
        this.drawStartEnd();
    }
    
    async testLevel() {
        if(!this.currentLevel) return;
        this.isTesting = true;
        
        // å¿…é¡»é€šè¿‡éªŒè¯æ‰èƒ½åˆ†äº«
        const success = await simulateGameTest(this.currentLevel);
        
        if(success) {
            this.currentLevel.meta.verified = true;
            const shareCode = LevelEncryptor.encrypt(
                this.currentLevel,
                this.currentLevel.meta.creator
            );
            
            alert(`æµ‹è¯•æˆåŠŸï¼ä½ çš„åˆ†äº«ç : ${shareCode}`);
        } else {
            alert("æµ‹è¯•å¤±è´¥ï¼Œå¿…é¡»äº²è‡ªé€šå…³æ‰èƒ½åˆ†äº«");
        }
        
        this.isTesting = false;
    }
}
class LevelLoader {
    static loadFromCode(shareCode, creatorName) {
        // 1. è§£å¯†æ•°æ®
        const levelData = LevelEncryptor.decrypt(shareCode, creatorName);
        if(!levelData) {
            throw new Error("æ— æ•ˆçš„åˆ†äº«ç æˆ–åˆ›ä½œè€…å");
        }
        
        // 2. éªŒè¯æ•°æ®ç»“æ„
        if(!this.validateLevel(levelData)) {
            throw new Error("å…³å¡æ•°æ®æŸå");
        }
        
        // 3. éªŒè¯åˆ›ä½œè€…æ˜¯å¦å®Œæˆè¿‡å…³
        if(!levelData.meta.verified) {
            throw new Error("è¯¥å…³å¡æœªé€šè¿‡åˆ›ä½œè€…éªŒè¯");
        }
        
        return levelData;
    }
    
    static validateLevel(levelData) {
        return levelData.meta &&
               levelData.meta.version >= 2 &&
               levelData.data &&
               Array.isArray(levelData.data.tiles) &&
               levelData.data.start &&
               levelData.data.end;
    }
}
class LocalLevelManager {
    static STORAGE_KEY = 'savedLevels_v2';
    
    static saveLevel(levelData) {
        const levels = this.getSavedLevels();
        levels.push({
            name: levelData.meta.name,
            code: LevelEncryptor.encrypt(
                levelData, 
                levelData.meta.creator
            ),
            creator: levelData.meta.creator,
            timestamp: Date.now()
        });
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(levels));
    }
    
    static getSavedLevels() {
        return JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '[]');
    }
    
    static deleteLevel(code) {
        const levels = this.getSavedLevels()
            .filter(l => l.code !== code);
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(levels));
    }
    
    static exportAllLevels() {
        const levels = this.getSavedLevels();
        const blob = new Blob([JSON.stringify(levels)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'my_levels_backup.json';
        a.click();
    }
}


const ENCRYPTION_CONFIG = {
    salt: "GAME_LEVEL_SALT_V1", // ä¿®æ”¹æ­¤å€¼ä½¿æ—§åˆ†äº«ç å¤±æ•ˆ
    iv: CryptoJS.enc.Hex.parse("0102030405060708")
};

class LevelEncryptor {
    static encrypt(levelData, creatorName) {
        // 1. å‡†å¤‡æ•°æ®
        const jsonStr = JSON.stringify(levelData);
        
        // 2. ç”ŸæˆåŸºäºåˆ›ä½œè€…åçš„å¯†é’¥
        const key = this._generateKey(creatorName);
        
        // 3. AES-CBCåŠ å¯†
        const encrypted = CryptoJS.AES.encrypt(jsonStr, key, {
            iv: ENCRYPTION_CONFIG.iv,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC
        });
        
        // 4. è½¬ä¸ºURLå®‰å…¨çš„Base64
        return encrypted.toString()
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+$/, '');
    }
    
    static decrypt(encryptedCode, creatorName) {
        try {
            // 1. è¿˜åŸæ ‡å‡†Base64
            const standardB64 = encryptedCode
                .replace(/-/g, '+')
                .replace(/_/g, '/') + 
                '='.repeat((4 - encryptedCode.length % 4) % 4);
                
            // 2. ç”Ÿæˆå¯†é’¥
            const key = this._generateKey(creatorName);
            
            // 3. è§£å¯†
            const decrypted = CryptoJS.AES.decrypt(standardB64, key, {
                iv: ENCRYPTION_CONFIG.iv,
                padding: CryptoJS.pad.Pkcs7,
                mode: CryptoJS.mode.CBC
            });
            
            // 4. è½¬ä¸ºJSONå¯¹è±¡
            return JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
        } catch(e) {
            console.error("è§£å¯†å¤±è´¥:", e);
            return null;
        }
    }
    
    static _generateKey(creatorName) {
        return CryptoJS.PBKDF2(
            creatorName + ENCRYPTION_CONFIG.salt,
            CryptoJS.enc.Hex.parse("0102030405060708"),
            { keySize: 256/32, iterations: 100 }
        );
    }
}
// åº”ç”¨UIè®¾ç½®
function makeDraggable(element, handle) {
    let isDragging = false;
    let offsetX, offsetY;

    const startDrag = (clientX, clientY) => {
        isDragging = true;
        const rect = element.getBoundingClientRect();
        offsetX = clientX - rect.left;
        offsetY = clientY - rect.top;
        element.style.transition = 'none';
        document.body.style.userSelect = 'none';
    };

    const moveDrag = (clientX, clientY) => {
        if (!isDragging) return;
        
        let newLeft = clientX - offsetX;
        let newTop = clientY - offsetY;
        
        // è¾¹ç•Œæ£€æŸ¥
        newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - element.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, window.innerHeight - element.offsetHeight));
        
        element.style.left = `${newLeft}px`;
        element.style.top = `${newTop}px`;
    };

    const endDrag = () => {
        if (!isDragging) return;
        isDragging = false;
        document.body.style.userSelect = '';
        
        // ä¿å­˜æ–°ä½ç½®
        gameState.uiSettings.customX = parseInt(element.style.left);
        gameState.uiSettings.customY = parseInt(element.style.top);
        localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
    };

    // é¼ æ ‡äº‹ä»¶
    handle.addEventListener('mousedown', (e) => {
        startDrag(e.clientX, e.clientY);
    });

    document.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
    document.addEventListener('mouseup', endDrag);

    // è§¦æ‘¸äº‹ä»¶
    handle.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            startDrag(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        if (isDragging) moveDrag(e.touches[0].clientX, e.touches[0].clientY);
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', endDrag);
}

        // å¤„ç†æ§åˆ¶æŒ‰é’®ç‚¹å‡»


function handleControlButtonClick(key) {
    // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„æ–¹å‘é”®
    if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
        // ç›´æ¥è°ƒç”¨æ ¸å¿ƒç§»åŠ¨å‡½æ•°ï¼Œä¼ å…¥åŸå§‹æŒ‰é”®
        // movePlayer å†…éƒ¨ä¼šå¤„ç†åè½¬é€»è¾‘
        movePlayer(key);
    }
}

        // =============== æ§åˆ¶å°åŠŸèƒ½ ===============
        function toggleConsole() {
            consoleVisible = !consoleVisible;
            const consoleDiv = document.getElementById('console');
            
            if (consoleVisible) {
                consoleDiv.classList.remove('console-hidden');
                document.getElementById('consoleInput').focus();
            } else {
                consoleDiv.classList.add('console-hidden');
            }
        }

        function handleConsoleInput(e) {
            // åªé˜»æ­¢ç‰¹å®šé”®çš„é»˜è®¤è¡Œä¸º
            if (e.key === 'Enter') {
                const input = document.getElementById('consoleInput');
                const command = input.value.trim();
                input.value = '';
                    
                if (command) {
                    consoleHistory.push(command);
                    historyIndex = consoleHistory.length;
                    executeCommand(command);
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (consoleHistory.length > 0) {
                    if (historyIndex > 0) historyIndex--;
                    document.getElementById('consoleInput').value = consoleHistory[historyIndex] || '';
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (consoleHistory.length > 0) {
                    if (historyIndex < consoleHistory.length - 1) historyIndex++;
                    document.getElementById('consoleInput').value = consoleHistory[historyIndex] || '';
                } else {
                    document.getElementById('consoleInput').value = '';
                }
            }
            // å…¶ä»–æŒ‰é”®ä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå…è®¸æ­£å¸¸è¾“å…¥
        }
function sendKickRequest(playerId, reason) {
    // æ‰¾åˆ°æˆ¿ä¸»è¿æ¥
    let hostConnection = null;
    for (const id in gameState.multiplayer.players) {
        if (gameState.multiplayer.players[id].isHost) {
            hostConnection = gameState.multiplayer.connections[id];
            break;
        }
    }
    
    if (hostConnection) {
        hostConnection.send({
            type: 'kick-request',
            playerId: playerId,
            requestorId: gameState.multiplayer.currentPlayerId,
            reason: reason
        });
    }
}
function sendPrivateMessage(playerId, message) {
    if (gameState.multiplayer.connections[playerId]) {
        try {
            gameState.multiplayer.connections[playerId].send({
                type: 'private-message',
                from: gameState.multiplayer.currentPlayerId,
                message: message,
                timestamp: Date.now()
            });
            
            // ç»™è‡ªå·±ä¹Ÿæ˜¾ç¤ºä¸€æ¡å‘é€æˆåŠŸçš„æ¶ˆæ¯
            // showMessageToSelf(`ä½  â†’ ${gameState.multiplayer.players[playerId].name}: ${message}`);
        } catch (err) {
            console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', err);
        }
    }
}
// ç»™è‡ªå·±æ˜¾ç¤ºæ¶ˆæ¯
function showMessageToSelf(message) {
    const consoleOutput = document.getElementById('consoleOutput');
    consoleOutput.innerHTML += `\n[ç§èŠ] ${message}`;
    consoleOutput.scrollTop = consoleOutput.scrollHeight;
    
    // å¦‚æœæ˜¯å¼¹çª—å½¢å¼
    alert(message);
}


        function executeCommand(command) {
            const output = document.getElementById('consoleOutput');
            output.innerHTML += `\n> ${command}`;
            output.scrollTop = output.scrollHeight;
            
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);
            
            switch(cmd) {
                case 'help':
                    output.innerHTML += '\nå¯ç”¨å‘½ä»¤:';
                    output.innerHTML += '\n- help: æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯';
                    output.innerHTML += '\n- dev [password]: è¿›å…¥å¼€å‘è€…æ¨¡å¼';
                    output.innerHTML += '\n- win: ç«‹å³å®Œæˆå½“å‰å…³å¡';
                    output.innerHTML += '\n- level [n]: è·³è½¬åˆ°ç¬¬nå…³ (1-80)';
                    output.innerHTML += '\n- unlockall: è§£é”æ‰€æœ‰å…³å¡';
                    output.innerHTML += '\n- reset: é‡ç½®å½“å‰å…³å¡';
                    output.innerHTML += '\n- clear: æ¸…ç©ºæ§åˆ¶å°è¾“å‡º';
                    output.innerHTML += '\n- twoplayer: è¿›å…¥å¤šäººæ¸¸æˆé¡µé¢';
                    output.innerHTML += '\n- tp [x] [y]: ä¼ é€è‡³ä¸€ä¸ªä½ç½®';
                    output.innerHTML += '\n- tp select: ä¼ é€è‡³ä¸€ä¸ªä½ç½®ï¼ˆåœ°å›¾é€‰æ‹©ï¼‰';
                    output.innerHTML += '\n- tp [playername] select: ä¼ é€ç©å®¶åˆ°é€‰æ‹©çš„ä½ç½®';
                    output.innerHTML += '\n- kick [playername]: è¸¢å‡ºç©å®¶ï¼ˆæˆ¿ä¸»æƒé™ï¼‰';
                    output.innerHTML += '\n- protect [playername]: ä¿æŠ¤ç©å®¶ï¼ˆæ— æ•ŒçŠ¶æ€ï¼Œæ— æ³•è¢«è¸¢å‡ºï¼‰';
                    output.innerHTML += '\n- unprotect [playername]: å–æ¶ˆä¿æŠ¤ç©å®¶';
                    output.innerHTML += '\n- players: æ˜¾ç¤ºç©å®¶åˆ—è¡¨';
                    output.innerHTML += '\n- msg: å‘ç©å®¶å‘å‡ºä¿¡æ¯';
                    break;
                    
                case 'dev':
                    if (args.length > 0 && args[0] === 'dev') {
                        gameState.devMode = true;
                        output.innerHTML += '\nå¼€å‘è€…æ¨¡å¼å·²æ¿€æ´»ï¼';
                    } else {
                        output.innerHTML += '\néœ€è¦å¯†ç ï¼è¾“å…¥ "dev [password]" æ¿€æ´»å¼€å‘è€…æ¨¡å¼';
                    }
                    break;
                   
                case 'tp':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nè¯·å…ˆæ¿€æ´»å¼€å‘è€…æ¨¡å¼ (è¾“å…¥ "dev [password]")';
                        break;
                    }
            
                    if (args.length === 0) {
                        output.innerHTML += '\nç”¨æ³•: tp [ç©å®¶] [x] [y] æˆ– tp [ç©å®¶] select';
                        output.innerHTML += '\nç¤ºä¾‹: tp 5 10 - ä¼ é€åˆ°åæ ‡(5,10)';
                        output.innerHTML += '\n       tp player1 5 10 - ä¼ é€player1åˆ°åæ ‡(5,10)';
                        output.innerHTML += '\n       tp select - è¿›å…¥åœ°å›¾é€‰æ‹©æ¨¡å¼';
                        output.innerHTML += '\n       tp player1 select - ä¸ºplayer1è¿›å…¥åœ°å›¾é€‰æ‹©æ¨¡å¼';
                        output.innerHTML += '\nä½¿ç”¨ "players" å‘½ä»¤æŸ¥çœ‹æ‰€æœ‰ç©å®¶';
                        break;
                    }
            
                    // è§£æç©å®¶å‚æ•°
                    let targetPlayerId = null;
                    let coordArgs = args;
                    
                    // æ£€æŸ¥ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¦æ˜¯ç©å®¶åæˆ–ID
                    if (args.length >= 3 || (args.length === 2 && args[1] === 'select')) {
                        const playerIdentifier = args[0];
                        
                        // æŸ¥æ‰¾ç©å®¶
                        if (gameState.currentScreen === 'singlePlayerGame') {
                            // å•äººæ¸¸æˆåªæœ‰è‡ªå·±
                            if (playerIdentifier === 'me' || playerIdentifier === 'self') {
                                targetPlayerId = 'singleplayer';
                            } else {
                                output.innerHTML += '\nå•äººæ¨¡å¼ä¸‹åªèƒ½ä¼ é€è‡ªå·±ï¼Œä½¿ç”¨ "me" æˆ–çœç•¥ç©å®¶å‚æ•°';
                                break;
                            }
                        } else if (gameState.currentScreen === 'multiplayerGame') {
                            // åœ¨å¤šäººæ¸¸æˆä¸­æŸ¥æ‰¾ç©å®¶
                            const players = gameState.multiplayer.players;
                            for (const id in players) {
                                if (players[id].name === playerIdentifier || id === playerIdentifier) {
                                    targetPlayerId = id;
                                    break;
                                }
                            }
                            
                            if (!targetPlayerId) {
                                output.innerHTML += `\næœªæ‰¾åˆ°ç©å®¶: ${playerIdentifier}`;
                                output.innerHTML += '\nä½¿ç”¨ "players" å‘½ä»¤æŸ¥çœ‹æ‰€æœ‰ç©å®¶';
                                break;
                            }
                        }
                        
                        // ç§»é™¤ç©å®¶å‚æ•°ï¼Œä¿ç•™åæ ‡å‚æ•°
                        coordArgs = args.slice(1);
                    }
            
                    if (coordArgs[0] === 'select') {
                        // è¿›å…¥åœ°å›¾é€‰æ‹©æ¨¡å¼
                        startMapSelection(targetPlayerId);
                        output.innerHTML += `\nå·²è¿›å…¥åœ°å›¾é€‰æ‹©æ¨¡å¼ï¼Œç‚¹å‡»åœ°å›¾ä¸Šçš„ä½ç½®è¿›è¡Œä¼ é€${targetPlayerId ? ' ç›®æ ‡ç©å®¶: ' + targetPlayerId : ''}`;
                    } else if (coordArgs.length === 2) {
                        // ç›´æ¥ä¼ é€åˆ°æŒ‡å®šåæ ‡
                        const x = parseInt(coordArgs[0]);
                        const y = parseInt(coordArgs[1]);
                
                        if (isNaN(x) || isNaN(y)) {
                            output.innerHTML += '\nåæ ‡å¿…é¡»æ˜¯æ•°å­—';
                            break;
                        }
                    
                        const success = teleportPlayer(x, y, targetPlayerId);
                        if (success) {
                            output.innerHTML += `\nå·²ä¼ é€${targetPlayerId ? 'ç©å®¶ ' + targetPlayerId : 'è‡ªå·±'}åˆ°åæ ‡(${x},${y})`;
                        }
                    } else {
                        output.innerHTML += '\nç”¨æ³•: tp [ç©å®¶] [x] [y] æˆ– tp [ç©å®¶] select';
                    }
                    break;
                case 'msg':
                case 'message':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nè¯·å…ˆæ¿€æ´»å¼€å‘è€…æ¨¡å¼ (è¾“å…¥ "dev [password]")';
                        break;
                    }
                    
                    if (args.length < 2) {
                        output.innerHTML += '\nç”¨æ³•: msg [ç©å®¶åæˆ–ID] [æ¶ˆæ¯å†…å®¹]';
                        output.innerHTML += '\nç¤ºä¾‹: msg player1 ä½ å¥½ï¼';
                        output.innerHTML += '\nä½¿ç”¨ "players" å‘½ä»¤æŸ¥çœ‹æ‰€æœ‰ç©å®¶';
                        break;
                    }
                    
                    const recipient = args[0];
                    const message = args.slice(1).join(' ');
                    
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // æŸ¥æ‰¾ç©å®¶
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === recipient || id === recipient) {
                                playerId = id;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            // å‘é€æ¶ˆæ¯
                            sendPrivateMessage(playerId, message);
                            output.innerHTML += `\nå·²å‘ ${recipient} å‘é€æ¶ˆæ¯: ${message}`;
                        } else {
                            output.innerHTML += `\næœªæ‰¾åˆ°ç©å®¶: ${recipient}`;
                        }
                    } else {
                        output.innerHTML += '\næ­¤å‘½ä»¤åªèƒ½åœ¨å¤šäººæ¸¸æˆä¸­ä½¿ç”¨';
                    }
                    break;                    
                case 'players':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nè¯·å…ˆæ¿€æ´»å¼€å‘è€…æ¨¡å¼ (è¾“å…¥ "dev [password]")';
                        break;
                    }
                    
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        output.innerHTML += '\nå½“å‰ç©å®¶: è‡ªå·± (å•äººæ¨¡å¼)';
                    } else if (gameState.currentScreen === 'multiplayerGame') {
                        output.innerHTML += '\nç©å®¶åˆ—è¡¨:';
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            const player = players[id];
                            const isCurrent = id === gameState.multiplayer.currentPlayerId;
                            const isProtected = gameState.multiplayer.protectedPlayers[id];
                            output.innerHTML += `\n- ${player.name} (ID: ${id})${isCurrent ? ' [å½“å‰ç©å®¶]' : ''}${isProtected ? ' [å—ä¿æŠ¤]' : ''}`;
                        }
                    } else {
                        output.innerHTML += '\næ­¤å‘½ä»¤åªèƒ½åœ¨æ¸¸æˆä¸­ä½¿ç”¨';
                    }
                    break;
                    
                case 'twoplayer':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nè¯·æ¿€æ´»å¼€å‘è€…æ¨¡å¼';
                        break;
                    }
                    showScreen('multiplayerSetup');
                    output.innerHTML += '\nå·²è¿›å…¥å¤šäººæ¸¸æˆè®¾ç½®';
                    break;
                    
                case 'kick':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nè¯·å…ˆæ¿€æ´»å¼€å‘è€…æ¨¡å¼ (è¾“å…¥ "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\nç”¨æ³•: kick [ç©å®¶åæˆ–ID] [force]';
                        output.innerHTML += '\nç¤ºä¾‹: kick player1 - å‘æˆ¿ä¸»å‘é€è¸¢å‡ºè¯·æ±‚';
                        output.innerHTML += '\n       kick player1 force - å¼ºåˆ¶è¸¢å‡º(æ— éœ€æˆ¿ä¸»ç¡®è®¤)';
                        output.innerHTML += '\nä½¿ç”¨ "players" å‘½ä»¤æŸ¥çœ‹æ‰€æœ‰ç©å®¶';
                        break;
                    }
            
                    const playerToKick = args[0];
                    const forceKick = args[1] === 'force'; // æ˜¯å¦å¼ºåˆ¶è¸¢å‡º
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // æŸ¥æ‰¾ç©å®¶
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === playerToKick || id === playerToKick) {
                                playerId = id;
                                break;
                            }
                        }
                
                        if (playerId) {
                            // æ£€æŸ¥ç©å®¶æ˜¯å¦å—ä¿æŠ¤
                            if (gameState.multiplayer.protectedPlayers[playerId]) {
                                output.innerHTML += '\nè¸¢å‡ºå¤±è´¥ï¼šerr75937 (ç©å®¶å—ä¿æŠ¤)';
                            } else {
                                if (forceKick || !gameState.multiplayer.isHost) {
                                    // å¼ºåˆ¶è¸¢å‡ºæˆ–éæˆ¿ä¸»ç›´æ¥å‘é€è¸¢å‡ºè¯·æ±‚
                                    sendKickRequest(playerId, 'æ§åˆ¶å°è¸¢å‡º' + (forceKick ? '(å¼ºåˆ¶)' : ''));
                                    output.innerHTML += `\nå·²å‘é€è¸¢å‡º ${playerToKick} çš„è¯·æ±‚` + (forceKick ? ' (å¼ºåˆ¶)' : '');
                                } else {
                                    // æˆ¿ä¸»ç›´æ¥è¸¢äºº
                                    kickPlayer(playerId, 'æ§åˆ¶å°è¸¢å‡º');
                                    output.innerHTML += `\nå·²è¸¢å‡ºç©å®¶: ${playerToKick}`;
                                }
                            }
                        } else {
                            output.innerHTML += `\næœªæ‰¾åˆ°ç©å®¶: ${playerToKick}`;
                        }
                    } else {
                        output.innerHTML += '\næ­¤å‘½ä»¤åªèƒ½åœ¨å¤šäººæ¸¸æˆä¸­ä½¿ç”¨';
                    }
                    break;
                case 'protect':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nè¯·å…ˆæ¿€æ´»å¼€å‘è€…æ¨¡å¼ (è¾“å…¥ "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\nç”¨æ³•: protect [ç©å®¶åæˆ–ID]';
                        output.innerHTML += '\nç¤ºä¾‹: protect player1';
                        output.innerHTML += '\nä½¿ç”¨ "players" å‘½ä»¤æŸ¥çœ‹æ‰€æœ‰ç©å®¶';
                        break;
                    }
                    
                    const playerToProtect = args[0];
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // æŸ¥æ‰¾ç©å®¶
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === playerToProtect || id === playerToProtect) {
                                playerId = id;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            gameState.multiplayer.protectedPlayers[playerId] = true;
                            output.innerHTML += `\nå·²ä¿æŠ¤ç©å®¶: ${playerToProtect}`;
                            
                            // å¹¿æ’­ä¿æŠ¤çŠ¶æ€
                            broadcast({
                                type: 'player-protected',
                                playerId: playerId,
                                protected: true
                            });
                        } else {
                            output.innerHTML += `\næœªæ‰¾åˆ°ç©å®¶: ${playerToProtect}`;
                        }
                    } else {
                        output.innerHTML += '\næ­¤å‘½ä»¤åªèƒ½åœ¨å¤šäººæ¸¸æˆä¸­ä½¿ç”¨';
                    }
                    break;
                    
                case 'unprotect':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nè¯·å…ˆæ¿€æ´»å¼€å‘è€…æ¨¡å¼ (è¾“å…¥ "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\nç”¨æ³•: unprotect [ç©å®¶åæˆ–ID]';
                        output.innerHTML += '\nç¤ºä¾‹: unprotect player1';
                        output.innerHTML += '\nä½¿ç”¨ "players" å‘½ä»¤æŸ¥çœ‹æ‰€æœ‰ç©å®¶';
                        break;
                    }
                    
                    const playerToUnprotect = args[0];
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // æŸ¥æ‰¾ç©å®¶
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === playerToUnprotect || id === playerToUnprotect) {
                                playerId = id;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            delete gameState.multiplayer.protectedPlayers[playerId];
                            output.innerHTML += `\nå·²å–æ¶ˆä¿æŠ¤ç©å®¶: ${playerToUnprotect}`;
                            
                            // å¹¿æ’­ä¿æŠ¤çŠ¶æ€
                            broadcast({
                                type: 'player-protected',
                                playerId: playerId,
                                protected: false
                            });
                        } else {
                            output.innerHTML += `\næœªæ‰¾åˆ°ç©å®¶: ${playerToUnprotect}`;
                        }
                    } else {
                        output.innerHTML += '\næ­¤å‘½ä»¤åªèƒ½åœ¨å¤šäººæ¸¸æˆä¸­ä½¿ç”¨';
                    }
                    break;
                    
                case 'win':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nè¯·å…ˆæ¿€æ´»å¼€å‘è€…æ¨¡å¼ (è¾“å…¥ "dev [password]")';
                        break;
                    }
                    
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        // å®Œæˆå½“å‰å…³å¡
                        singlePlayerGame.player.x = singlePlayerGame.exit.x;
                        singlePlayerGame.player.y = singlePlayerGame.exit.y;
                        checkSinglePlayerExit();
                        output.innerHTML += '\nå½“å‰å…³å¡å·²é€šå…³ï¼';
                    } else {
                        output.innerHTML += '\nåªèƒ½åœ¨æ¸¸æˆå…³å¡ä¸­ä½¿ç”¨æ­¤å‘½ä»¤';
                    }
                    break;
                    
                case 'level':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nè¯·å…ˆæ¿€æ´»å¼€å‘è€…æ¨¡å¼ (è¾“å…¥ "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\néœ€è¦å…³å¡å· (1-80)';
                        break;
                    }
                    
                    const levelNum = parseInt(args[0]);
                    if (isNaN(levelNum) || levelNum < 1 || levelNum > 80) {
                        output.innerHTML += '\næ— æ•ˆçš„å…³å¡å· (å¿…é¡»ä»‹äº1-80)';
                        break;
                    }
                    
                    gameState.currentLevel = levelNum;
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        initSinglePlayerGame();
                        output.innerHTML += `\nå·²è·³è½¬åˆ°ç¬¬ ${levelNum} å…³`;
                    } else {
                        showScreen('singlePlayerGame');
                        output.innerHTML += `\nå·²å¼€å§‹ç¬¬ ${levelNum} å…³`;
                    }
                    break;
                    
                case 'unlockall':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nè¯·å…ˆæ¿€æ´»å¼€å‘è€…æ¨¡å¼ (è¾“å…¥ "dev [password]")';
                        break;
                    }
                    
                    gameState.unlockedLevel = 80;
                    localStorage.setItem('unlockedLevel', 80);
                    output.innerHTML += '\næ‰€æœ‰å…³å¡å·²è§£é”ï¼';
                    if (gameState.currentScreen === 'singlePlayerLevelSelect') {
                        generateLevelButtons();
                    }
                    break;
                    
                case 'reset':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nè¯·å…ˆæ¿€æ´»å¼€å‘è€…æ¨¡å¼ (è¾“å…¥ "dev [password]")';
                        break;
                    }
                    
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        resetSinglePlayerLevel();
                        output.innerHTML += '\nå½“å‰å…³å¡å·²é‡ç½®';
                    } else {
                        output.innerHTML += '\nåªèƒ½åœ¨æ¸¸æˆå…³å¡ä¸­ä½¿ç”¨æ­¤å‘½ä»¤';
                    }
                    break;
                    
                case 'clear':
                    output.innerHTML = '> æ§åˆ¶å°å·²æ¸…ç©º';
                    break;
                case 'kick-request':
                        console.log(data);
                        // åªæœ‰æˆ¿ä¸»èƒ½å¤„ç†è¸¢äººè¯·æ±‚
                        if (gameState.multiplayer.isHost) {
                            const playerId = data.playerId;
                            const requestorId = data.requestorId;
                            const reason = data.reason || 'æœªçŸ¥åŸå› ';
                            
                            // æ£€æŸ¥ç©å®¶æ˜¯å¦å—ä¿æŠ¤
                            if (gameState.multiplayer.protectedPlayers[playerId]) {
                                // å‘é€è¸¢å‡ºå¤±è´¥æ¶ˆæ¯ç»™è¯·æ±‚è€…
                                if (gameState.multiplayer.connections[requestorId]) {
                                    gameState.multiplayer.connections[requestorId].send({
                                        type: 'kick-failed',
                                        playerId: playerId,
                                        reason: 'err75937'
                                    });
                                }
                            } else {
                                // è¸¢å‡ºç©å®¶
                                kickPlayer(playerId, reason + ' (ç”±ç©å®¶è¯·æ±‚)');
                                
                                // é€šçŸ¥è¯·æ±‚è€…è¸¢å‡ºæˆåŠŸ
                                if (gameState.multiplayer.connections[requestorId]) {
                                    gameState.multiplayer.connections[requestorId].send({
                                        type: 'kick-success',
                                        playerId: playerId
                                    });
                                }
                            }
                        }
                        break;
                        
                    case 'kick-success':
                        console.log(data);
                        document.getElementById('consoleOutput').innerHTML += `\nç©å®¶ ${data.playerId} å·²è¢«æˆ¿ä¸»è¸¢å‡º`;
                        break;
                    case 'eventsystem':
                        if (args.length > 0) {
                            EventSystem.triggerById(args[0]);
                            output.innerHTML += `\nå½“å‰è§¦å‘äº†äº‹ä»¶: ${args[0]}`;
                        }
                        break;
                        default:
                            output.innerHTML += `\næœªçŸ¥å‘½ä»¤: ${command}\nè¾“å…¥ "help" æŸ¥çœ‹å¯ç”¨å‘½ä»¤`;
                    }
            
            output.scrollTop = output.scrollHeight;
        }

function startMapSelection(targetPlayerId = null) {
    // ä¿å­˜å½“å‰æ¸¸æˆçŠ¶æ€å’Œç›®æ ‡ç©å®¶
    gameState.mapSelectionMode = true;
    gameState.mapSelectionTarget = targetPlayerId;
    
    // æ·»åŠ åœ°å›¾ç‚¹å‡»äº‹ä»¶ç›‘å¬
    if (gameState.currentScreen === 'singlePlayerGame') {
        singlePlayerGame.canvas.addEventListener('click', handleMapClick);
        document.getElementById('consoleOutput').innerHTML += 
            '\nåœ°å›¾é€‰æ‹©æ¨¡å¼å·²æ¿€æ´»ï¼Œç‚¹å‡»åœ°å›¾ä¸Šçš„ä½ç½®è¿›è¡Œä¼ é€';
        console.log('åœ°å›¾é€‰æ‹©æ¨¡å¼å·²æ¿€æ´»');
        showNotification('åœ°å›¾é€‰æ‹©æ¨¡å¼å·²æ¿€æ´»ï¼Œç‚¹å‡»åœ°å›¾ä¸Šçš„ä½ç½®è¿›è¡Œä¼ é€');
    } else if (gameState.currentScreen === 'multiplayerGame') {
        multiplayerCanvas.addEventListener('click', handleMapClick);
        document.getElementById('consoleOutput').innerHTML += 
            `\nåœ°å›¾é€‰æ‹©æ¨¡å¼å·²æ¿€æ´»ï¼Œç‚¹å‡»åœ°å›¾ä¸Šçš„ä½ç½®è¿›è¡Œä¼ é€${targetPlayerId ? ' ç›®æ ‡ç©å®¶: ' + targetPlayerId : ''}`;
    } else {
        document.getElementById('consoleOutput').innerHTML += 
            '\nåœ°å›¾é€‰æ‹©æ¨¡å¼åªèƒ½åœ¨æ¸¸æˆä¸­è¿›è¡Œ';
        gameState.mapSelectionMode = false;
    }
}

function handleMapClick(e) {
    if (!gameState.mapSelectionMode) return;
    
    let canvas, cellSize, maze;
    
    // æ ¹æ®å½“å‰æ¸¸æˆæ¨¡å¼è·å–æ­£ç¡®çš„ç”»å¸ƒå’Œå‚æ•°
    if (gameState.currentScreen === 'singlePlayerGame') {
        canvas = singlePlayerGame.canvas;
        cellSize = singlePlayerGame.cellSize;
        maze = singlePlayerGame.maze;
    } else if (gameState.currentScreen === 'multiplayerGame') {
        canvas = document.getElementById('multiplayerCanvas');
        // è®¡ç®—å¤šäººæ¸¸æˆçš„å•å…ƒæ ¼å¤§å°
        const mazeWidth = gameState.multiplayer.maze[0].length;
        cellSize = canvas.width / mazeWidth;
        maze = gameState.multiplayer.maze;
    } else {
        return;
    }
    
    // è·å–ç”»å¸ƒç›¸å¯¹äºè§†å£çš„ä½ç½®
    const rect = canvas.getBoundingClientRect();
    
    // è®¡ç®—ç‚¹å‡»ä½ç½®ç›¸å¯¹äºç”»å¸ƒçš„åæ ‡
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    
    // è½¬æ¢ä¸ºè¿·å®«åæ ‡
    const x = Math.floor(clickX / cellSize);
    const y = Math.floor(clickY / cellSize);
    
    // éªŒè¯åæ ‡æ˜¯å¦æœ‰æ•ˆ
    if (x < 0 || x >= maze[0].length || y < 0 || y >= maze.length) {
        document.getElementById('consoleOutput').innerHTML += 
            `\né”™è¯¯: åæ ‡(${x},${y})è¶…å‡ºè¿·å®«èŒƒå›´`;
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯å¢™
    if (maze[y][x] === 1) {
        document.getElementById('consoleOutput').innerHTML += 
            `\né”™è¯¯: åæ ‡(${x},${y})æ˜¯å¢™ï¼Œæ— æ³•ä¼ é€`;
        return;
    }
    
    // ä¼ é€ç©å®¶
    const success = teleportPlayer(x, y, gameState.mapSelectionTarget);
    
    if (success) {
        document.getElementById('consoleOutput').innerHTML += 
            `\nå·²ä¼ é€åˆ°åæ ‡(${x},${y})`;
    }
    
    // é€€å‡ºåœ°å›¾é€‰æ‹©æ¨¡å¼
    gameState.mapSelectionMode = false;
    gameState.mapSelectionTarget = null;
    showNotification(`ä¼ é€æˆåŠŸï¼ä½ å·²åˆ°è¾¾åæ ‡(${x},${y})ã€‚`);
    
    
    // ç§»é™¤ç‚¹å‡»äº‹ä»¶ç›‘å¬
    canvas.removeEventListener('click', handleMapClick);
    
    document.getElementById('consoleOutput').innerHTML += 
        `\nåœ°å›¾é€‰æ‹©æ¨¡å¼å·²å…³é—­`;
}

// =============== ç©å®¶ä¼ é€åŠŸèƒ½ ===============
function teleportPlayer(x, y, targetPlayerId = null) {
    // æ£€æŸ¥åæ ‡æ˜¯å¦æœ‰æ•ˆ
    if (!isValidPosition(x, y)) {
        document.getElementById('consoleOutput').innerHTML += 
            `\né”™è¯¯: åæ ‡(${x},${y})æ— æ•ˆæˆ–ä¸å¯åˆ°è¾¾`;
        return false;
    }
    
    if (gameState.currentScreen === 'singlePlayerGame') {
        // å•äººæ¸¸æˆåªèƒ½ä¼ é€è‡ªå·±
        if (targetPlayerId && targetPlayerId !== 'singleplayer') {
            document.getElementById('consoleOutput').innerHTML += 
                '\nå•äººæ¨¡å¼ä¸‹åªèƒ½ä¼ é€è‡ªå·±';
            return false;
        }
        
        singlePlayerGame.player.x = x;
        singlePlayerGame.player.y = y;
        drawSinglePlayerMaze();
        
        // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å‡ºå£
        checkSinglePlayerExit();
        
    } else if (gameState.currentScreen === 'multiplayerGame') {
        // ç¡®å®šè¦ä¼ é€çš„ç©å®¶
        let playerId;
        if (targetPlayerId) {
            playerId = targetPlayerId;
        } else {
            playerId = gameState.multiplayer.currentPlayerId;
        }
        
        const player = gameState.multiplayer.players[playerId];
        
        if (!player) {
            document.getElementById('consoleOutput').innerHTML += 
                `\né”™è¯¯: æ‰¾ä¸åˆ°ç©å®¶ ID ${playerId}`;
            return false;
        }
           
        player.x = x;
        player.y = y;
        
        // å¹¿æ’­
        broadcast({
            type: 'player-teleport',
            playerId: playerId,
            x: x,
            y: y
        });
        
        drawMultiplayerMaze();
        updatePlayerList();
        
        // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å‡ºå£
        if (x === gameState.multiplayer.exit.x && y === gameState.multiplayer.exit.y) {
            player.reachedExit = true;
            
            // å¹¿æ’­åˆ°è¾¾å‡ºå£
            broadcast({
                type: 'player-reached-exit',
                playerId: playerId
            });
            
            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½åˆ°è¾¾å‡ºå£
            checkAllPlayersReachedExit();
        }
    }
    
    return true;
}

// =============== ä½ç½®éªŒè¯ ===============
function isValidPosition(x, y) {
    let maze;
    
    if (gameState.currentScreen === 'singlePlayerGame') {
        maze = singlePlayerGame.maze;
    } else if (gameState.currentScreen === 'multiplayerGame') {
        maze = gameState.multiplayer.maze;
    } else {
        return false;
    }
    
    // æ£€æŸ¥è¿·å®«æ˜¯å¦æœ‰æ•ˆ
    if (!maze || maze.length === 0) {
        return false;
    }
    
    // æ£€æŸ¥åæ ‡æ˜¯å¦åœ¨è¿·å®«èŒƒå›´å†…
    if (x < 0 || x >= maze[0].length || y < 0 || y >= maze.length) {
        return false;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯å¢™
    if (maze[y][x] === 1) {
        return false;
    }
    
    return true;
}

        // =============== å•äººæ¸¸æˆé€»è¾‘ ===============

        function generateLevelButtons() {
            const container = document.getElementById('levelContainer');
            container.innerHTML = '';
            container.style.touchAction = 'pan-y'; // ç¡®ä¿è§¦æ‘¸è¡Œä¸ºä¼˜åŒ–
            for (let i = 1; i <= 80; i++) {
                const button = document.createElement('button');
                button.className = 'level-button';
                if (i > gameState.unlockedLevel) {
                    button.classList.add('locked');
                    button.disabled = true;
                } else if (gameState.completedLevels.includes(i)) {
                    button.classList.add('completed');
                }
                
                // æ ‡è®°æ— è§£å…³å¡
                if (gameState.unsolvableLevels.includes(i)) {
                    button.classList.add('unsolvable');
                }
                
                button.textContent = i;
                button.onclick = () => {
                    gameState.currentLevel = i;
                    showScreen('singlePlayerGame');
                };
                container.appendChild(button);
            }
        }

function initSinglePlayerGame(isLoadingSave = false) {
    window.removeEventListener('keydown', handleSinglePlayerKeyDown);
    singlePlayerGame.canvas = document.getElementById('singlePlayerCanvas');
    singlePlayerGame.ctx = singlePlayerGame.canvas.getContext('2d');
    singlePlayerGame.moveCount = 0;
    singlePlayerGame.movingEnemies = [];
    singlePlayerGame.doorPosition = null;
    singlePlayerGame.keyPosition = null;
    singlePlayerGame.isUnlocking = false;
    singlePlayerGame.unlockTimeLeft = 10;
    singlePlayerGame.hasKey = false;
    clearInterval(singlePlayerGame.unlockTimer);
    if (!isLoadingSave) {
        const difficulty = Math.min(
            Math.floor(gameState.currentLevel / 7), 
            singlePlayerGame.difficultySettings.length - 1
        );
        const settings = singlePlayerGame.difficultySettings[difficulty];
        singlePlayerGame.maze = generateDifficultMaze(gameState.currentLevel, settings);
        singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
        singlePlayerGame.hasKey = false;
    }
    if (!window.EventSystemInitialized) {
        EventSystem.init();
        window.EventSystemInitialized = true;
    }
    document.getElementById('regularNextButton').style.display = 'none';
    document.getElementById('unsolvableNextButton').style.display = 'none';
    document.getElementById('levelDisplay').textContent = `å…³å¡: ${gameState.currentLevel}`;
    document.getElementById('moveCount').textContent = `ç§»åŠ¨: 0`;
    document.getElementById('keyStatus').textContent = `é’¥åŒ™: æœªè·å¾—`;
    
    // éšè—ç‰¹æ®Šå…ƒç´ æç¤º
    document.getElementById('keyInfo').classList.add('hidden');
    document.getElementById('unlockTimer').classList.add('hidden');
    document.getElementById('enemyInfo').classList.add('hidden');
    
    // æ ¹æ®å…³å¡éš¾åº¦è®¾ç½®ç”Ÿæˆè¿·å®«
    const difficulty = Math.min(
        Math.floor(gameState.currentLevel / 7), 
        singlePlayerGame.difficultySettings.length - 1
    );
    const settings = singlePlayerGame.difficultySettings[difficulty];
    if (gameState.autoSave) {
        loadGame(); // å°è¯•åŠ è½½ä¸Šæ¬¡çš„å­˜æ¡£
    }
    // ç‰¹æ®Šå…³å¡å¤„ç†
    if (gameState.currentLevel === 20) {
        let validMaze = false;
        let attempts = 0;
        while (!validMaze && attempts < 10) {
            singlePlayerGame.maze = generateDifficultMaze(gameState.currentLevel, settings);
            validMaze = validateMaze(singlePlayerGame.maze);
            attempts++;
        }
        if (!validMaze) {
            console.log("å…³å¡ç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨è¿·å®«");
            singlePlayerGame.maze = generateBackupMaze(settings.size);
        }
    } 
    // ç‰¹æ®Šèºæ—‹å…³å¡ï¼š30å’Œ60å…³
    else if (gameState.specialLevels.includes(gameState.currentLevel)) {
        singlePlayerGame.maze = generateSpiralMaze(settings.size);
        // è®¾ç½®èµ·ç‚¹å’Œç»ˆç‚¹
        const size = settings.size;
        singlePlayerGame.player = { x: 1, y: size - 2 };
        singlePlayerGame.exit = { x: Math.floor(size/2), y: Math.floor(size/2) };
        // æ·»åŠ ç§»åŠ¨æ•Œäºº
        addMovingEnemies(settings.size, gameState.currentLevel === 60 ? 5 : 3);
        // æ˜¾ç¤ºæ•Œäººè­¦å‘Š
        document.getElementById('enemyInfo').classList.remove('hidden');
        
        // æ·»åŠ é’¥åŒ™å’Œé—¨
        addKeyAndDoor(size);
        document.getElementById('keyInfo').classList.remove('hidden');
    } 
    else {
        singlePlayerGame.maze = generateDifficultMaze(gameState.currentLevel, settings);
    }
    
    // è®¾ç½®ç©å®¶å’Œå‡ºå£ä½ç½®ï¼ˆéç‰¹æ®Šå…³å¡ï¼‰
    if (!gameState.specialLevels.includes(gameState.currentLevel)) {
        singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
        singlePlayerGame.exit = findExitPosition(singlePlayerGame.maze);
    }
    
    // è°ƒæ•´ç”»å¸ƒå¤§å°
    resizeSinglePlayerCanvas();
    
    // å¼€å§‹æ¸¸æˆ
    startSinglePlayerTimer();
    drawSinglePlayerMaze();
    
    // æ·»åŠ é”®ç›˜äº‹ä»¶ç›‘å¬
    window.addEventListener('keydown', handleSinglePlayerKeyDown);
    
    // å¯åŠ¨ç§»åŠ¨é™·é˜±
    if (settings.movingTraps > 0 || 
        gameState.specialLevels.includes(gameState.currentLevel)) {
        startMovingTraps();
    }
    updateNextLevelButtons();
    // åº”ç”¨UIè®¾ç½®
    applyUISettings();
    if (gameState.specialLevels.includes(gameState.currentLevel)) {
        document.getElementById('enemyInfo').classList.remove('hidden');
    }
}
class GameRecorder {
    constructor() {
        this.frames = [];
        this.startTime = 0;
        this.isRecording = false;
    }

    startRecording(canvas) {
        this.frames = [];
        this.startTime = Date.now();
        this.isRecording = true;
        
        // ä½¿ç”¨requestAnimationFrameæ•è·ç”»é¢
        const captureFrame = () => {
            if(!this.isRecording) return;
            this.frames.push({
                timestamp: Date.now() - this.startTime,
                imageData: canvas.toDataURL('image/webp', 0.8)
            });
            requestAnimationFrame(captureFrame);
        };
        captureFrame();
    }
    static getAllRecords() {
        return JSON.parse(localStorage.getItem('gameRecords') || "[]")
            .map((record, index) => ({ ...record, id: index }))
            .sort((a,b) => new Date(b.metadata.timestamp) - new Date(a.metadata.timestamp));
    }
    static deleteRecord(id) {
        const records = this.getAllRecords();
        const newRecords = records.filter(r => r.id !== id);
        localStorage.setItem('gameRecords', JSON.stringify(newRecords));
    }
    static getStorageUsage() {
        const records = this.getAllRecords();
        const used = JSON.stringify(records).length / (1024 * 1024);
        const max = parseInt(localStorage.getItem('maxRecordStorage') || "300");
        return { used: used.toFixed(1), max, percent: (used/max*100).toFixed(1) };
    }
    stopRecording() {
        this.isRecording = false;
        this.saveToLocalStorage();
    }

    saveToLocalStorage() {
        const recordData = {
            version: 1.0,
            metadata: {
                level: gameState.currentLevel,
                timestamp: new Date().toISOString(),
                duration: Date.now() - this.startTime,
                playerName: gameState.playerName
            },
            frames: this.frames
        };
        
        // å­˜å‚¨ç®¡ç†
        const records = JSON.parse(localStorage.getItem('gameRecords') || "[]");
        records.push(recordData);
        
        // è‡ªåŠ¨æ¸…ç†æ—§å½•åƒ
        let totalSize = 0;
        const cleanRecords = records.reverse().filter(record => {
            totalSize += JSON.stringify(record).length;
            return totalSize < document.getElementById('maxStorage').value * 1024 * 1024;
        }).reverse();
        
        localStorage.setItem('gameRecords', JSON.stringify(cleanRecords));
    }

    replay(recordId) {
        const record = JSON.parse(localStorage.getItem('gameRecords'))[recordId];
        const replayCanvas = document.createElement('canvas');
        // å®ç°å›æ”¾é€»è¾‘...
    }
}
class ReplayPlayer {
    constructor() {
        this.currentFrame = 0;
        this.isPlaying = false;
        this.playbackSpeed = 1;
        this.animationFrame = null;
    }
    load(replayData) {
        this.replayData = replayData;
        this.canvas = document.getElementById('replayCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = replayData.metadata.width || 800;
        this.canvas.height = replayData.metadata.height || 600;
        
        document.getElementById('replayTitle').textContent = 
            `å…³å¡${replayData.metadata.level} - ${new Date(replayData.metadata.timestamp).toLocaleString()}`;
        
        this.showFrame(0);
    }
    showFrame(index) {
        this.currentFrame = Math.max(0, Math.min(index, this.replayData.frames.length-1));
        const frame = this.replayData.frames[this.currentFrame];
        
        const img = new Image();
        img.onload = () => {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(img, 0, 0);
            this.updateProgress();
        };
        img.src = frame.imageData;
    }
    play() {
        if(this.isPlaying) return;
        this.isPlaying = true;
        document.getElementById('playBtn').textContent = 'â¸ï¸ æš‚åœ';
        
        const startTime = Date.now() - (this.currentFrame * 1000 / this.playbackSpeed);
        
        const playLoop = () => {
            if(!this.isPlaying) return;
            
            const elapsed = (Date.now() - startTime) * this.playbackSpeed;
            const targetFrame = Math.floor(elapsed / 1000 * 60); // å‡è®¾60fps
            
            if(targetFrame < this.replayData.frames.length) {
                this.showFrame(targetFrame);
                this.animationFrame = requestAnimationFrame(playLoop);
            } else {
                this.stop();
            }
        };
        
        playLoop();
    }
    stop() {
        this.isPlaying = false;
        cancelAnimationFrame(this.animationFrame);
        document.getElementById('playBtn').textContent = 'â–¶ï¸ æ’­æ”¾';
    }
    updateProgress() {
        const progress = (this.currentFrame / this.replayData.frames.length) * 100;
        document.getElementById('replayProgress').value = progress;
        
        const currentTime = (this.currentFrame / 60).toFixed(1);
        const totalTime = (this.replayData.frames.length / 60).toFixed(1);
        document.getElementById('timeDisplay').textContent = 
            `${formatTime(currentTime)} / ${formatTime(totalTime)}`;
    }
}
// å…¨å±€æ’­æ”¾å™¨å®ä¾‹
const replayPlayer = new ReplayPlayer();
// æ‰“å¼€å›æ”¾ç•Œé¢
function showReplayModal() {
    document.getElementById('replayModal').classList.remove('hidden');
    renderReplayList();
    updateStorageInfo();
}
function closeReplayModal() {
    document.getElementById('replayModal').classList.add('hidden');
    replayPlayer.stop();
}
function renderReplayList(filter = 'all') {
    const listEl = document.getElementById('replayList');
    listEl.innerHTML = '';
    
    const records = GameRecorder.getAllRecords();
    
    // åº”ç”¨ç­›é€‰
    const filteredRecords = filter === 'recent' 
        ? records.filter(r => new Date(r.metadata.timestamp) > Date.now() - 7*86400000)
        : records;
    
    if(filteredRecords.length === 0) {
        listEl.innerHTML = '<div class="no-records">æš‚æ— å½•åƒè®°å½•</div>';
        return;
    }
    
    filteredRecords.forEach(record => {
        const item = document.createElement('div');
        item.className = 'replay-item';
        item.innerHTML = `
            <div class="replay-meta">
                <strong>å…³å¡ ${record.metadata.level}</strong>
                <span>${new Date(record.metadata.timestamp).toLocaleString()}</span>
            </div>
            <div>
                æ—¶é•¿ï¼š${formatTime(record.metadata.duration/1000)} | 
                ç©å®¶ï¼š${record.metadata.playerName || 'åŒ¿å'}
            </div>
            <div class="replay-actions">
                <button onclick="playReplay(${record.id})">æ’­æ”¾</button>
                <button onclick="deleteReplay(${record.id})">åˆ é™¤</button>
            </div>
        `;
        listEl.appendChild(item);
    });
}
function playReplay(id) {
    const records = GameRecorder.getAllRecords();
    const record = records.find(r => r.id === id);
    if(!record) return;
    
    document.getElementById('replayList').classList.add('hidden');
    document.getElementById('playerContainer').classList.remove('hidden');
    
    replayPlayer.load(record);
}
function exitPlayer() {
    replayPlayer.stop();
    document.getElementById('replayList').classList.remove('hidden');
    document.getElementById('playerContainer').classList.add('hidden');
}
function togglePlay() {
    if(replayPlayer.isPlaying) {
        replayPlayer.stop();
    } else {
        replayPlayer.play();
    }
}
function seekForward() {
    replayPlayer.showFrame(replayPlayer.currentFrame + 5*60); // å‰è¿›5ç§’(å‡è®¾60fps)
}
function seekBack() {
    replayPlayer.showFrame(replayPlayer.currentFrame - 5*60); // åé€€5ç§’
}
function deleteReplay(id) {
    if(confirm('ç¡®å®šåˆ é™¤æ­¤å½•åƒå—ï¼Ÿ')) {
        GameRecorder.deleteRecord(id);
        renderReplayList(document.getElementById('replayFilter').value);
        updateStorageInfo();
    }
}
function updateStorageInfo() {
    const usage = GameRecorder.getStorageUsage();
    document.getElementById('storageInfo').textContent = 
        `å·²ä½¿ç”¨ï¼š${usage.used}MB/${usage.max}MB (${usage.percent}%)`;
}
// å·¥å…·å‡½æ•°
function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}
// åœ¨å…³å¡ç”Ÿæˆé€»è¾‘ä¸­æ·»åŠ 
function generateMovingPlatforms(level) {
    const platformCount = Math.min(Math.floor(level/5), 5);
    singlePlayerGame.movingPlatforms = [];
    
    for(let i=0; i<platformCount; i++) {
        singlePlayerGame.movingPlatforms.push({
            id: i,
            x: Math.floor(Math.random() * (mazeWidth-4)) + 2,
            y: Math.floor(Math.random() * (mazeHeight-4)) + 2,
            path: generatePlatformPath(),
            speed: 0.5 + Math.random(),
            passengers: []
        });
    }
}

function generatePlatformPath() {
    // ç”Ÿæˆç§»åŠ¨è·¯å¾„ï¼šç›´çº¿/æ–¹å½¢/åœ†å½¢
    const pathType = Math.floor(Math.random() * 3);
    const centerX = Math.floor(Math.random() * mazeWidth);
    const centerY = Math.floor(Math.random() * mazeHeight);
    
    switch(pathType) {
        case 0: // æ°´å¹³
            return { type: 'horizontal', start: centerX-3, end: centerX+3, y: centerY };
        case 1: // ç«–ç›´
            return { type: 'vertical', start: centerY-3, end: centerY+3, x: centerX };
        case 2: // åœ†å½¢
            return { type: 'circular', centerX, centerY, radius: 2 };
    }
}
// åœ¨drawSinglePlayerMazeä¸­æ·»åŠ 
function drawMovingPlatforms() {
    const ctx = singlePlayerGame.ctx;
    singlePlayerGame.movingPlatforms.forEach(platform => {
        // æ›´æ–°ä½ç½®
        updatePlatformPosition(platform);
        
        // ç»˜åˆ¶å¹³å°
        ctx.fillStyle = '#8BC34A';
        ctx.fillRect(
            platform.x * singlePlayerGame.cellSize,
            platform.y * singlePlayerGame.cellSize,
            singlePlayerGame.cellSize * 2,
            singlePlayerGame.cellSize
        );
        
        // æ£€æµ‹ç©å®¶ç¢°æ’
        checkPlayerOnPlatform(platform);
    });
}

function updatePlatformPosition(platform) {
    switch(platform.path.type) {
        case 'horizontal':
            platform.x += platform.speed * (platform.movingForward ? 1 : -1);
            if(platform.x > platform.path.end) platform.movingForward = false;
            if(platform.x < platform.path.start) platform.movingForward = true;
            break;
        case 'vertical':
            platform.y += platform.speed * (platform.movingForward ? 1 : -1);
            if(platform.y > platform.path.end) platform.movingForward = false;
            if(platform.y < platform.path.start) platform.movingForward = true;
            break;
        case 'circular':
            const angle = Date.now()/1000 * platform.speed;
            platform.x = platform.path.centerX + Math.cos(angle) * platform.path.radius;
            platform.y = platform.path.centerY + Math.sin(angle) * platform.path.radius;
            break;
    }
}


        // æ·»åŠ é’¥åŒ™å’Œé—¨ï¼ˆç”¨äºç‰¹æ®Šå…³å¡ï¼‰
        function addKeyAndDoor(size) {
            // éšæœºæ”¾ç½®é’¥åŒ™ï¼ˆé¿å¼€èµ·ç‚¹å’Œç»ˆç‚¹ï¼‰
            let keyX, keyY;
            do {
                keyX = Math.floor(Math.random() * (size - 4)) + 2;
                keyY = Math.floor(Math.random() * (size - 4)) + 2;
            } while (singlePlayerGame.maze[keyY][keyX] === 1 || 
                     (keyX === 1 && keyY === size - 2) || 
                     (keyX === Math.floor(size/2) && keyY === Math.floor(size/2)));
            
            // åœ¨é’¥åŒ™ä½ç½®æ”¾ç½®é’¥åŒ™ï¼ˆå…ƒç´ å€¼8ï¼‰
            singlePlayerGame.maze[keyY][keyX] = 8;
            singlePlayerGame.keyPosition = {x: keyX, y: keyY};
            
            // åœ¨å‡ºå£å‰æ”¾ç½®é—¨ï¼ˆå…ƒç´ å€¼9ï¼‰
            let doorX = singlePlayerGame.exit.x;
            let doorY = singlePlayerGame.exit.y;
            
            // ç¡®å®šé—¨çš„ä½ç½®ï¼ˆåœ¨å‡ºå£æ—è¾¹ï¼‰
            if (doorX < size-1 && singlePlayerGame.maze[doorY][doorX+1] === 0) {
                doorX++;
            } else if (doorX > 0 && singlePlayerGame.maze[doorY][doorX-1] === 0) {
                doorX--;
            } else if (doorY < size-1 && singlePlayerGame.maze[doorY+1][doorX] === 0) {
                doorY++;
            } else if (doorY > 0 && singlePlayerGame.maze[doorY-1][doorX] === 0) {
                doorY--;
            }
            
            singlePlayerGame.maze[doorY][doorX] = 9;
            singlePlayerGame.doorPosition = {x: doorX, y: doorY};
        }

        // ç”Ÿæˆèºæ—‹è¿·å®«ï¼ˆç”¨äºç¬¬30å’Œ60å…³ï¼‰
        function generateSpiralMaze(size) {
            // ç¡®ä¿å¥‡æ•°å°ºå¯¸
            if (size % 2 === 0) size++;
            
            const maze = Array(size).fill().map(() => Array(size).fill(1));
            
            // åˆ›å»ºèºæ—‹è·¯å¾„
            let x = 0, y = 0;
            let dx = 0, dy = 1;
            let steps = size - 1;
            let currentSteps = 0;
            let stepCount = 0;
            let turnCount = 0;
            
            for (let i = 0; i < size * size; i++) {
                maze[y][x] = 0;
                
                // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ä¸­å¿ƒ
                if (steps <= 0) break;
                
                currentSteps++;
                if (currentSteps === steps) {
                    currentSteps = 0;
                    turnCount++;
                    
                    // æ¯ä¸¤æ¬¡è½¬å‘å‡å°‘æ­¥é•¿
                    if (turnCount % 2 === 0) {
                        steps--;
                    }
                    
                    // è½¬å‘
                    const temp = dx;
                    dx = dy;
                    dy = -temp;
                }
                
                x += dx;
                y += dy;
            }
            
            // ç¡®ä¿å‡ºå£åœ¨ä¸­å¿ƒ
            const center = Math.floor(size / 2);
            maze[center][center] = 0;
            
            // ç¡®ä¿èµ·ç‚¹åœ¨å·¦ä¸‹è§’
            maze[size - 2][1] = 0;
            
            return maze;
        }
        
        // æ·»åŠ ç§»åŠ¨æ•Œäººï¼ˆç”¨äºèºæ—‹å…³å¡ï¼‰
        function addMovingEnemies(size, count) {
            singlePlayerGame.movingEnemies = [];
            
            for (let i = 0; i < count; i++) {
                // éšæœºä½ç½®ï¼ˆé¿å¼€èµ·ç‚¹å’Œç»ˆç‚¹ï¼‰
                let x, y;
                do {
                    x = Math.floor(Math.random() * (size - 4)) + 2;
                    y = Math.floor(Math.random() * (size - 4)) + 2;
                } while (singlePlayerGame.maze[y][x] === 1 || 
                         (x === 1 && y === size - 2) || 
                         (x === Math.floor(size/2) && y === Math.floor(size/2)));
                
                singlePlayerGame.movingEnemies.push({
                    x, y,
                    dx: Math.random() > 0.5 ? 1 : -1,
                    dy: Math.random() > 0.5 ? 1 : -1,
                    speed: 0.3 + Math.random() * 0.4,
                    color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                    lastMove: 0
                });
            }
        }

        // éªŒè¯è¿·å®«æ˜¯å¦æœ‰è§£
        function validateMaze(maze) {
            // åˆ›å»ºè®¿é—®æ ‡è®°æ•°ç»„
            const visited = Array(maze.length).fill().map(() => Array(maze[0].length).fill(false));
            const queue = [{x: 1, y: 1}];
            visited[1][1] = true;
            
            const exit = findExitPosition(maze);
            
            while (queue.length > 0) {
                const cell = queue.shift();
                
                // å¦‚æœåˆ°è¾¾å‡ºå£ï¼Œè¿”å›true
                if (cell.x === exit.x && cell.y === exit.y) {
                    return true;
                }
                
                // æ£€æŸ¥æ‰€æœ‰æ–¹å‘
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = cell.x + dir.dx;
                    const ny = cell.y + dir.dy;
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨è¾¹ç•Œå†…
                    if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length) {
                        // æ£€æŸ¥æ˜¯å¦æ˜¯å¢™æˆ–æœªè¢«è®¿é—®
                        if (maze[ny][nx] !== 1 && !visited[ny][nx]) {
                            visited[ny][nx] = true;
                            queue.push({x: nx, y: ny});
                        }
                    }
                }
            }
            
            return false;
        }
        
        // å¤‡ç”¨è¿·å®«ç”Ÿæˆï¼ˆç¡®ä¿æœ‰è§£ï¼‰
        function generateBackupMaze(size) {
            const maze = Array(size).fill().map(() => Array(size).fill(1));
            
            // åˆ›å»ºä¸€æ¡ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„è·¯å¾„
            for (let y = 1; y < size - 1; y++) {
                for (let x = 1; x < size - 1; x++) {
                    // åˆ›å»ºåå­—äº¤å‰è·¯å¾„
                    if (x === Math.floor(size/2) || y === Math.floor(size/2)) {
                        maze[y][x] = 0;
                    }
                }
            }
            
            // ç¡®ä¿èµ·ç‚¹å’Œç»ˆç‚¹
            maze[1][1] = 0;
            maze[size-2][size-1] = 0;
            
            return maze;
        }

function generateDifficultMaze(level, settings) {
    const size = settings.size;
    const seed = level;
    const random = new Random(seed);
    
    // åˆ›å»ºè¿·å®« (1=å¢™, 0=è·¯, 2=é™·é˜±, 3=ä¼ é€é—¨, 4=ç§»åŠ¨é™·é˜±, 5=å•å‘é€šé“, 8=é’¥åŒ™, 9=é—¨)
    const maze = Array(size).fill().map(() => Array(size).fill(1));
    
    // ä½¿ç”¨æ”¹è¿›çš„éšæœºPrimç®—æ³•ç”Ÿæˆè¿·å®«
    const walls = [];
    maze[1][1] = 0;
    walls.push(...getCellWalls(1, 1, maze));
    
    while (walls.length > 0) {
        const wallIndex = Math.floor(random.next() * walls.length);
        const wall = walls[wallIndex];
        walls.splice(wallIndex, 1);
        
        const opposite = getOppositeCell(wall, maze);
        
        if (opposite.x > 0 && opposite.x < size-1 && 
            opposite.y > 0 && opposite.y < size-1 && 
            maze[opposite.y][opposite.x] === 1) {
            
            maze[wall.y][wall.x] = 0;
            maze[opposite.y][opposite.x] = 0;
            walls.push(...getCellWalls(opposite.x, opposite.y, maze));
        }
    }
    
    // ç¡®ä¿å‡ºå£å¯è¾¾
    ensureExitPath(maze, random);
    
    // æ·»åŠ é™·é˜±ï¼ˆé¿å¼€å…³é”®è·¯å¾„ï¼‰
    const criticalPath = findCriticalPath(maze);
    for (let i = 0; i < settings.traps; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(random.next() * (size-2)) + 1;
            y = Math.floor(random.next() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || criticalPath.some(p => p.x === x && p.y === y)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y][x] = 2;
        }
    }
    
    // æ·»åŠ ä¼ é€é—¨
    if (level > 10) {
        addTeleporters(maze, random, Math.min(4, Math.floor(level/10)));
    }
    
    // æ·»åŠ ç§»åŠ¨é™·é˜±
    singlePlayerGame.movingTraps = [];
    for (let i = 0; i < settings.movingTraps; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(random.next() * (size-2)) + 1;
            y = Math.floor(random.next() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || criticalPath.some(p => p.x === x && p.y === y)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y][x] = 4;
            singlePlayerGame.movingTraps.push({
                x, y, 
                dx: Math.random() > 0.5 ? 1 : -1,
                dy: Math.random() > 0.5 ? 1 : -1,
                speed: 0.5 + Math.random() * 0.5
            });
        }
    }
    
    // æ·»åŠ å•å‘é€šé“
    for (let i = 0; i < settings.oneWayPaths; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(random.next() * (size-2)) + 1;
            y = Math.floor(random.next() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || criticalPath.some(p => p.x === x && p.y === y)) && attempts < 50);
        
        if (attempts < 50) {
            // 5è¡¨ç¤ºå•å‘é€šé“ (1=å³, 2=å·¦, 3=ä¸‹, 4=ä¸Š)
            maze[y][x] = 50 + Math.floor(random.next() * 4) + 1;
        }
    }
    
    // å¦‚æœæ˜¯æ— è§£å…³å¡ï¼Œå°é—­å‡ºå£è·¯å¾„
    if (gameState.unsolvableLevels.includes(level)) {
        const exit = findExitPosition(maze);
        // å°é—­å‡ºå£å‘¨å›´çš„è·¯å¾„
        const directions = [
            {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
            {dx: 0, dy: 1}, {dx: 0, dy: -1}
        ];
        for (const dir of directions) {
            const nx = exit.x + dir.dx;
            const ny = exit.y + dir.dy;
            if (nx >= 0 && nx < size && ny >= 0 && ny < size && maze[ny][nx] === 0) {
                maze[ny][nx] = 1;
            }
        }
    }
    
    return maze;
    
    // è¾…åŠ©å‡½æ•°ï¼šè·å–å•å…ƒæ ¼çš„å¢™
    function getCellWalls(x, y, maze) {
        const walls = [];
        const directions = [
            {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
            {dx: 0, dy: 1}, {dx: 0, dy: -1}
        ];
        
        for (const dir of directions) {
            const nx = x + dir.dx;
            const ny = y + dir.dy;
            
            if (nx >= 0 && nx < maze[0].length && 
                ny >= 0 && ny < maze.length && 
                maze[ny][nx] === 1) {
                walls.push({x: nx, y: ny});
            }
        }
        
        return walls;
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šè·å–å¯¹é¢çš„å•å…ƒæ ¼
    function getOppositeCell(wall, maze) {
        const directions = [
            {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
            {dx: 0, dy: 1}, {dx: 0, dy: -1}
        ];
        
        for (const dir of directions) {
            const nx = wall.x + dir.dx;
            const ny = wall.y + dir.dy;
            
            if (nx >= 0 && nx < maze[0].length && 
                ny >= 0 && ny < maze.length && 
                maze[ny][nx] === 0) {
                return {x: wall.x - dir.dx, y: wall.y - dir.dy};
            }
        }
        
        return {x: -1, y: -1};
    }
}
        
        // æ‰¾åˆ°å…³é”®è·¯å¾„ï¼ˆä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„ï¼‰
        function findCriticalPath(maze) {
            const start = {x: 1, y: 1};
            const exit = findExitPosition(maze);
            
            // BFSå¯»æ‰¾æœ€çŸ­è·¯å¾„
            const visited = Array(maze.length).fill().map(() => Array(maze[0].length).fill(false));
            const queue = [{...start, path: []}];
            visited[start.y][start.x] = true;
            
            while (queue.length > 0) {
                const cell = queue.shift();
                const newPath = [...cell.path, {x: cell.x, y: cell.y}];
                
                if (cell.x === exit.x && cell.y === exit.y) {
                    return newPath;
                }
                
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = cell.x + dir.dx;
                    const ny = cell.y + dir.dy;
                    
                    if (nx >= 0 && nx < maze[0].length && 
                        ny >= 0 && ny < maze.length && 
                        !visited[ny][nx] && maze[ny][nx] !== 1) {
                        visited[ny][nx] = true;
                        queue.push({x: nx, y: ny, path: newPath});
                    }
                }
            }
            
            return [];
        }
        
        function ensureExitPath(maze, random) {
            const size = maze.length;
            const exit = findExitPosition(maze);
            
            // ä½¿ç”¨BFSç¡®ä¿èµ·ç‚¹åˆ°å‡ºå£æœ‰è·¯å¾„
            const visited = Array(size).fill().map(() => Array(size).fill(false));
            const queue = [{x: 1, y: 1}];
            visited[1][1] = true;
            
            let found = false;
            
            while (queue.length > 0) {
                const cell = queue.shift();
                
                if (cell.x === exit.x && cell.y === exit.y) {
                    found = true;
                    break;
                }
                
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = cell.x + dir.dx;
                    const ny = cell.y + dir.dy;
                    
                    if (nx >= 0 && nx < size && ny >= 0 && ny < size && 
                        !visited[ny][nx] && maze[ny][nx] !== 1) {
                        visited[ny][nx] = true;
                        queue.push({x: nx, y: ny});
                    }
                }
            }
            
            // å¦‚æœè·¯å¾„ä¸å­˜åœ¨ï¼Œæ‰“å¼€ä¸€æ¡è·¯å¾„
            if (!found) {
                let x = 1, y = 1;
                while (x !== exit.x || y !== exit.y) {
                    if (x < exit.x) x++;
                    else if (x > exit.x) x--;
                    else if (y < exit.y) y++;
                    else if (y > exit.y) y--;
                    
                    maze[y][x] = 0;
                }
            }
        }
        
        function addTeleporters(maze, random, count) {
            const size = maze.length;
            singlePlayerGame.teleporters = [];
            
            for (let i = 0; i < count * 2; i++) {
                let x, y;
                do {
                    x = Math.floor(random.next() * (size-2)) + 1;
                    y = Math.floor(random.next() * (size-2)) + 1;
                } while (maze[y][x] !== 0 || singlePlayerGame.teleporters.some(t => t.x === x && t.y === y));
                
                maze[y][x] = 3;
                singlePlayerGame.teleporters.push({x, y, id: Math.floor(i/2)});
            }
        }

        function findStartPosition(maze) {
            return { x: 1, y: 1 };
        }

        function findExitPosition(maze) {
            const size = maze.length;
            const random = new Random(gameState.currentLevel);
            
            // åœ¨è¾¹ç¼˜å¯»æ‰¾åˆé€‚çš„ä½ç½®ä½œä¸ºå‡ºå£
            const edgePositions = [];
            
            // å³ä¾§è¾¹ç¼˜ (x = size-1)
            for (let y = 1; y < size-1; y++) {
                if (maze[y][size-2] === 0) {
                    edgePositions.push({x: size-1, y});
                }
            }
            
            // ä¸‹ä¾§è¾¹ç¼˜ (y = size-1)
            for (let x = 1; x < size-1; x++) {
                if (maze[size-2][x] === 0) {
                    edgePositions.push({x, y: size-1});
                }
            }
            
            if (edgePositions.length > 0) {
                const exit = edgePositions[Math.floor(random.next() * edgePositions.length)];
                maze[exit.y][exit.x] = 0;
                return exit;
            }
            
            // å¦‚æœæ²¡æœ‰åˆé€‚ä½ç½®ï¼Œä½¿ç”¨å³ä¸‹è§’
            maze[size-2][size-1] = 0;
            return {x: size-1, y: size-2};
        }

function resizeSinglePlayerCanvas() {
    // æ£€æŸ¥mazeæ˜¯å¦å·²æ­£ç¡®åˆå§‹åŒ–
    if (!singlePlayerGame.maze || singlePlayerGame.maze.length === 0) {
        console.error("Maze not initialized in resizeSinglePlayerCanvas");
        
        // è®¾ç½®é»˜è®¤ç”»å¸ƒå¤§å°
        singlePlayerGame.canvas.width = 300;
        singlePlayerGame.canvas.height = 300;
        return;
    }
    
    const maxWidth = window.innerWidth - 40;
    const maxHeight = window.innerHeight - 180;
    
    const mazeWidth = singlePlayerGame.maze[0].length;
    const mazeHeight = singlePlayerGame.maze.length;
    
    singlePlayerGame.cellSize = Math.min(
        40,
        Math.floor(maxWidth / mazeWidth),
        Math.floor(maxHeight / mazeHeight)
    );
    
    singlePlayerGame.canvas.width = mazeWidth * singlePlayerGame.cellSize;
    singlePlayerGame.canvas.height = mazeHeight * singlePlayerGame.cellSize;
}

        function drawSinglePlayerMaze() {
            const ctx = singlePlayerGame.ctx;
            ctx.clearRect(0, 0, singlePlayerGame.canvas.width, singlePlayerGame.canvas.height);
            
            // ç»˜åˆ¶è¿·å®«
            for (let y = 0; y < singlePlayerGame.maze.length; y++) {
                for (let x = 0; x < singlePlayerGame.maze[y].length; x++) {
                    const cellValue = singlePlayerGame.maze[y][x];
                    
                    // æ ¹æ®å•å…ƒæ ¼å€¼è®¾ç½®é¢œè‰²
                    switch(cellValue) {
                        case 1: // å¢™
                            ctx.fillStyle = '#333';
                            break;
                        case 2: // é™·é˜±
                            ctx.fillStyle = '#FF0';
                            break;
                        case 3: // ä¼ é€é—¨
                            ctx.fillStyle = '#0FF';
                            break;
                        case 4: // ç§»åŠ¨é™·é˜±
                            ctx.fillStyle = '#F0F';
                            break;
                        case 8: // é’¥åŒ™
                            ctx.fillStyle = 'gold';
                            break;
                        case 9: // é—¨
                            ctx.fillStyle = '#8B4513';
                            break;
                        default: // è·¯
                            if (cellValue >= 50 && cellValue <= 54) {
                                ctx.fillStyle = '#F90'; // å•å‘é€šé“
                            } else {
                                ctx.fillStyle = '#111';
                            }
                    }
                    
                    ctx.fillRect(x * singlePlayerGame.cellSize, y * singlePlayerGame.cellSize, 
                                singlePlayerGame.cellSize, singlePlayerGame.cellSize);
                    
                    // ç»˜åˆ¶ç‰¹æ®Šå…ƒç´ çš„å›¾æ¡ˆ
                    if (cellValue === 2) { // é™·é˜±
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            singlePlayerGame.cellSize/4,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (cellValue === 8) { // é’¥åŒ™
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            singlePlayerGame.cellSize/4,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        ctx.fillStyle = 'gold';
                        ctx.font = 'bold ' + (singlePlayerGame.cellSize/2) + 'px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ğŸ”‘', 
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2
                        );
                    } else if (cellValue === 9) { // é—¨
                        ctx.fillStyle = '#5D4037';
                        ctx.fillRect(
                            x * singlePlayerGame.cellSize, 
                            y * singlePlayerGame.cellSize, 
                            singlePlayerGame.cellSize, 
                            singlePlayerGame.cellSize
                        );
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/4, 
                            y * singlePlayerGame.cellSize, 
                            singlePlayerGame.cellSize/2, 
                            singlePlayerGame.cellSize
                        );
                    } else if (cellValue >= 50 && cellValue <= 54) { // å•å‘é€šé“
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold ' + (singlePlayerGame.cellSize/2) + 'px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        let arrow = '';
                        switch(cellValue) {
                            case 51: arrow = 'â†’'; break; // å³
                            case 52: arrow = 'â†'; break; // å·¦
                            case 53: arrow = 'â†“'; break; // ä¸‹
                            case 54: arrow = 'â†‘'; break; // ä¸Š
                        }
                        
                        ctx.fillText(arrow, 
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2
                        );
                    }
                }
            }
            
            // ç»˜åˆ¶å‡ºå£
            ctx.fillStyle = '#F00';
            ctx.fillRect(singlePlayerGame.exit.x * singlePlayerGame.cellSize, 
                        singlePlayerGame.exit.y * singlePlayerGame.cellSize, 
                        singlePlayerGame.cellSize, singlePlayerGame.cellSize);
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold ' + (singlePlayerGame.cellSize/2) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('å‡º', 
                singlePlayerGame.exit.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                singlePlayerGame.exit.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2
            );
            
            // ç»˜åˆ¶ç©å®¶
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(
                singlePlayerGame.player.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                singlePlayerGame.player.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                singlePlayerGame.cellSize/2 - 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // ç»˜åˆ¶ç§»åŠ¨æ•Œäººï¼ˆç‰¹æ®Šå…³å¡ï¼‰
            for (const enemy of singlePlayerGame.movingEnemies) {
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(
                    enemy.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                    enemy.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                    singlePlayerGame.cellSize/2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // ç»˜åˆ¶æ•Œäººçœ¼ç›
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(
                    enemy.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/3,
                    enemy.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/3,
                    singlePlayerGame.cellSize/8,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
        }

        function startSinglePlayerTimer() {
            clearInterval(singlePlayerGame.timerInterval);
            singlePlayerGame.startTime = Date.now();
            singlePlayerGame.moveCount = 0;
            singlePlayerGame.unlockTimeLeft = 10
            updateSinglePlayerTimer();
            singlePlayerGame.timerInterval = setInterval(updateSinglePlayerTimer, 1000);
        }
function saveGameData() {
    localStorage.setItem('achievements', JSON.stringify(gameState.achievements));
    localStorage.setItem('gameStats', JSON.stringify(gameState.gameStats));
    localStorage.setItem('gameSettings', JSON.stringify(gameState.settings));
}

// å…¨å±€å˜é‡è·Ÿè¸ªå½“å‰æ‰“å¼€çš„æ¨¡æ€æ¡†
let currentModal = null;
function confirmLoadGame(slot) {
    if (gameState.currentScreen !== 'singlePlayerLevelSelect' && 
        gameState.currentScreen !== 'mainMenu') {
        if (!confirm('æ˜¯å¦æ”¾å¼ƒå½“å‰è¿›åº¦å¹¶åŠ è½½å­˜æ¡£ï¼Ÿ')) {
            return;
        }
    }
    
    if (loadGame(slot)) {
        const modal = document.getElementById('saveLoadModal');
        if (modal) modal.remove();
        
        // æ ¹æ®å½“å‰ç•Œé¢åšä¸åŒå¤„ç†
        if (gameState.currentScreen === 'singlePlayerGame') {
            // é‡æ–°åˆå§‹åŒ–æ¸¸æˆä½†ä¿ç•™åŠ è½½çš„ä½ç½®
            initSinglePlayerGame(true); // ä¼ å…¥trueè¡¨ç¤ºæ˜¯åŠ è½½å­˜æ¡£
        } else {
            showScreen('singlePlayerGame');
        }
    }
}

function showSaveLoadMenu() {
    // å…ˆå…³é—­ä»»ä½•ç°æœ‰çš„å­˜æ¡£å¯¹è¯æ¡†
    const existingModal = document.getElementById('saveLoadModal');
    if (existingModal) {
        document.body.removeChild(existingModal);
    }

    const modal = document.createElement('div');
    modal.id = 'saveLoadModal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    `;
    
    modal.innerHTML = `
        <div style="background: #333; padding: 20px; border-radius: 10px; max-width: 500px; width: 90%;">
            <h3 style="color: white; margin-top: 0; text-align: center;">å­˜æ¡£/è¯»æ¡£</h3>
            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                <button onclick="saveGame(0)" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">ä¿å­˜åˆ°å­˜æ¡£1</button>
                <button onclick="confirmLoadGame(0)" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">è¯»å–å­˜æ¡£1</button>
                <button onclick="deleteSave(0)" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">åˆ é™¤å­˜æ¡£1</button>
            </div>
            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                <button onclick="saveGame(1)" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">ä¿å­˜åˆ°å­˜æ¡£2</button>
                <button onclick="confirmLoadGame(1)" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">è¯»å–å­˜æ¡£2</button>
                <button onclick="deleteSave(1)" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">åˆ é™¤å­˜æ¡£2</button>
            </div>
            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                <button onclick="saveGame(2)" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">ä¿å­˜åˆ°å­˜æ¡£3</button>
                <button onclick="confirmLoadGame(2)" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">è¯»å–å­˜æ¡£3</button>
                <button onclick="deleteSave(2)" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">åˆ é™¤å­˜æ¡£3</button>
            </div>
            <button id="saveLoadCloseBtn" style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 5px; width: 100%;">å…³é—­</button>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
    const closeBtn = document.getElementById('saveLoadCloseBtn');
    closeBtn.addEventListener('click', () => {
        modal.remove();
    });
}



function completeLevel() {
    // 1. åœæ­¢æ‰€æœ‰è®¡æ—¶å™¨å’ŒåŠ¨ç”»
    clearInterval(singlePlayerGame.timerInterval);
    clearInterval(singlePlayerGame.movingTrapsInterval);
    clearInterval(singlePlayerGame.unlockTimer);
    
    // 2. å¼ºåˆ¶éšè—æ‰€æœ‰æŒ‰é’®
    document.getElementById('regularNextButton').style.display = 'none';
    document.getElementById('unsolvableNextButton').style.display = 'none';
    
    // 3. æ›´æ–°é€šå…³ä¿¡æ¯æ˜¾ç¤º
    const elapsed = Math.floor((Date.now() - singlePlayerGame.startTime) / 1000);
    document.getElementById('singlePlayerCompleteTime').textContent = 
        `ç”¨æ—¶: ${Math.floor(elapsed/60)}:${(elapsed%60).toString().padStart(2,'0')}`;
    document.getElementById('singlePlayerCompleteMoves').textContent = 
        `ç§»åŠ¨æ¬¡æ•°: ${singlePlayerGame.moveCount}`;
    
    // 4. æ›´æ–°æ¸¸æˆè¿›åº¦
    if (gameState.currentLevel === gameState.unlockedLevel) {
        gameState.unlockedLevel++;
        while (gameState.unsolvableLevels.includes(gameState.unlockedLevel)) {
            gameState.unlockedLevel++;
        }
        localStorage.setItem('unlockedLevel', gameState.unlockedLevel);
    }
    
    if (!gameState.completedLevels.includes(gameState.currentLevel)) {
        gameState.completedLevels.push(gameState.currentLevel);
        localStorage.setItem('completedLevels', JSON.stringify(gameState.completedLevels));
    }
    
    // 5. æ˜¾ç¤ºé€šå…³é¢æ¿
    document.getElementById('singlePlayerComplete').classList.remove('hidden');
    
    // 6. è§£é™¤é”®ç›˜æ§åˆ¶
    window.removeEventListener('keydown', handleSinglePlayerKeyDown);
    
    // 7. ä¿å­˜æ•°æ®
    recordAchievement('levelComplete', 1);

    addCoins(5);

    // ä¿å­˜é‡‘å¸åˆ° localStorage
    localStorage.setItem('playerCoins', gameState.coins);
}

function loadNextLevel() {
    if (gameState.currentLevel < 80) {
        gameState.currentLevel++;
        
        // å¼ºåˆ¶é‡ç½®æ‰€æœ‰çŠ¶æ€
        document.getElementById('singlePlayerComplete').classList.add('hidden');
        document.getElementById('regularNextButton').style.display = 'none';
        document.getElementById('unsolvableNextButton').style.display = 'none';
        
        initSinglePlayerGame();
    } else {
        alert('æ­å–œä½ å®Œæˆäº†æ‰€æœ‰å…³å¡ï¼');
        showScreen('singlePlayerLevelSelect');
    }
}

function resetSinglePlayerLevel() {
    // å¼ºåˆ¶éšè—æŒ‰é’®
    document.getElementById('regularNextButton').style.display = 'none';
    document.getElementById('unsolvableNextButton').style.display = 'none';
    
    // é‡ç½®æ¸¸æˆçŠ¶æ€
    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
    singlePlayerGame.moveCount = 0;
    singlePlayerGame.hasKey = false;
    singlePlayerGame.isUnlocking = false;
    singlePlayerGame.unlockTimeLeft = 10;
    clearInterval(singlePlayerGame.unlockTimer);
    
    // æ›´æ–°UI
    document.getElementById('moveCount').textContent = `ç§»åŠ¨: 0`;
    document.getElementById('keyStatus').textContent = `é’¥åŒ™: æœªè·å¾—`;
    document.getElementById('unlockTimer').classList.add('hidden');
    
    drawSinglePlayerMaze();
}

        function updateSinglePlayerTimer() {
            const elapsed = Math.floor((Date.now() - singlePlayerGame.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timeDisplay').textContent = 
                `æ—¶é—´: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('moveCount').textContent = `ç§»åŠ¨: ${singlePlayerGame.moveCount}`;
        }

        function startMovingTraps() {
            if (singlePlayerGame.movingTrapsInterval) {
                clearInterval(singlePlayerGame.movingTrapsInterval);
            }
            
            singlePlayerGame.movingTrapsInterval = setInterval(moveTraps, 500);
        }

        function moveTraps() {
            const maze = singlePlayerGame.maze;
            const size = maze.length;
            const now = Date.now();
            
            // ç§»åŠ¨æ™®é€šé™·é˜±
            for (let i = 0; i < singlePlayerGame.movingTraps.length; i++) {
                const trap = singlePlayerGame.movingTraps[i];
                
                // å°è¯•ç§»åŠ¨
                let newX = trap.x + Math.round(trap.dx);
                let newY = trap.y + Math.round(trap.dy);
                
                // æ£€æŸ¥è¾¹ç•Œå’Œå¢™å£
                if (newX <= 0 || newX >= size-1 || newY <= 0 || newY >= size-1 || 
                    maze[newY][newX] === 1 || maze[newY][newX] >= 50) {
                    // æ”¹å˜æ–¹å‘
                    trap.dx = Math.random() > 0.5 ? 1 : -1;
                    trap.dy = Math.random() > 0.5 ? 1 : -1;
                    continue;
                }
                
                // æ›´æ–°é™·é˜±ä½ç½®
                maze[trap.y][trap.x] = 0; // æ¸…é™¤æ—§ä½ç½®
                trap.x = newX;
                trap.y = newY;
                maze[newY][newX] = 4; // è®¾ç½®æ–°ä½ç½®
                
                // æ£€æŸ¥æ˜¯å¦ç¢°åˆ°ç©å®¶
                if (trap.x === singlePlayerGame.player.x && trap.y === singlePlayerGame.player.y) {
                    // å›åˆ°èµ·ç‚¹
                    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
                    // singlePlayerGame.hasKey = false;
                    // document.getElementById('keyStatus').textContent = `é’¥åŒ™: æœªè·å¾—`;
                }
            }
            
            // ç§»åŠ¨æ•Œäººï¼ˆç‰¹æ®Šå…³å¡ï¼‰
            for (const enemy of singlePlayerGame.movingEnemies) {
                // æ ¹æ®æ—¶é—´é—´éš”ç§»åŠ¨
                if (now - enemy.lastMove < 500 / enemy.speed) continue;
                enemy.lastMove = now;
                
                // è¿½é€ç©å®¶
                const dx = singlePlayerGame.player.x - enemy.x;
                const dy = singlePlayerGame.player.y - enemy.y;
                
                // ä¼˜å…ˆç§»åŠ¨æ–¹å‘ï¼ˆæ°´å¹³æˆ–å‚ç›´ï¼‰
                if (Math.abs(dx) > Math.abs(dy)) {
                    enemy.dx = dx > 0 ? 1 : -1;
                    enemy.dy = 0;
                } else {
                    enemy.dx = 0;
                    enemy.dy = dy > 0 ? 1 : -1;
                }
                
                // å°è¯•ç§»åŠ¨
                let newX = enemy.x + enemy.dx;
                let newY = enemy.y + enemy.dy;
                
                // æ£€æŸ¥æ˜¯å¦å¯ç§»åŠ¨
                if (newX >= 0 && newX < size && newY >= 0 && newY < size && 
                    maze[newY][newX] !== 1 && maze[newY][newX] < 50) {
                    enemy.x = newX;
                    enemy.y = newY;
                }
                
                // æ£€æŸ¥æ˜¯å¦ç¢°åˆ°ç©å®¶
                if (enemy.x === singlePlayerGame.player.x && enemy.y === singlePlayerGame.player.y) {
                    // å›åˆ°èµ·ç‚¹
                    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
                    // singlePlayerGame.hasKey = false;
                    // document.getElementById('keyStatus').textContent = `é’¥åŒ™: æœªè·å¾—`;
                }
            }
            
            drawSinglePlayerMaze();
        }
function movePlayer(rawKey, isFromSystem = false) {
    // 1. åº”ç”¨åè½¬çŠ¶æ€
    let effectiveKey = rawKey;
    if (gameState.controlsReversed) {
        // åè½¬é€»è¾‘
        effectiveKey = {
            'ArrowUp': 'ArrowDown',
            'ArrowDown': 'ArrowUp',
            'ArrowLeft': 'ArrowRight',
            'ArrowRight': 'ArrowLeft'
        }[rawKey] || rawKey;
        console.log('æ§åˆ¶åè½¬ä¸­:', rawKey, '->', effectiveKey);
    }
    
    // 2. æ ¹æ®æœ€ç»ˆç¡®å®šçš„æ–¹å‘è¿›è¡Œç§»åŠ¨
    let newX = 0, newY = 0;
    
    switch(effectiveKey) {
        case 'ArrowUp': newY--; break;
        case 'ArrowDown': newY++; break;
        case 'ArrowLeft': newX--; break;
        case 'ArrowRight': newX++; break;
        default: return; // ä¸æ˜¯æ–¹å‘é”®ï¼Œä¸å¤„ç†
    }
    // 3. è°ƒç”¨å·²å­˜åœ¨çš„ç§»åŠ¨é€»è¾‘
    if (gameState.currentScreen === 'singlePlayerGame') {
        handleSinglePlayerMoveLogic(newX, newY);
    }
    else if (gameState.currentScreen === 'multiplayerGame') {
        handleMultiplayerMoveLogic(newX, newY);
    }
}

function handleSinglePlayerMoveLogic(dx, dy) {
    const originalPlayerX = singlePlayerGame.player.x;
    const originalPlayerY = singlePlayerGame.player.y;
    
    const newX = originalPlayerX + dx;
    const newY = originalPlayerY + dy;
    
    // è¾¹ç•Œæ£€æŸ¥
    if (newY < 0 || newY >= singlePlayerGame.maze.length || 
        newX < 0 || newX >= singlePlayerGame.maze[0].length) {
        return;
    }

    const cellValue = singlePlayerGame.maze[newY][newX];

    // å¢™
    if (cellValue === 1) return;

    // å•å‘é€šé“
    if (cellValue >= 50 && cellValue <= 54) {
        let allowed = false;
        switch(cellValue) {
            case 51: allowed = (dx > 0); break; // å³
            case 52: allowed = (dx < 0); break; // å·¦
            case 53: allowed = (dy > 0); break; // ä¸‹
            case 54: allowed = (dy < 0); break; // ä¸Š
        }
        if (!allowed) return;
    }

    // é™·é˜±
    if (cellValue === 2 || cellValue === 4) {
        recordAchievement('trapHit', 1);
        singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
        singlePlayerGame.moveCount++;
        document.getElementById('moveCount').textContent = `ç§»åŠ¨: ${singlePlayerGame.moveCount}`;
        drawSinglePlayerMaze();
        return;
    }

    // ä¼ é€é—¨
    if (cellValue === 3 && singlePlayerGame.teleporters.length > 0) {
        const currentPortal = singlePlayerGame.teleporters.find(t => t.x === newX && t.y === newY);
        if (currentPortal) {
            const pairPortals = singlePlayerGame.teleporters.filter(t => 
                t.id === currentPortal.id && (t.x !== newX || t.y !== newY)
            );
            if (pairPortals.length > 0) {
                const targetPortal = pairPortals[Math.floor(Math.random() * pairPortals.length)];
                // åªæ›´æ–°åæ ‡æ•°å€¼ï¼Œè¿™æ˜¯å®‰å…¨çš„
                singlePlayerGame.player.x = targetPortal.x;
                singlePlayerGame.player.y = targetPortal.y;
                singlePlayerGame.moveCount++;
                document.getElementById('moveCount').textContent = `ç§»åŠ¨: ${singlePlayerGame.moveCount}`;
                drawSinglePlayerMaze();
                checkSinglePlayerExit();
                return; // ä¼ é€é€»è¾‘ç»“æŸï¼Œä¸å†æ‰§è¡Œåç»­çš„æ™®é€šç§»åŠ¨é€»è¾‘
            }
        }
    }

    // é’¥åŒ™
    if (cellValue === 8) {
        singlePlayerGame.hasKey = true;
        document.getElementById('keyStatus').textContent = `é’¥åŒ™: å·²è·å¾—`;
        singlePlayerGame.maze[newY][newX] = 0; // ç§»é™¤é’¥åŒ™
    }

    // é—¨
    if (cellValue === 9) {
        if (singlePlayerGame.hasKey) {
            startUnlockDoor();
            return;
        } else {
            alert("ä½ éœ€è¦é’¥åŒ™æ‰èƒ½æ‰“å¼€è¿™æ‰‡é—¨ï¼");
            return;
        }
    }
    
    // æ‰€æœ‰æ£€æŸ¥é€šè¿‡ï¼Œæ‰§è¡Œæ ‡å‡†ç§»åŠ¨
    singlePlayerGame.player.x = newX;
    singlePlayerGame.player.y = newY;
    singlePlayerGame.moveCount++;
    document.getElementById('moveCount').textContent = `ç§»åŠ¨: ${singlePlayerGame.moveCount}`;
    drawSinglePlayerMaze();
    checkSinglePlayerExit();
}


function handleSinglePlayerKeyDown(e) {
    // æ£€æŸ¥æŒ‰é”®æ˜¯å¦æ˜¯æˆ‘ä»¬å…³å¿ƒçš„æ–¹å‘é”®
    const key = e.key;
    if(!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
        return; // ä¸æ˜¯æ–¹å‘é”®ï¼Œä¸å¤„ç†
    }
    
    // ã€é‡è¦ã€‘ä¸å†é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé¿å…å½±å“é¡µé¢æ»šåŠ¨
    // if (typeof e.preventDefault === 'function') {
    //     e.preventDefault();
    // }
    movePlayer(key);
}



// æ›´æ–°è®¡æ—¶å™¨æ˜¾ç¤º
function updateUnlockTimer() {
    document.getElementById('unlockTimer').textContent = 
        `å¼€é—¨å€’è®¡æ—¶: ${singlePlayerGame.unlockTimeLeft}ç§’`;
}
function checkSinglePlayerExit() {
    // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨å‡ºå£ä½ç½®
    if (singlePlayerGame.player.x === singlePlayerGame.exit.x && 
        singlePlayerGame.player.y === singlePlayerGame.exit.y) {
        
        // å¦‚æœæ˜¯ç‰¹æ®Šå…³å¡ä¸”æœ‰é—¨çš„ä½ç½®
        if (gameState.specialLevels.includes(gameState.currentLevel) && 
            singlePlayerGame.doorPosition) {
            
            // æ£€æŸ¥é—¨æ˜¯å¦å·²ç»æ‰“å¼€
            if (singlePlayerGame.maze[singlePlayerGame.doorPosition.y][singlePlayerGame.doorPosition.x] === 0) {
                // é—¨å·²æ‰“å¼€ï¼Œå¯ä»¥é€šå…³
                completeLevel();
            } else {
                // é—¨æœªæ‰“å¼€ï¼Œæç¤ºç©å®¶éœ€è¦é’¥åŒ™
                alert("ä½ éœ€è¦æ‰¾åˆ°é’¥åŒ™å¹¶æ‰“å¼€é—¨æ‰èƒ½é€šå…³ï¼");
                // å°†ç©å®¶ç§»å›é—¨å‰çš„ä½ç½®
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                let moved = false;
                for (const dir of directions) {
                    const nx = singlePlayerGame.exit.x + dir.dx;
                    const ny = singlePlayerGame.exit.y + dir.dy;
                    
                    if (nx >= 0 && nx < singlePlayerGame.maze[0].length && 
                        ny >= 0 && ny < singlePlayerGame.maze.length &&
                        singlePlayerGame.maze[ny][nx] === 0) {
                        singlePlayerGame.player.x = nx;
                        singlePlayerGame.player.y = ny;
                        moved = true;
                        break;
                    }
                }
                
                // å¦‚æœæ— æ³•ç§»åŠ¨ç©å®¶ï¼Œåˆ™é‡ç½®åˆ°èµ·ç‚¹
                if (!moved) {
                    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
                }
                
                drawSinglePlayerMaze();
            }
        } else {
            // æ™®é€šå…³å¡ï¼Œç›´æ¥é€šå…³
            completeLevel();
        }
    }
}

        // =============== å¤šäººæ¸¸æˆP2PåŠŸèƒ½ ===============
        function connectToMultiplayerGame() {
            console.log("è§¦å‘è¿æ¥è‡³å¤šäººè”æœºæ¸¸æˆå‡½æ•°")
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            
            gameState.playerName = document.getElementById('playerName').value.trim() || 'ç©å®¶';
            const roomCodeInput = document.getElementById('roomCode').value.trim();
            
            // è®¾ç½®æœ€å¤§ç©å®¶æ•°
            if (roomCodeInput === '') {
                gameState.multiplayer.maxPlayers = parseInt(document.getElementById('maxPlayers').value);
            }
            
            // åˆå§‹åŒ–Peerè¿æ¥
            try {
                if (roomCodeInput) {
                    // åŠ å…¥ç°æœ‰æˆ¿é—´
                    console.log("åŠ å…¥ç°æœ‰æˆ¿é—´")
                    gameState.multiplayer.isHost = false;
                    gameState.multiplayer.roomCode = roomCodeInput;
                    gameState.multiplayer.peer = new Peer({
                        debug: 2,
                        config: {
                            'iceServers': [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });
                } else {
                    // åˆ›å»ºæ–°æˆ¿é—´
                    console.log("åˆ›å»ºæ–°æˆ¿é—´")
                    gameState.multiplayer.isHost = true;
                    
                    // ä½¿ç”¨æ—¶é—´æˆ³å’Œéšæœºæ•°ç”Ÿæˆæ›´å”¯ä¸€çš„ID
                    const timestamp = new Date().getTime().toString(36);
                    const randomStr = Math.random().toString(36).substring(2, 10);
                    // const roomCode = `room_${timestamp}_${randomStr}`;
                    const roomCode = generateShortRoomCode();

                    gameState.multiplayer.roomCode = roomCode;
                    gameState.multiplayer.peer = new Peer(roomCode, {
                        debug: 2,
                        config: {
                            'iceServers': [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });
                }
                
                // è®¾ç½®Peeräº‹ä»¶å¤„ç†
                gameState.multiplayer.peer.on('open', (id) => {
                    console.log('Peerè¿æ¥å»ºç«‹ï¼ŒID:', id);
                    gameState.multiplayer.currentPlayerId = id;
                    
                    if (gameState.multiplayer.isHost) {
                        // ä¸»æœºé€»è¾‘
                        setupAsHost(id);
                    } else {
                        // è¿æ¥åˆ°ä¸»æœº
                        connectToHost(roomCodeInput);
                    }
                });
                
                gameState.multiplayer.peer.on('connection', (conn) => {
                    console.log('æ”¶åˆ°è¿æ¥è¯·æ±‚:', conn.peer);
                    setupConnection(conn);
                });
                
                gameState.multiplayer.peer.on('error', (err) => {
                    console.error('Peeré”™è¯¯:', err);
                    
                    // å¤„ç†IDè¢«å ç”¨çš„æƒ…å†µ
                    if (err.type === 'peer-unavailable' || err.type === 'unavailable-id') {
                        alert('è¿æ¥å‡ºé”™',err);
                    } else {
                        alert('è¿æ¥é”™è¯¯: ' + err);
                    }
                    
                    showScreen('multiplayerSetup');
                });
                
                // æ›´æ–°UIæ˜¾ç¤ºè¿æ¥çŠ¶æ€
                updateConnectionStatus('connecting');
                
            } catch (err) {
                console.error('åˆå§‹åŒ–Peerå¤±è´¥:', err);
                alert('è¿æ¥åˆå§‹åŒ–å¤±è´¥: ' + err);
            }
        }

        function setupAsHost(peerId) {
            // ç”Ÿæˆå¤šäººæ¸¸æˆè¿·å®«
            console.log("ç”Ÿæˆå¤šäººæ¸¸æˆè¿·å®«")
            gameState.multiplayer.maze = generateMultiplayerMaze();
            
            // æ·»åŠ è‡ªå·±ä½œä¸ºç©å®¶
            gameState.multiplayer.players[peerId] = {
                id: peerId,
                name: gameState.playerName,
                x: 1,
                y: 1,
                color: getRandomColor(),
                reachedExit: false,
                isHost: true
            };
            
            // è®¾ç½®æˆ¿é—´ä»£ç æ˜¾ç¤º
            document.getElementById('multiplayerRoomCode').textContent = 
                `æˆ¿é—´: ${peerId}`;
            
            // å¼€å§‹å¤šäººæ¸¸æˆ
            console.log("å¼€å§‹å¤šäººæ¸¸æˆ")
            startMultiplayerGame();
        }

        function connectToHost(hostId) {
            try {
                // è¿æ¥åˆ°ä¸»æœº
                console.log("è¿æ¥è‡³ä¸»æœº")
                const conn = gameState.multiplayer.peer.connect(hostId, {
                    reliable: true
                });
                
                if (!conn) {
                    console.error("æ— æ³•å»ºç«‹è¿æ¥")
                    throw new Error('æ— æ³•å»ºç«‹è¿æ¥');
                }
                
                setupConnection(conn);
                
                conn.on('open', () => {
                    console.log('å·²è¿æ¥åˆ°ä¸»æœº');
                    // å‘é€åŠ å…¥è¯·æ±‚
                    conn.send({
                        type: 'player-join',
                        player: {
                            id: gameState.multiplayer.currentPlayerId,
                            name: gameState.playerName,
                            color: getRandomColor()
                        }
                    });
                    
                    updateConnectionStatus('connected');
                });
                
                conn.on('error', (err) => {
                    console.error('è¿æ¥é”™è¯¯:', err);
                    alert('è¿æ¥ä¸»æœºå¤±è´¥: ' + err);
                    updateConnectionStatus('disconnected');
                    disconnectMultiplayer()
                });
                
            } catch (err) {
                console.error('è¿æ¥å¼‚å¸¸:', err);
                alert('è¿æ¥å¼‚å¸¸: ' + err.message);
                updateConnectionStatus('disconnected');
                disconnectMultiplayer()
            }
        }

        function setupConnection(conn) {
            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§ç©å®¶æ•°
            if (gameState.multiplayer.isHost && 
                Object.keys(gameState.multiplayer.players).length >= gameState.multiplayer.maxPlayers) {
                console.log('æˆ¿é—´å·²æ»¡ï¼Œæ‹’ç»è¿æ¥:', conn.peer);
                conn.send({
                    type: 'room-full',
                    message: 'æˆ¿é—´å·²æ»¡ï¼Œæ— æ³•åŠ å…¥'
                });
                conn.close();
                return;
            }
            
            // å­˜å‚¨è¿æ¥
            gameState.multiplayer.connections[conn.peer] = conn;
            
            // å¤„ç†æ”¶åˆ°çš„æ¶ˆæ¯
            conn.on('data', (data) => {
                handleMultiplayerData(data, conn.peer);
            });
            
            conn.on('close', () => {
                console.log('è¿æ¥å…³é—­:', conn.peer);
                removePlayer(conn.peer);
            });
            
            conn.on('error', (err) => {
                console.error('è¿æ¥é”™è¯¯:', conn.peer, err);
                removePlayer(conn.peer);
            });
        }
// ç”Ÿæˆç®€çŸ­æˆ¿é—´å·ï¼ˆ5ä½æ•°å­—ï¼‰
function generateShortRoomCode() {
    // ç”Ÿæˆ5ä½éšæœºæ•°å­—
    const code = Math.floor(10000 + Math.random() * 90000).toString();
    return `room_${code}`;
}
// æ—¶é—´æŒ‘æˆ˜æ¨¡å¼
function startTimeChallenge() {
    gameState.currentChallenge = 'time';
    gameState.currentLevel = 1;
    showScreen('singlePlayerGame');
    
    // æ·»åŠ æ—¶é—´æŒ‘æˆ˜UI
    const timeChallengeInfo = document.createElement('div');
    timeChallengeInfo.className = 'time-challenge-info';
    timeChallengeInfo.id = 'timeChallengeInfo';
    timeChallengeInfo.innerHTML = 'â±ï¸ æ—¶é—´æŒ‘æˆ˜æ¨¡å¼<br>å‰©ä½™æ—¶é—´: <span id="challengeTimeLeft">60</span>ç§’';
    document.getElementById('singlePlayerGame').appendChild(timeChallengeInfo);
    
    // å¯åŠ¨æ—¶é—´æŒ‘æˆ˜è®¡æ—¶å™¨
    startTimeChallengeTimer();
}

function startTimeChallengeTimer() {
    let timeLeft = 60; // 60ç§’æŒ‘æˆ˜
    const timerElement = document.getElementById('challengeTimeLeft');
    
    const challengeTimer = setInterval(() => {
        timeLeft--;
        timerElement.textContent = timeLeft;
        
        if (timeLeft <= 0) {
            clearInterval(challengeTimer);
            alert('æ—¶é—´åˆ°ï¼æŒ‘æˆ˜å¤±è´¥ï¼');
            showScreen('moreChallenges');
            document.getElementById('timeChallengeInfo').remove();
        }
        
        // æ—¶é—´è­¦å‘Š
        if (timeLeft <= 10) {
            timerElement.style.color = '#ff4444';
            timerElement.style.animation = 'pulse 0.5s infinite';
        }
    }, 1000);
    
    // ä¿å­˜è®¡æ—¶å™¨å¼•ç”¨ä»¥ä¾¿æ¸…ç†
    gameState.challengeTimer = challengeTimer;
}

// è§£è°œæ¨¡å¼
function startPuzzleMode() {
    gameState.currentChallenge = 'puzzle';
    gameState.currentLevel = 1;
    showScreen('singlePlayerGame');
    
    // è¿™é‡Œå¯ä»¥æ·»åŠ ç‰¹æ®Šçš„è§£è°œå…³å¡é€»è¾‘
    // ä¾‹å¦‚ï¼šéœ€è¦æŒ‰ç…§ç‰¹å®šé¡ºåºè¸©è¸æŒ‰é’®ç­‰
}

// æˆå°±ç³»ç»Ÿå‡½æ•°
function updateAchievementProgress() {
    // æ›´æ–°æˆå°±1ï¼šé€šå…³æ‰€æœ‰å…³å¡
    const totalLevels = 80;
    const progress1 = (gameState.achievements.allLevelsCompleted ? totalLevels : gameState.gameStats.totalLevelsCompleted) / totalLevels * 100;
    document.getElementById('progress1').style.width = progress1 + '%';
    document.getElementById('progressText1').textContent = 
        gameState.achievements.allLevelsCompleted ? '80/80' : gameState.gameStats.totalLevelsCompleted + '/80';
    
    if (gameState.achievements.allLevelsCompleted) {
        document.getElementById('achievement1').classList.add('completed');
        document.getElementById('status1').textContent = 'å·²å®Œæˆ';
    }
    
    // æ›´æ–°æˆå°±2ï¼šå¤šäººæ¸¸æˆèƒœåˆ©
    const progress2 = Math.min(gameState.achievements.multiplayerWins / 10 * 100, 100);
    document.getElementById('progress2').style.width = progress2 + '%';
    document.getElementById('progressText2').textContent = gameState.achievements.multiplayerWins + '/10';
    
    if (gameState.achievements.multiplayerWins >= 10) {
        document.getElementById('achievement2').classList.add('completed');
        document.getElementById('status2').textContent = 'å·²å®Œæˆ';
    }
    
    // æ›´æ–°æˆå°±3ï¼šé™·é˜±æ¬¡æ•°
    const progress3 = Math.min(gameState.achievements.trapHits / 10 * 100, 100);
    document.getElementById('progress3').style.width = progress3 + '%';
    document.getElementById('progressText3').textContent = gameState.achievements.trapHits + '/30';
    
    if (gameState.achievements.trapHits >= 30) {
        document.getElementById('achievement3').classList.add('completed');
        document.getElementById('status3').textContent = 'å·²å®Œæˆ';
    }
}

// è®°å½•æˆå°±è¿›åº¦
function recordAchievement(type, value = 1) {
    switch(type) {
        case 'levelComplete':
            gameState.gameStats.totalLevelsCompleted += value;
            
            // æ£€æŸ¥æ˜¯å¦å®Œæˆæ‰€æœ‰å…³å¡
            if (gameState.gameStats.totalLevelsCompleted == 80) {
                gameState.achievements.allLevelsCompleted = true;
                showAchievementUnlocked('è¿·å®«å¤§å¸ˆ', 'æ­å–œä½ é€šå…³æ‰€æœ‰å…³å¡ï¼');
            }
            break;
            
        case 'multiplayerWin':
            gameState.achievements.multiplayerWins += value;
            
            if (gameState.achievements.multiplayerWins == 10) {
                showAchievementUnlocked('ç¤¾äº¤è¾¾äºº', 'å®Œæˆ10æ¬¡å¤šäººè”æœºæŒ‘æˆ˜ï¼');
            }
            break;
            
        case 'trapHit':
            gameState.achievements.trapHits += value;
            
            if (gameState.achievements.trapHits == 30) {
                showAchievementUnlocked('é™·é˜±ä¸“å®¶', 'æˆåŠŸè¸©ä¸­é™·é˜±30æ¬¡ï¼');
            }
            break;
    }
    
    saveGameData();
    updateAchievementProgress();
}

// æ˜¾ç¤ºæˆå°±è§£é”æç¤º
function showAchievementUnlocked(title, description) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 3px solid #FFD700;
        border-radius: 15px;
        padding: 20px;
        text-align: center;
        z-index: 10000;
        animation: popIn 0.5s ease-out;
    `;
    
    notification.innerHTML = `
        <h3 style="color: #FFD700; margin: 0 0 10px 0;">ğŸ† æˆå°±è§£é”ï¼</h3>
        <h4 style="color: white; margin: 0 0 10px 0;">${title}</h4>
        <p style="color: #ccc; margin: 0;">${description}</p>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.remove();
    }, 3000);
}

// å­˜æ¡£ç³»ç»Ÿ
// æ–°å¢åˆ é™¤å­˜æ¡£åŠŸèƒ½
function deleteSave(slot) {
    gameState.saveSlots[slot] = {};
    localStorage.setItem('saveSlots', JSON.stringify(gameState.saveSlots));
    showNotification(`å­˜æ¡£ä½ç½® ${slot + 1} å·²åˆ é™¤`);
}

// ä¿®æ”¹ä¿å­˜æ¸¸æˆå‡½æ•° - ç¡®ä¿ä¿å­˜ç©å®¶ä½ç½®
function saveGame(slot = gameState.currentSaveSlot) {
    // ä¿å­˜æ ¸å¿ƒè¿›åº¦æ•°æ®å’Œå½“å‰ç©å®¶ä½ç½®
    const saveData = {
        unlockedLevel: gameState.unlockedLevel,
        completedLevels: gameState.completedLevels,
        achievements: gameState.achievements,
        gameStats: gameState.gameStats,
        currentLevel: gameState.currentLevel,
        playerData: {
            x: singlePlayerGame.player.x,
            y: singlePlayerGame.player.y,
            hasKey: singlePlayerGame.hasKey
        },
        mazeState: JSON.parse(JSON.stringify(singlePlayerGame.maze)) // ä¿å­˜è¿·å®«çŠ¶æ€
    };
    
    gameState.saveSlots[slot] = saveData;
    localStorage.setItem('saveSlots', JSON.stringify(gameState.saveSlots));
    showNotification(`æ¸¸æˆå·²å­˜æ¡£è‡³ä½ç½® ${slot + 1}`);
}

// æ­£ç¡®åŠ è½½ç©å®¶ä½ç½®
function loadGame(slot = gameState.currentSaveSlot) {
    const saveData = gameState.saveSlots[slot];
    if (!saveData) return false;
    
    // æ¢å¤æ¸¸æˆçŠ¶æ€
    gameState.unlockedLevel = saveData.unlockedLevel;
    gameState.completedLevels = saveData.completedLevels;
    gameState.achievements = saveData.achievements;
    gameState.gameStats = saveData.gameStats;
    gameState.currentLevel = saveData.currentLevel;
    
    // æ¢å¤ç©å®¶ä½ç½®å’ŒçŠ¶æ€
    if (saveData.playerData) {
        singlePlayerGame.player.x = saveData.playerData.x;
        singlePlayerGame.player.y = saveData.playerData.y;
        singlePlayerGame.hasKey = saveData.playerData.hasKey || false;
    } else {
        // å…¼å®¹æ—§å­˜æ¡£
        singlePlayerGame.player.x = 1;
        singlePlayerGame.player.y = 1;
        singlePlayerGame.hasKey = false;
    }
    
    // æ¢å¤è¿·å®«çŠ¶æ€
    if (saveData.mazeState) {
        singlePlayerGame.maze = saveData.mazeState;
        
        // æ¢å¤é’¥åŒ™å’Œé—¨çš„ä½ç½®ï¼ˆå¦‚æœéœ€è¦ï¼‰
        if (saveData.playerData && saveData.playerData.hasKey) {
            // æŸ¥æ‰¾é’¥åŒ™ä½ç½®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            for (let y = 0; y < singlePlayerGame.maze.length; y++) {
                for (let x = 0; x < singlePlayerGame.maze[y].length; x++) {
                    if (singlePlayerGame.maze[y][x] === 8) {
                        singlePlayerGame.keyPosition = {x, y};
                        break;
                    }
                }
            }
            
            // æŸ¥æ‰¾é—¨ä½ç½®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            for (let y = 0; y < singlePlayerGame.maze.length; y++) {
                for (let x = 0; x < singlePlayerGame.maze[y].length; x++) {
                    if (singlePlayerGame.maze[y][x] === 9) {
                        singlePlayerGame.doorPosition = {x, y};
                        break;
                    }
                }
            }
        }
    }
    
    showNotification(`å·²åŠ è½½å­˜æ¡£ä½ç½® ${slot + 1}`);
    return true;
}



// æ·»åŠ é€šçŸ¥æ˜¾ç¤ºåŠŸèƒ½
function showNotification(message, duration = 2000) {
    // ç§»é™¤ç°æœ‰çš„é€šçŸ¥
    const existingNotification = document.getElementById('gameNotification');
    if (existingNotification) {
        existingNotification.remove();
    }

    // åˆ›å»ºæ–°çš„é€šçŸ¥å…ƒç´ 
    const notification = document.createElement('div');
    notification.id = 'gameNotification';
    notification.textContent = message;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        animation: fadeIn 0.3s ease-out;
    `;

    document.body.appendChild(notification);

    // è‡ªåŠ¨æ¶ˆå¤±
    setTimeout(() => {
        notification.style.animation = 'fadeOut 0.3s ease-out';
        setTimeout(() => notification.remove(), 300);
    }, duration);

    // æ·»åŠ åŠ¨ç”»å…³é”®å¸§
    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        @keyframes fadeOut {
            from { opacity: 1; transform: translateX(-50%) translateY(0); }
            to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }
    `;
    document.head.appendChild(style);
}



// é€€å‡ºç¡®è®¤
function showExitConfirmation() {
    const modal = document.createElement('div');
    modal.id = 'exitConfirmationModal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    `;
    
    modal.innerHTML = `
        <div style="background: #333; padding: 20px; border-radius: 10px; width: 300px; max-width: 90%;">
            <h3 style="color: white; margin-top: 0; text-align: center;">é€€å‡ºå…³å¡</h3>
            <p style="color: #ccc; text-align: center;">æ˜¯å¦è¦ä¿å­˜å½“å‰è¿›åº¦ï¼Ÿ</p>
            <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                <button id="saveAndExitBtn" style="padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px;">ä¿å­˜å¹¶é€€å‡º</button>
                <button id="exitWithoutSavingBtn" style="padding: 10px; background: #f44336; color: white; border: none; border-radius: 5px;">ä¸ä¿å­˜é€€å‡º</button>
                <button id="cancelExitBtn" style="padding: 10px; background: #555; color: white; border: none; border-radius: 5px;">å–æ¶ˆ</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
    document.getElementById('saveAndExitBtn').addEventListener('click', () => {
        saveGame();  // é€€å‡ºæ—¶ä¿å­˜
        showScreen('singlePlayerLevelSelect');
        modal.remove();
    });
    
    document.getElementById('exitWithoutSavingBtn').addEventListener('click', () => {
        showScreen('singlePlayerLevelSelect');
        modal.remove();
    });
    
    document.getElementById('cancelExitBtn').addEventListener('click', () => {
        modal.remove();
    });
}

function handleMultiplayerData(data, peerId) {
            if (peerId === gameState.multiplayer.currentPlayerId && (data.type !== 'game-state')) {
                return;
            }
            switch(data.type) {
                case 'private-message':
                    // æ”¶åˆ°ç§èŠæ¶ˆæ¯
                    console.log(data);
                    const sender = gameState.multiplayer.players[data.from];
                    if (sender) {
                        const msg = `${data.message}`;
                        showMessageToSelf(msg);
                        alert(msg); // å¼¹å‡ºæç¤º
                    }
                    break;
                case 'room-full':
                    disconnectMultiplayer();
                    showScreen('multiplayerSetup');
                    alert('æˆ¿é—´å·²æ»¡ï¼Œæ— æ³•åŠ å…¥');
                    break;
                case 'door-open':
                        gameState.multiplayer.maze[data.y][data.x] = 0;
                        document.getElementById('unlockTimer').classList.add('hidden');
                        gameState.multiplayer.isUnlocking = false;
                        drawMultiplayerMaze();
                    break;  
                case 'player-join':
                    // æ–°ç©å®¶åŠ å…¥
                    console.log(data);
                    addPlayer(data.player);
                    // å¦‚æœæ˜¯ä¸»æœºï¼Œå‘é€å½“å‰æ¸¸æˆçŠ¶æ€ç»™æ–°ç©å®¶
                    if (gameState.multiplayer.isHost) {
                        gameState.multiplayer.connections[peerId].send({
                            type: 'game-state',
                            maze: gameState.multiplayer.maze,
                            players: gameState.multiplayer.players,
                            exit: gameState.multiplayer.exit,
                            teleporters: gameState.multiplayer.teleporters,
                            maxPlayers: gameState.multiplayer.maxPlayers,
                            protectedPlayers: gameState.multiplayer.protectedPlayers
                        });
                    }
                    drawMultiplayerMaze();
                    break;
                case 'key-pickup':
                    if (gameState.multiplayer.players[data.playerId]) {
                        gameState.multiplayer.players[data.playerId].hasKey = true;
                        delete gameState.multiplayer.keyPosition;
                        drawMultiplayerMaze();
                    }
                    break;
                case 'game-state':
                        // æ”¶åˆ°æ¸¸æˆçŠ¶æ€ï¼ˆå®¢æˆ·ç«¯ï¼‰
                        gameState.multiplayer.maze = data.maze;
                        gameState.multiplayer.players = data.players;
                        gameState.multiplayer.exit = data.exit;
                        gameState.multiplayer.teleporters = data.teleporters;
                        gameState.multiplayer.movingEnemies = data.movingEnemies || [];
                        gameState.multiplayer.keyPosition = data.keyPosition || null;
                        gameState.multiplayer.doorPosition = data.doorPosition || null;
                        gameState.multiplayer.maxPlayers = data.maxPlayers;
                        gameState.multiplayer.protectedPlayers = data.protectedPlayers || {};
                        
                        // æ·»åŠ è‡ªå·±åˆ°ç©å®¶åˆ—è¡¨
                        if (!gameState.multiplayer.players[gameState.multiplayer.currentPlayerId]) {
                            gameState.multiplayer.players[gameState.multiplayer.currentPlayerId] = {
                                id: gameState.multiplayer.currentPlayerId,
                                name: gameState.playerName,
                                x: 1,
                                y: 1,
                                color: getRandomColor(),
                                reachedExit: false
                            };
                        }
                        
                        // å¼€å§‹æ¸¸æˆ
                        startMultiplayerGame();
                        break;
                    
                case 'enemy-move':
                    // æ›´æ–°æ•Œäººä½ç½®
                    if (data.enemies) {
                        gameState.multiplayer.movingEnemies = data.enemies;
                        drawMultiplayerMaze();
                    }
                    break;
                case 'player-move':
                    if (peerId === gameState.multiplayer.currentPlayerId) {
                        break;
                    }
                    // ç©å®¶ç§»åŠ¨
                    if (gameState.multiplayer.players[peerId]) {
                        gameState.multiplayer.players[peerId].x = data.x;
                        gameState.multiplayer.players[peerId].y = data.y;
                        
                        // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å‡ºå£
                        if (data.x === gameState.multiplayer.exit.x && 
                            data.y === gameState.multiplayer.exit.y) {
                            gameState.multiplayer.players[peerId].reachedExit = true;
                            
                            // å¹¿æ’­ç©å®¶åˆ°è¾¾å‡ºå£
                            broadcast({
                                type: 'player-reached-exit',
                                playerId: peerId
                            });
                        }
                        
                        drawMultiplayerMaze();
                        updatePlayerList();
                    }
                    break;
                case 'key-pickup':
                        if (gameState.multiplayer.players[data.playerId]) {
                            gameState.multiplayer.players[data.playerId].hasKey = true;
                            delete gameState.multiplayer.keyPosition;
                            drawMultiplayerMaze();
                        }
                        break;
                        
                case 'door-open':
                        gameState.multiplayer.maze[data.y][data.x] = 0;
                        drawMultiplayerMaze();
                        break;
                        
                case 'enemy-move':
                        if (gameState.multiplayer.movingEnemies) {
                            gameState.multiplayer.movingEnemies = data.enemies;
                            drawMultiplayerMaze();
                        }
                        break;    
                case 'teleport-request':
                    // å¤„ç†ä¼ é€è¯·æ±‚ï¼ˆåªæœ‰ä¸»æœºä¼šæ”¶åˆ°ï¼‰
                    console.log(data);
                    if (gameState.multiplayer.isHost) {
                        const teleporter = gameState.multiplayer.teleporters.find(t => 
                            t.x === data.teleporterX && t.y === data.teleporterY);
                        
                        if (teleporter && gameState.multiplayer.players[data.playerId]) {
                            // ä¼ é€ç©å®¶
                            gameState.multiplayer.players[data.playerId].x = teleporter.pairX;
                            gameState.multiplayer.players[data.playerId].y = teleporter.pairY;
                            
                            // å¹¿æ’­ä¼ é€
                            broadcast({
                                type: 'player-teleport',
                                playerId: data.playerId,
                                x: teleporter.pairX,
                                y: teleporter.pairY
                            });
                            
                            drawMultiplayerMaze();
                            updatePlayerList();
                        }
                    }
                    break;
                    
                case 'player-teleport':
                    console.log(data);
                    // å¤„ç†ç©å®¶ä¼ é€
                    if (gameState.multiplayer.players[data.playerId]) {
                        gameState.multiplayer.players[data.playerId].x = data.x;
                        gameState.multiplayer.players[data.playerId].y = data.y;
                        drawMultiplayerMaze();
                        updatePlayerList();
                    }
                    break;
                    
                case 'player-reached-exit':
                    console.log(data);
                    // ç©å®¶åˆ°è¾¾å‡ºå£
                    if (gameState.multiplayer.players[data.playerId]) {
                        gameState.multiplayer.players[data.playerId].reachedExit = true;
                        
                        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½åˆ°è¾¾å‡ºå£
                        checkAllPlayersReachedExit();
                        
                        updatePlayerList();
                    }
                    break;
                    
                case 'player-joined':
                    console.log(data);
                    // æ–°ç©å®¶åŠ å…¥é€šçŸ¥
                    if (!gameState.multiplayer.players[data.player.id]) {
                        gameState.multiplayer.players[data.player.id] = data.player;
                        updatePlayerList();
                        drawMultiplayerMaze();
                    }
                    break;
                    
                case 'player-kicked':
                    console.log(data);
                    // ç©å®¶è¢«è¸¢å‡ºé€šçŸ¥
                    if (data.playerId === gameState.multiplayer.currentPlayerId) {
                        alert('ä½ å·²è¢«ç®¡ç†å‘˜è¸¢å‡ºæˆ¿é—´');
                        disconnectMultiplayer();
                        showScreen('multiplayerSetup');
                    } else {
                        removePlayer(data.playerId);
                    }
                    break;
                    
                case 'player-protected':
                    console.log(data);
                    // ç©å®¶ä¿æŠ¤çŠ¶æ€æ›´æ–°
                    if (data.protected) {
                        gameState.multiplayer.protectedPlayers[data.playerId] = true;
                    } else {
                        delete gameState.multiplayer.protectedPlayers[data.playerId];
                    }
                    updatePlayerList();
                    break;
                    
                case 'kick-player':
                    console.log(data);
                    // è¸¢å‡ºç©å®¶è¯·æ±‚ï¼ˆåªæœ‰ä¸»æœºä¼šæ”¶åˆ°ï¼‰
                    if (gameState.multiplayer.isHost) {
                        const playerId = data.playerId;
                        const reason = data.reason || 'æœªçŸ¥åŸå› ';
                        
                        // æ£€æŸ¥ç©å®¶æ˜¯å¦å—ä¿æŠ¤
                        if (gameState.multiplayer.protectedPlayers[playerId]) {
                            // å‘é€è¸¢å‡ºå¤±è´¥æ¶ˆæ¯
                            gameState.multiplayer.connections[data.requestorId].send({
                                type: 'kick-failed',
                                playerId: playerId,
                                reason: 'err75937'
                            });
                        } else {
                            // è¸¢å‡ºç©å®¶
                            kickPlayer(playerId, reason);
                        }
                    }
                    break;
                    
                case 'kick-failed':
                    console.log(data);
                    // è¸¢å‡ºå¤±è´¥é€šçŸ¥
                    alert(`è¸¢å‡ºç©å®¶å¤±è´¥: ${data.reason}`);
                    break;
            }
        }

        function addPlayer(player) {
            gameState.multiplayer.players[player.id] = {
                ...player,
                x: 1,
                y: 1,
                reachedExit: false
            };
            
            // å¹¿æ’­æ–°ç©å®¶åŠ å…¥ï¼ˆé™¤äº†è‡ªå·±ï¼‰
            broadcast({
                type: 'player-joined',
                player: gameState.multiplayer.players[player.id]
            }, player.id);
            
            updatePlayerList();
            drawMultiplayerMaze();
        }

        function removePlayer(playerId) {
            delete gameState.multiplayer.players[playerId];
            delete gameState.multiplayer.connections[playerId];
            delete gameState.multiplayer.protectedPlayers[playerId];
            
            updatePlayerList();
            drawMultiplayerMaze();
        }


function broadcast(data, excludePlayerId = null) {
    for (const connId in gameState.multiplayer.connections) {
        if (connId !== excludePlayerId) {
            const connection = gameState.multiplayer.connections[connId];
            if (connection.open) {  // åªæœ‰è¿æ¥æ‰“å¼€æ—¶æ‰å‘é€
                try {
                    connection.send(data);
                } catch (err) {
                    console.error('å¹¿æ’­é”™è¯¯:', err);
                    // å¦‚æœå‘é€å¤±è´¥ï¼Œå¤„ç†è¿æ¥å¤±æ•ˆçš„æƒ…å†µ
                    removePlayer(connId);
                }
            }
        }
    }
}

        function startMultiplayerGame() {
            gameState.multiplayer.connected = true;
            gameState.multiplayer.moveCount = 0;
            gameState.multiplayer.hasKey = false;
            gameState.multiplayer.isUnlocking = false;
            gameState.multiplayer.unlockTimeLeft = 10;
            clearInterval(gameState.multiplayer.unlockTimer);
            
            // å¦‚æœæ˜¯èºæ—‹è¿·å®«ï¼Œæ˜¾ç¤ºæ•Œäººè­¦å‘Š
            if (gameState.multiplayer.movingEnemies) {
                document.getElementById('enemyInfo').classList.remove('hidden');
                document.getElementById('keyInfo').classList.remove('hidden');
            } else {
                document.getElementById('enemyInfo').classList.add('hidden');
                document.getElementById('keyInfo').classList.add('hidden');
            }
                    
            // è®¾ç½®æˆ¿é—´ä»£ç æ˜¾ç¤º
            document.getElementById('multiplayerRoomCode').textContent = 
                `æˆ¿é—´: ${gameState.multiplayer.roomCode}`;
            document.getElementById('multiplayerMoveCount').textContent = `ç§»åŠ¨: 0`;
            updatePlayerCount();

            // åˆå§‹åŒ–ç”»å¸ƒ
            console.log("åˆå§‹åŒ–ç”»å¸ƒ")
            initMultiplayerCanvas();
            // å¼€å§‹è®¡æ—¶
            console.log("å¼€å§‹è®¡æ—¶")
            startMultiplayerTimer();
            
            // æ›´æ–°è¿æ¥çŠ¶æ€
            console.log("æ›´æ–°è¿æ¥çŠ¶æ€")
            updateConnectionStatus('connected');
            
            // æ˜¾ç¤ºæ¸¸æˆç•Œé¢
            console.log("æ˜¾ç¤ºæ¸¸æˆç”»é¢")
            showScreen('multiplayerGame');

            function gameLoop() {
                // updateMultiplayerGame();
                EventSystem.update();
                requestAnimationFrame(gameLoop);
            }
            
            // å¯åŠ¨æ¸¸æˆå¾ªç¯
            gameLoop();
            // åº”ç”¨UIè®¾ç½®
            console.log("åº”ç”¨UIè®¾ç½®")
            applyUISettings();
        }

function handleMultiplayerMoveLogic(dx, dy) {
    // 1. è·å–å½“å‰å›åˆçš„ç©å®¶å¯¹è±¡
    const currentPlayer = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
    if (!currentPlayer || currentPlayer.reachedExit) {
        return; // å¦‚æœç©å®¶ä¸å­˜åœ¨æˆ–å·²ç»åˆ°è¾¾ç»ˆç‚¹ï¼Œåˆ™ä¸åšä»»ä½•äº‹
    }

    // 2. è®¡ç®—æ–°çš„ç›®æ ‡ä½ç½®
    const newX = currentPlayer.x + dx;
    const newY = currentPlayer.y + dy;

    // 3. è¾¹ç•Œæ£€æŸ¥
    if (newY < 0 || newY >= gameState.multiplayer.maze.length || 
        newX < 0 || newX >= gameState.multiplayer.maze[0].length) {
        return;
    }

    const cellValue = gameState.multiplayer.maze[newY][newX];
    
    // 4. è§„åˆ™æ£€æŸ¥
    // --------------------------------------------------

    // 4.1 å¢™
    if (cellValue === 1) return;

    // 4.2 é™·é˜±
    if (cellValue === 2) {
        // å¦‚æœç©å®¶æ˜¯ä¸»æœºä¸”å—ä¿æŠ¤ï¼ˆæ— æ•Œï¼‰ï¼Œåˆ™å¿½ç•¥é™·é˜±
        if (currentPlayer.isHost && gameState.multiplayer.protectedPlayers[currentPlayer.id]) {
            console.log('ä¸»æœºç©å®¶æ— æ•Œï¼Œæ— è§†é™·é˜±');
        } else {
            // æ™®é€šç©å®¶ï¼Œå›åˆ°èµ·ç‚¹
            currentPlayer.x = 1;
            currentPlayer.y = 1;
            gameState.multiplayer.moveCount++;
            document.getElementById('multiplayerMoveCount').textContent = `ç§»åŠ¨: ${gameState.multiplayer.moveCount}`;
            console.log('è¸©åˆ°é™·é˜±ï¼Œå›åˆ°èµ·ç‚¹ï¼');
            
            // ã€å…³é”®ä¿®å¤ 1ã€‘å³ä½¿å›åˆ°èµ·ç‚¹ï¼Œä¹Ÿéœ€è¦å¹¿æ’­è¿™æ¬¡ç§»åŠ¨ï¼Œä»¥æ›´æ–°æ‰€æœ‰ç©å®¶çš„è§†å›¾
            if (currentPlayer.isHost) {
                // ä¸»æœºç©å®¶ç§»åŠ¨åï¼Œéœ€è¦æ›´æ–°æ‰€æœ‰ç©å®¶çš„è§†å›¾
                broadcast({
                    type: 'player-move',
                    playerId: currentPlayer.id,
                    x: currentPlayer.x,
                    y: currentPlayer.y
                });
            } else {
                // æ™®é€šç©å®¶åªéœ€è¦æ›´æ–°è‡ªå·±çš„è§†å›¾
                drawMultiplayerMaze();
                updatePlayerList();
            }
            return; // é™·é˜±å¤„ç†ç»“æŸï¼Œä¸å†æ‰§è¡Œåç»­é€»è¾‘
        }
    }
    
    // 4.3 ä¼ é€é—¨
    if (cellValue === 3) {
        // æ‰¾åˆ°ä¼ é€é—¨å¯¹è±¡
        const teleporter = gameState.multiplayer.teleporters.find(t => t.x === newX && t.y === newY);
        if (teleporter) {
            // æ‰§è¡Œä¼ é€
            currentPlayer.x = teleporter.pairX;
            currentPlayer.y = teleporter.pairY;
            
            // ã€å…³é”®ä¿®å¤ 2ã€‘ä¼ é€æ“ä½œå®Œæˆåï¼Œå¿…é¡»å¹¿æ’­æ–°ä½ç½®
            broadcast({
                type: 'player-teleport',
                playerId: currentPlayer.id,
                x: currentPlayer.x,
                y: currentPlayer.y
            });
            
            gameState.multiplayer.moveCount++;
            document.getElementById('multiplayerMoveCount').textContent = `ç§»åŠ¨: ${gameState.multiplayer.moveCount}`;
            
            console.log('ä¼ é€!');

            drawMultiplayerMaze();
            updatePlayerList();
            // ä¼ é€åæ£€æŸ¥æ˜¯å¦åˆ°è¾¾å‡ºå£
            checkPlayerAtExit(currentPlayer);
            return; // ä¼ é€é€»è¾‘ç»“æŸ
        }
    }

    // 4.4 é’¥åŒ™
    if (cellValue === 8) {
        // æ£€æŸ¥ç©å®¶æ˜¯å¦å—ä¿æŠ¤ï¼Œé˜²æ­¢å…¶ä»–ç©å®¶å·é’¥åŒ™
        if (gameState.multiplayer.protectedPlayers[currentPlayer.id]) {
            console.log('ç©å®¶å—ä¿æŠ¤ï¼Œå…¶ä»–ç©å®¶æ— æ³•æ¡é’¥åŒ™');
        } else {
            currentPlayer.hasKey = true;
            gameState.multiplayer.maze[newY][newX] = 0; // ç§»é™¤é’¥åŒ™
            delete gameState.multiplayer.keyPosition;

            // å¹¿æ’­é’¥åŒ™æ‹¾å–äº‹ä»¶
            broadcast({
                type: 'key-pickup',
                playerId: currentPlayer.id
            });
            console.log('æ‹¿åˆ°é’¥åŒ™!');
        }
    }

    // 4.5 é—¨
    if (cellValue === 9) {
        if (currentPlayer.hasKey) {
            startMultiplayerUnlockDoor();
            return; // å¼€é—¨å€’è®¡æ—¶å¼€å§‹ï¼Œæœ¬æ¬¡ç§»åŠ¨ç»“æŸ
        } else {
            alert("ä½ éœ€è¦é’¥åŒ™æ‰èƒ½æ‰“å¼€è¿™æ‰‡é—¨ï¼");
            return; // æ²¡æœ‰é’¥åŒ™ï¼Œå¼€é—¨å¤±è´¥ï¼Œæœ¬æ¬¡ç§»åŠ¨ç»“æŸ
        }
    }

    // 5. æ‰§è¡Œæ ‡å‡†ç§»åŠ¨
    // --------------------------------------------------
    // å¦‚æœé€šè¿‡äº†æ‰€æœ‰æ£€æŸ¥ï¼Œè¯´æ˜æ˜¯æœ‰æ•ˆçš„æ™®é€šç§»åŠ¨
    currentPlayer.x = newX;
    currentPlayer.y = newY;
    
    gameState.multiplayer.moveCount++;
    document.getElementById('multiplayerMoveCount').textContent = `ç§»åŠ¨: ${gameState.multiplayer.moveCount}`;
    
    // å¹¿æ’­ç§»åŠ¨
    broadcast({
        type: 'player-move',
        playerId: currentPlayer.id,
        x: currentPlayer.x,
        y: currentPlayer.y
    });
    
    console.log('ç§»åŠ¨!');

    // 6. ç»˜åˆ¶UIå’Œæ£€æŸ¥å‡ºå£
    drawMultiplayerMaze();
    updatePlayerList();
    
    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å‡ºå£
    checkPlayerAtExit(currentPlayer);
}

/**
 * æ£€æŸ¥ç‰¹å®šç©å®¶æ˜¯å¦åˆ°è¾¾äº†å‡ºå£ï¼Œå¹¶è§¦å‘ç›¸åº”é€»è¾‘ã€‚
 * @param {object} player - è¦æ£€æŸ¥çš„ç©å®¶å¯¹è±¡
 */
function checkPlayerAtExit(player) {
    const exit = gameState.multiplayer.exit;
    if (player.x === exit.x && player.y === exit.y) {
        // ç©å®¶åˆ°è¾¾å‡ºå£
        player.reachedExit = true;
        console.log(`${player.name} åˆ°è¾¾äº†å‡ºå£ï¼`);

        // å¹¿æ’­åˆ°è¾¾å‡ºå£äº‹ä»¶
        broadcast({
            type: 'player-reached-exit',
            playerId: player.id
        });

        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰äººéƒ½åˆ°äº†
        checkAllPlayersReachedExit();
    }
}

        function initMultiplayerCanvas() {
            const canvas = document.getElementById('multiplayerCanvas');
            const ctx = canvas.getContext('2d');
            
            // è°ƒæ•´ç”»å¸ƒå¤§å°
            console.log("åˆå§‹åŒ–ç”»å¸ƒ")
            const maxWidth = window.innerWidth - 40;
            const maxHeight = window.innerHeight - 180;
            
            // ç¡®ä¿è¿·å®«å·²åˆå§‹åŒ–
            if (!gameState.multiplayer.maze || gameState.multiplayer.maze.length === 0) {
                console.error("å¤šäººæ¸¸æˆè¿·å®«æœªåˆå§‹åŒ–");
                canvas.width = 300;
                canvas.height = 300;
                return;
            }
            
            const mazeWidth = gameState.multiplayer.maze[0].length;
            const mazeHeight = gameState.multiplayer.maze.length;
            
            const cellSize = Math.min(30, Math.floor(maxWidth / mazeWidth), 
                                     Math.floor(maxHeight / mazeHeight));
            
            canvas.width = mazeWidth * cellSize;
            canvas.height = mazeHeight * cellSize;
            
            // ä¿å­˜å•å…ƒæ ¼å¤§å°ä¾›åç»­ä½¿ç”¨
            gameState.multiplayer.cellSize = cellSize;
            
            // ç»˜åˆ¶åˆå§‹è¿·å®«
            drawMultiplayerMaze();
            
            // æ›´æ–°ç©å®¶åˆ—è¡¨
            updatePlayerList();
            
            // æ·»åŠ é”®ç›˜äº‹ä»¶ç›‘å¬
            window.addEventListener('keydown', handleMultiplayerKeyDown);
        }

        function handleMultiplayerKeyDown(e) {
            if (!gameState.multiplayer.connected) return;
            
            e.preventDefault();
            const player = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
            if (!player || player.reachedExit) return;
            
            let newX = player.x;
            let newY = player.y;
            
            switch(e.key) {
                case 'ArrowUp': newY--; break;
                case 'ArrowDown': newY++; break;
                case 'ArrowLeft': newX--; break;
                case 'ArrowRight': newX++; break;
                default: return;
            }
            
            // æ£€æŸ¥ç§»åŠ¨æ˜¯å¦æœ‰æ•ˆ
            if (newX >= 0 && newX < gameState.multiplayer.maze[0].length && 
                newY >= 0 && newY < gameState.multiplayer.maze.length) {
                
                const cellValue = gameState.multiplayer.maze[newY][newX];
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯å¢™
                if (cellValue === 1) return;
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯é™·é˜±
                if (cellValue === 2) {
                    // æ£€æŸ¥ç©å®¶æ˜¯å¦å—ä¿æŠ¤ï¼ˆæ— æ•ŒçŠ¶æ€ï¼‰
                    if (gameState.multiplayer.protectedPlayers[gameState.multiplayer.currentPlayerId]) {
                        // æ— æ•ŒçŠ¶æ€ï¼Œå¿½ç•¥é™·é˜±
                        console.log('æ— æ•ŒçŠ¶æ€ï¼Œå¿½ç•¥é™·é˜±');
                    } else {
                        // å›åˆ°èµ·ç‚¹
                        player.x = 1;
                        player.y = 1;
                        gameState.multiplayer.moveCount++;
                        document.getElementById('multiplayerMoveCount').textContent = 
                            `ç§»åŠ¨: ${gameState.multiplayer.moveCount}`;
                        
                        // å¹¿æ’­ç§»åŠ¨
                        broadcast({
                            type: 'player-move',
                            playerId: gameState.multiplayer.currentPlayerId,
                            x: player.x,
                            y: player.y
                        });
                        
                        drawMultiplayerMaze();
                        
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯ä¼ é€é—¨
                if (cellValue === 3) {
                    // æ‰¾åˆ°é…å¯¹çš„ä¼ é€é—¨
                    const teleporter = gameState.multiplayer.teleporters.find(t => 
                        t.x === newX && t.y === newY);
                    
                    if (teleporter) {
                        // å¦‚æœæ˜¯ä¸»æœºï¼Œç›´æ¥å¤„ç†ä¼ é€
                        if (gameState.multiplayer.isHost) {
                            newX = teleporter.pairX;
                            newY = teleporter.pairY;
                            
                            player.x = newX;
                            player.y = newY;
                            
                            // å¹¿æ’­ä¼ é€
                            broadcast({
                                type: 'player-teleport',
                                playerId: gameState.multiplayer.currentPlayerId,
                                x: newX,
                                y: newY
                            });
                            drawMultiplayerMaze();
                        } else {
                            // å¦‚æœæ˜¯å®¢æˆ·ç«¯ï¼Œå‘ä¸»æœºå‘é€ä¼ é€è¯·æ±‚
                            const conn = Object.values(gameState.multiplayer.connections)[0];
                            if (conn) {
                                conn.send({
                                    type: 'teleport-request',
                                    playerId: gameState.multiplayer.currentPlayerId,
                                    teleporterX: newX,
                                    teleporterY: newY
                                });
                            }
                            return; // ç­‰å¾…ä¸»æœºå¤„ç†
                            drawMultiplayerMaze();
                        }
                    }
                } else {
                    // æ™®é€šç§»åŠ¨
                    player.x = newX;
                    player.y = newY;
                }
                
                gameState.multiplayer.moveCount++;
                document.getElementById('multiplayerMoveCount').textContent = 
                    `ç§»åŠ¨: ${gameState.multiplayer.moveCount}`;
                
                // å¹¿æ’­ç§»åŠ¨
                broadcast({
                    type: 'player-move',
                    playerId: gameState.multiplayer.currentPlayerId,
                    x: player.x,
                    y: player.y
                });
                drawMultiplayerMaze();
                // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å‡ºå£
                if (player.x === gameState.multiplayer.exit.x && player.y === gameState.multiplayer.exit.y) {
                    player.reachedExit = true;
                    
                    // å¹¿æ’­åˆ°è¾¾å‡ºå£
                    broadcast({
                        type: 'player-reached-exit',
                        playerId: gameState.multiplayer.currentPlayerId
                    });
                    
                    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½åˆ°è¾¾å‡ºå£
                    checkAllPlayersReachedExit();
                }
                drawMultiplayerMaze();
                if (cellValue === 8) {
                    gameState.multiplayer.hasKey = true;
                    // ç§»é™¤é’¥åŒ™
                    gameState.multiplayer.maze[newY][newX] = 0;
                    delete gameState.multiplayer.keyPosition;
                    
                    // å¹¿æ’­é’¥åŒ™æ‹¾å–
                    broadcast({
                        type: 'key-pickup',
                        playerId: gameState.multiplayer.currentPlayerId
                    });
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯é—¨
                if (cellValue === 9) {
                        if (gameState.multiplayer.hasKey) {
                            // å¼€å§‹å¼€é—¨å€’è®¡æ—¶
                            startMultiplayerUnlockDoor();
                            
                        } else {
                            // æ²¡æœ‰é’¥åŒ™ï¼Œä¸èƒ½é€šè¿‡
                            alert("ä½ éœ€è¦é’¥åŒ™æ‰èƒ½æ‰“å¼€è¿™æ‰‡é—¨ï¼");
                            
                        }
                drawMultiplayerMaze();
                updatePlayerList();
            }
        }
    }
function startUnlockDoor() {
    // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„æ—§å®šæ—¶å™¨
    clearInterval(singlePlayerGame.unlockTimer);
    
    singlePlayerGame.isUnlocking = true;
    singlePlayerGame.unlockTimeLeft = 10;
    document.getElementById('unlockTimer').classList.remove('hidden');
    updateUnlockTimer();
    
    singlePlayerGame.unlockTimer = setInterval(() => {
        singlePlayerGame.unlockTimeLeft--;
        updateUnlockTimer();
        
        if (singlePlayerGame.unlockTimeLeft <= 0) {
            clearInterval(singlePlayerGame.unlockTimer);
            // å¼€é—¨æˆåŠŸ
            singlePlayerGame.maze[singlePlayerGame.doorPosition.y][singlePlayerGame.doorPosition.x] = 0;
            document.getElementById('unlockTimer').classList.add('hidden');
            singlePlayerGame.isUnlocking = false;
            
            drawSinglePlayerMaze();
            alert("é—¨å·²æ‰“å¼€ï¼ç°åœ¨ä½ å¯ä»¥è¿›å…¥å‡ºå£äº†ã€‚");
        }
    }, 1000);
}


function startMultiplayerUnlockDoor() {
    // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„æ—§å®šæ—¶å™¨
    clearInterval(gameState.multiplayer.unlockTimer);
    
    gameState.multiplayer.isUnlocking = true;
    gameState.multiplayer.unlockTimeLeft = 10;
    document.getElementById('unlockTimer').classList.remove('hidden');
    updateMultiplayerUnlockTimer();
    
    gameState.multiplayer.unlockTimer = setInterval(() => {
        gameState.multiplayer.unlockTimeLeft--;
        updateMultiplayerUnlockTimer();
        
        if (gameState.multiplayer.unlockTimeLeft <= 0) {
            clearInterval(gameState.multiplayer.unlockTimer);
            // å¼€é—¨æˆåŠŸ
            gameState.multiplayer.maze[
                gameState.multiplayer.doorPosition.y][
                gameState.multiplayer.doorPosition.x] = 0;
            document.getElementById('unlockTimer').classList.add('hidden');
            gameState.multiplayer.isUnlocking = false;
            
            // å¦‚æœæ˜¯ä¸»æœºï¼Œå¹¿æ’­å¼€é—¨
            if (gameState.multiplayer.isHost) {
                broadcast({
                    type: 'door-open',
                    x: gameState.multiplayer.doorPosition.x,
                    y: gameState.multiplayer.doorPosition.y
                });
            }
            
            drawMultiplayerMaze();
            alert("é—¨å·²æ‰“å¼€ï¼");
        }
    }, 1000);
}

function updateUnlockTimer() {
    document.getElementById('unlockTimer').textContent = 
        `å¼€é—¨å€’è®¡æ—¶: ${singlePlayerGame.unlockTimeLeft}ç§’`;
}

function checkAllPlayersReachedExit() {
    const allReached = Object.values(gameState.multiplayer.players).every(p => p.reachedExit);
    if (allReached) {
        alert('æ‰€æœ‰ç©å®¶éƒ½åˆ°è¾¾äº†å‡ºå£ï¼æ¸¸æˆèƒœåˆ©ï¼');
        
        // è®°å½•å¤šäººæ¸¸æˆæˆå°±
        recordAchievement('multiplayerWin', 1);
    }
}

// åˆå§‹åŒ–å‡½æ•°
function initializeNewFeatures() {
    updateAchievementProgress();
    
    // æ›´æ–°æŒ‘æˆ˜ç•Œé¢æ•°æ®
    document.getElementById('timeChallengeBest').textContent = 
        gameState.gameStats.timeChallengeBest > 0 ? 
        gameState.gameStats.timeChallengeBest + 'ç§’' : 'æš‚æ— ';
    
    document.getElementById('puzzleCompleted').textContent = 
        gameState.gameStats.puzzleLevelsCompleted + '/10';
    
    
}
// åœ¨é¡µé¢åŠ è½½æ—¶è°ƒç”¨
window.addEventListener('load', initializeNewFeatures);

        function disconnectMultiplayer() {
            if (gameState.multiplayer.peer) {
                gameState.multiplayer.peer.destroy();
            }
            
            gameState.multiplayer.connected = false;
            gameState.multiplayer.connections = {};
            gameState.multiplayer.players = {};
            gameState.multiplayer.protectedPlayers = {};
            clearInterval(gameState.multiplayer.timerInterval);
            window.removeEventListener('keydown', handleMultiplayerKeyDown);
            showScreen('mainMenu');
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            
            switch(status) {
                case 'connecting':
                    statusElement.textContent = 'è¿æ¥ä¸­...';
                    statusElement.className = 'connection-status disconnected';
                    break;
                case 'connected':
                    statusElement.textContent = 'å·²è¿æ¥ å¤šäººè”æœºæµ‹è¯•';
                    statusElement.className = 'connection-status connected';
                    break;
                case 'disconnected':
                    statusElement.textContent = 'æ–­å¼€è¿æ¥ å¤šäººè”æœºæµ‹è¯•';
                    statusElement.className = 'connection-status disconnected';
                    break;
            }
        }

        function updatePlayerList() {
            const container = document.getElementById('playersContainer');
            container.innerHTML = '';
            
            for (const playerId in gameState.multiplayer.players) {
                const player = gameState.multiplayer.players[playerId];
                const div = document.createElement('div');
                div.className = 'player-item';
                
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                playerInfo.innerHTML = `
                    <div class="player-color" style="background-color:${player.color}"></div>
                    ${player.name} ${player.reachedExit ? 'âœ“' : ''}
                    ${gameState.multiplayer.protectedPlayers[playerId] ? 'ğŸ›¡ï¸' : ''}
                `;
                
                div.appendChild(playerInfo);
                
                // å¦‚æœæ˜¯æˆ¿ä¸»ä¸”ä¸æ˜¯è‡ªå·±ï¼Œæ˜¾ç¤ºè¸¢å‡ºæŒ‰é’®
                if (gameState.multiplayer.isHost && 
                    gameState.multiplayer.currentPlayerId !== playerId) {
                    const kickButton = document.createElement('button');
                    kickButton.className = 'kick-button';
                    kickButton.textContent = 'è¸¢å‡º';
                    kickButton.onclick = () => {
                        if (confirm(`ç¡®å®šè¦è¸¢å‡ºç©å®¶ ${player.name} å—ï¼Ÿ`)) {
                            // æ£€æŸ¥ç©å®¶æ˜¯å¦å—ä¿æŠ¤
                            if (gameState.multiplayer.protectedPlayers[playerId]) {
                                alert('è¸¢å‡ºå¤±è´¥ï¼šerr75937 (ç©å®¶å—ä¿æŠ¤)');
                            } else {
                                kickPlayer(playerId, 'è¢«ç®¡ç†å‘˜è¸¢å‡º');
                            }
                        }
                    };
                    div.appendChild(kickButton);
                }
                
                container.appendChild(div);
            }
            
            updatePlayerCount();
        }

        function updatePlayerCount() {
            const currentPlayers = Object.keys(gameState.multiplayer.players).length;
            const maxPlayers = gameState.multiplayer.maxPlayers;
            document.getElementById('multiplayerPlayerCount').textContent = 
                `ç©å®¶: ${currentPlayers}/${maxPlayers}`;
        }

function kickPlayer(playerId, reason) {
    // æ£€æŸ¥æ˜¯å¦æ˜¯æˆ¿ä¸»ä¸”ä¸æ˜¯å¼ºåˆ¶è¸¢å‡º
    const isHost = gameState.multiplayer.players[playerId]?.isHost;
    if (isHost && !reason.includes('(å¼ºåˆ¶)')) {
        output.innerHTML += '\né”™è¯¯: ä¸èƒ½è¸¢å‡ºæˆ¿ä¸»(é™¤éä½¿ç”¨forceå‚æ•°)';
        return;
    }
    
    // å‘é€è¸¢å‡ºæ¶ˆæ¯ç»™è¯¥ç©å®¶
    if (gameState.multiplayer.connections[playerId]) {
        gameState.multiplayer.connections[playerId].send({
            type: 'player-kicked',
            playerId: playerId,
            reason: reason
        });
        gameState.multiplayer.connections[playerId].close();
    }
    
    // å¹¿æ’­ç»™å…¶ä»–ç©å®¶
    broadcast({
        type: 'player-kicked',
        playerId: playerId,
        reason: reason
    });
    
    // ä»åˆ—è¡¨ä¸­ç§»é™¤
    removePlayer(playerId);
}


        function resetMultiplayerPlayer() {
            const player = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
            if (player) {
                player.x = 1;
                player.y = 1;
                player.reachedExit = false;
                
                // å¹¿æ’­ç§»åŠ¨
                broadcast({
                    type: 'player-move',
                    playerId: gameState.multiplayer.currentPlayerId,
                    x: player.x,
                    y: player.y
                });
                
                drawMultiplayerMaze();
                updatePlayerList();
            }
        }
function addKeyAndDoormultiplayer(size, maze) {
    // éšæœºæ”¾ç½®é’¥åŒ™
    let keyX, keyY;
    do {
        keyX = Math.floor(Math.random() * (size - 4)) + 2;
        keyY = Math.floor(Math.random() * (size - 4)) + 2;
    } while (maze[keyY][keyX] === 1 || 
             (keyX === 1 && keyY === size - 2) || 
             (keyX === Math.floor(size/2) && keyY === Math.floor(size/2)));
    
    // æ”¾ç½®é’¥åŒ™(8)
    maze[keyY][keyX] = 8;
    gameState.multiplayer.keyPosition = {x: keyX, y: keyY};
    
    // åœ¨å‡ºå£å‰æ”¾ç½®é—¨(9)
    let doorX = gameState.multiplayer.exit.x;
    let doorY = gameState.multiplayer.exit.y;
    
    // ç¡®å®šé—¨çš„ä½ç½®
    if (doorX < size-1 && maze[doorY][doorX+1] === 0) {
        doorX++;
    } else if (doorX > 0 && maze[doorY][doorX-1] === 0) {
        doorX--;
    } else if (doorY < size-1 && maze[doorY+1][doorX] === 0) {
        doorY++;
    } else if (doorY > 0 && maze[doorY-1][doorX] === 0) {
        doorY--;
    }
    
    maze[doorY][doorX] = 9;
    gameState.multiplayer.doorPosition = {x: doorX, y: doorY};
}

function generateMultiplayerMaze() {
    const size = 15;
    let maze;
    let validMaze = false;
    let attempts = 0;
    
    // 10%æ¦‚ç‡ç”Ÿæˆèºæ—‹è¿·å®«(åº”æ•Œäººæ— æ³•æ¸²æŸ“ï¼Œæš‚æ—¶å…³é—­)
    const isSpiralMaze = false;
    // const isSpiralMaze = Math.random() < 0.1;
    // %100ç”Ÿæˆ
    // const isSpiralMaze = true;
    if (isSpiralMaze) {
        maze = generateSpiralMaze(size);
        gameState.multiplayer.exit = { 
            x: Math.floor(size/2), 
            y: Math.floor(size/2) 
        };
        
        // æ·»åŠ ç§»åŠ¨æ•Œäºº
        gameState.multiplayer.movingEnemies = [];
        for (let i = 0; i < 3; i++) {
            gameState.multiplayer.movingEnemies.push({
                x: Math.floor(Math.random() * (size-4)) + 2,
                y: Math.floor(Math.random() * (size-4)) + 2,
                dx: Math.random() > 0.5 ? 1 : -1,
                dy: Math.random() > 0.5 ? 1 : -1,
                speed: 0.3 + Math.random() * 0.4,
                color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                lastMove: 0
            });
        }
        
        // æ·»åŠ é’¥åŒ™å’Œé—¨
        addKeyAndDoormultiplayer(size, maze);
    } else {
        // æ™®é€šè¿·å®«
        while (!validMaze && attempts < 5) {
            maze = Array(size).fill().map(() => Array(size).fill(1));
            validMaze = tryGenerateValidMaze(maze, size);
            attempts++;
        }
        
        if (!validMaze) {
            maze = generateBackupMaze(size);
        }
        
        // è®¾ç½®å‡ºå£
        maze[size-2][size-1] = 0;
        gameState.multiplayer.exit = {x: size-1, y: size-2};
    }
    
    // æ·»åŠ ä¼ é€é—¨
    addMultiplayerTeleporters(maze, size);
    
    return maze;
}

function tryGenerateValidMaze(maze, size) {
    // ä½¿ç”¨éšæœºPrimç®—æ³•ç”Ÿæˆè¿·å®«
    const walls = [];
    maze[1][1] = 0;
    walls.push(...getCellWalls(1, 1, maze));
    
    while (walls.length > 0) {
        const wallIndex = Math.floor(Math.random() * walls.length);
        const wall = walls[wallIndex];
        walls.splice(wallIndex, 1);
        
        const opposite = getOppositeCell(wall, maze);
        
        if (opposite.x > 0 && opposite.x < size-1 && 
            opposite.y > 0 && opposite.y < size-1 && 
            maze[opposite.y][opposite.x] === 1) {
            
            maze[wall.y][wall.x] = 0;
            maze[opposite.y][opposite.x] = 0;
            walls.push(...getCellWalls(opposite.x, opposite.y, maze));
        }
    }
    
    // ç¡®ä¿æœ‰ä¸€æ¡ä»èµ·ç‚¹(1,1)åˆ°ç»ˆç‚¹(size-2, size-1)çš„è·¯å¾„
    return validateMaze(maze);
}

function addMultiplayerTraps(maze, size) {
    // æ·»åŠ é™·é˜±ï¼ˆé¿å¼€å…³é”®è·¯å¾„ï¼‰
    const criticalPath = findCriticalPath(maze);
    for (let i = 0; i < 5; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(Math.random() * (size-2)) + 1;
            y = Math.floor(Math.random() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || 
                  criticalPath.some(p => p.x === x && p.y === y) || 
                  (x === 1 && y === 1)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y][x] = 2;
        }
    }
}

function addMultiplayerTeleporters(maze, size) {
    gameState.multiplayer.teleporters = [];
    for (let i = 0; i < 2; i++) {
        let x1, y1, x2, y2;
        let attempts = 0;
        do {
            x1 = Math.floor(Math.random() * (size-2)) + 1;
            y1 = Math.floor(Math.random() * (size-2)) + 1;
            x2 = Math.floor(Math.random() * (size-2)) + 1;
            y2 = Math.floor(Math.random() * (size-2)) + 1;
            attempts++;
        } while ((maze[y1][x1] !== 0 || maze[y2][x2] !== 0 || 
                 (x1 === 1 && y1 === 1) || (x2 === 1 && y2 === 1)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y1][x1] = 3;
            maze[y2][x2] = 3;
            gameState.multiplayer.teleporters.push({x: x1, y: y1, pairX: x2, pairY: y2});
            gameState.multiplayer.teleporters.push({x: x2, y: y2, pairX: x1, pairY: y1});
        }
    }
}



function getOppositeCell(wall, maze) {
    const directions = [
        {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
        {dx: 0, dy: 1}, {dx: 0, dy: -1}
    ];
    
    for (const dir of directions) {
        const nx = wall.x + dir.dx;
        const ny = wall.y + dir.dy;
        
        if (nx >= 0 && nx < maze[0].length && 
            ny >= 0 && ny < maze.length && 
            maze[ny][nx] === 0) {
            return {x: wall.x - dir.dx, y: wall.y - dir.dy};
        }
    }
    
    return {x: -1, y: -1};
}

            // è¾…åŠ©å‡½æ•°
            function getCellWalls(x, y, maze) {
                const walls = [];
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    
                    if (nx >= 0 && nx < maze[0].length && 
                        ny >= 0 && ny < maze.length && 
                        maze[ny][nx] === 1) {
                        walls.push({x: nx, y: ny});
                    }
                }
                
                return walls;
            }
            
            function getOppositeCell(wall, maze) {
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = wall.x + dir.dx;
                    const ny = wall.y + dir.dy;
                    
                    if (nx >= 0 && nx < maze[0].length && 
                        ny >= 0 && ny < maze.length && 
                        maze[ny][nx] === 0) {
                        return {x: wall.x - dir.dx, y: wall.y - dir.dy};
                    }
                }
                
                return {x: -1, y: -1};
            }
        

        function drawMultiplayerMaze() {
            const canvas = document.getElementById('multiplayerCanvas');
            const ctx = canvas.getContext('2d');
            const cellSize = gameState.multiplayer.cellSize;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶è¿·å®«
            for (let y = 0; y < gameState.multiplayer.maze.length; y++) {
                for (let x = 0; x < gameState.multiplayer.maze[y].length; x++) {
                    const cellValue = gameState.multiplayer.maze[y][x];
                    
                    switch(cellValue) {
                        case 1: // å¢™
                            ctx.fillStyle = '#333';
                            break;
                        case 2: // é™·é˜±
                            ctx.fillStyle = '#FF0';
                            break;
                        case 3: // ä¼ é€é—¨
                            ctx.fillStyle = '#0FF';
                            break;
                        default: // è·¯
                            ctx.fillStyle = '#111';
                    }
                    
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    
                    // ç»˜åˆ¶é™·é˜±å›¾æ¡ˆ
                    if (cellValue === 2) {
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            x * cellSize + cellSize/2,
                            y * cellSize + cellSize/2,
                            cellSize/4,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                       if (gameState.multiplayer.keyPosition) {
                            ctx.fillStyle = 'gold';
                            ctx.fillRect(
                                gameState.multiplayer.keyPosition.x * cellSize,
                                gameState.multiplayer.keyPosition.y * cellSize,
                                cellSize, cellSize
                            );
                        }
                        
                        // ç»˜åˆ¶é—¨
                        if (gameState.multiplayer.doorPosition) {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(
                                gameState.multiplayer.doorPosition.x * cellSize,
                                gameState.multiplayer.doorPosition.y * cellSize,
                                cellSize, cellSize
                            );
                        }
                        
                        // ç»˜åˆ¶ç§»åŠ¨æ•Œäººï¼ˆå¦‚æœæ˜¯èºæ—‹è¿·å®«ï¼‰
                        if (gameState.multiplayer.movingEnemies) {
                            gameState.multiplayer.movingEnemies.forEach(enemy => {
                                ctx.fillStyle = enemy.color;
                                ctx.beginPath();
                                ctx.arc(
                                    enemy.x * cellSize + cellSize/2,
                                    enemy.y * cellSize + cellSize/2,
                                    cellSize/2 - 2,
                                    0,
                                    Math.PI * 2
                                );
                                ctx.fill();
                                
                                // ç»˜åˆ¶æ•Œäººçœ¼ç›
                                ctx.fillStyle = '#FFF';
                                ctx.beginPath();
                                ctx.arc(
                                    enemy.x * cellSize + cellSize/3,
                                    enemy.y * cellSize + cellSize/3,
                                    cellSize/8,
                                    0,
                                    Math.PI * 2
                                );
                                ctx.fill();
                            });
                        }
                }
            
                
            
            
            // ç»˜åˆ¶å‡ºå£
            ctx.fillStyle = '#F00';
            ctx.fillRect(gameState.multiplayer.exit.x * cellSize, 
                        gameState.multiplayer.exit.y * cellSize, 
                        cellSize, cellSize);
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold ' + (cellSize/2) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('å‡º', 
                gameState.multiplayer.exit.x * cellSize + cellSize/2,
                gameState.multiplayer.exit.y * cellSize + cellSize/2
            );
            
            // ç»˜åˆ¶æ‰€æœ‰ç©å®¶
            for (const playerId in gameState.multiplayer.players) {
                const player = gameState.multiplayer.players[playerId];
                
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(
                    player.x * cellSize + cellSize/2,
                    player.y * cellSize + cellSize/2,
                    cellSize/2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // ç»˜åˆ¶ç©å®¶åå­—
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold ' + (cellSize/4) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(player.name.charAt(0), 
                    player.x * cellSize + cellSize/2,
                    player.y * cellSize + cellSize/2
                );
            }
        }
    }
function updateMultiplayerGame() {
    // ç§»åŠ¨æ•Œäºº
    const now = Date.now();
    const size = gameState.multiplayer.maze.length; // è·å–è¿·å®«å¤§å°
    
    if (gameState.multiplayer.movingEnemies) {
        gameState.multiplayer.movingEnemies.forEach(enemy => {
            // æ ¹æ®æ—¶é—´é—´éš”ç§»åŠ¨
            if (now - enemy.lastMove < 500 / enemy.speed) return;
            enemy.lastMove = now;
            
            // è¿½é€æœ€è¿‘çš„ç©å®¶
            let closestPlayer = null;
            let minDistance = Infinity;
            
            for (const playerId in gameState.multiplayer.players) {
                const player = gameState.multiplayer.players[playerId];
                const distance = Math.sqrt(
                    Math.pow(player.x - enemy.x, 2) + 
                    Math.pow(player.y - enemy.y, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPlayer = player;
                }
            }
            
            if (closestPlayer) {
                // è®¡ç®—ç§»åŠ¨æ–¹å‘
                enemy.dx = closestPlayer.x - enemy.x > 0 ? 1 : -1;
                enemy.dy = closestPlayer.y - enemy.y > 0 ? 1 : -1;
                
                // å°è¯•ç§»åŠ¨
                let newX = enemy.x + enemy.dx;
                let newY = enemy.y + enemy.dy;
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç§»åŠ¨
                if (newX >= 0 && newX < size && newY >= 0 && newY < size && 
                    gameState.multiplayer.maze[newY][newX] !== 1) {
                    enemy.x = newX;
                    enemy.y = newY;
                    
                    // æ£€æŸ¥æ˜¯å¦ç¢°åˆ°ç©å®¶
                    for (const playerId in gameState.multiplayer.players) {
                        const player = gameState.multiplayer.players[playerId];
                        
                        if (enemy.x === player.x && enemy.y === player.y && 
                            !gameState.multiplayer.protectedPlayers[playerId]) {
                            // ç©å®¶è¢«é€å›èµ·ç‚¹
                            player.x = 1;
                            player.y = 1;
                            
                            // å¹¿æ’­ç§»åŠ¨
                            broadcast({
                                type: 'player-move',
                                playerId: playerId,
                                x: player.x,
                                y: player.y
                            });
                        }
                    }
                }
            }
        });
        
        // å¹¿æ’­æ•Œäººç§»åŠ¨
        broadcast({
            type: 'enemy-move',
            enemies: gameState.multiplayer.movingEnemies
        });
        
        drawMultiplayerMaze();
    }
}

        function updateMultiplayerUnlockTimer() {
            document.getElementById('unlockTimer').textContent = 
                `å¼€é—¨å€’è®¡æ—¶: ${gameState.multiplayer.unlockTimeLeft}ç§’`;
        }

        function startMultiplayerTimer() {
            clearInterval(gameState.multiplayer.timerInterval);
            gameState.multiplayer.startTime = Date.now();
            updateMultiplayerUnlockTimer();
            gameState.multiplayer.timerInterval = setInterval(updateMultiplayerUnlockTimer, 1000);
        }



        function getRandomColor() {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'];
            return colors[Math.floor(Math.random() * colors.length)];
        }




        // =============== é”®ç›˜å¿«æ·é”® ===============
        document.addEventListener('keydown', function(e) {
            // Ctrl+Shift+C æ‰“å¼€/å…³é—­æ§åˆ¶å°
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                toggleConsole();
            }
            
            // Ctrl+Shift+D åˆ‡æ¢å¼€å‘è€…æ¨¡å¼
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                e.preventDefault();
                gameState.devMode = !gameState.devMode;
                console.log('å¼€å‘è€…æ¨¡å¼:', gameState.devMode ? 'å¼€å¯' : 'å…³é—­');
                
                // æ˜¾ç¤ºæç¤º
                const hint = document.createElement('div');
                hint.className = 'console-hint';
                hint.textContent = `å¼€å‘è€…æ¨¡å¼ ${gameState.devMode ? 'å¼€å¯' : 'å…³é—­'}`;
                document.body.appendChild(hint);
                
                setTimeout(() => {
                    hint.classList.add('hidden');
                    setTimeout(() => hint.remove(), 500);
                }, 2000);
            }
            
            // æ§åˆ¶å°è¾“å…¥å¤„ç†
            if (consoleVisible && e.key === 'Enter') {
                const input = document.getElementById('consoleInput');
                const command = input.value.trim();
                input.value = '';
                    
                if (command) {
                    consoleHistory.push(command);
                    historyIndex = consoleHistory.length;
                    executeCommand(command);
                }
            }
        });

        // æ§åˆ¶å°è¾“å…¥æ¡†äº‹ä»¶å¤„ç†
        document.getElementById('consoleInput').addEventListener('keydown', handleConsoleInput);

        // åˆå§‹åŒ–å…³å¡æŒ‰é’®
        generateLevelButtons();
        
        // æ›´æ–°ä¸‹ä¸€å…³æŒ‰é’®æ˜¾ç¤º
function updateNextLevelButtons() {
    const regularBtn = document.getElementById('regularNextButton');
    const unsolvableBtn = document.getElementById('unsolvableNextButton');
    
    // ç¡®ä¿åœ¨ä»»ä½•æ—¶å€™è°ƒç”¨è¿™ä¸ªå‡½æ•°éƒ½èƒ½æ­£ç¡®è®¾ç½®æŒ‰é’®çŠ¶æ€
    if (gameState.unsolvableLevels.includes(gameState.currentLevel)) {
        regularBtn.style.display = 'none';
        unsolvableBtn.style.display = 'block'; // æ”¹ä¸ºblockä»¥ç¡®ä¿æ˜¾ç¤º
    } else {
        regularBtn.style.display = 'block'; // æ”¹ä¸ºblockä»¥ç¡®ä¿æ˜¾ç¤º
        unsolvableBtn.style.display = 'none';
    }
}

        // åˆå§‹åº”ç”¨UIè®¾ç½®
        applyUISettings();
document.addEventListener('touchstart', function(e) {
    // æ£€æŸ¥ç‚¹å‡»çš„æ˜¯å¦æ˜¯ç›®æ ‡æŒ‰é’®
    if (e.target.id === 'multiplayerBtn' || e.target.parentElement.id === 'multiplayerBtn') {
        e.preventDefault();
        showScreen('multiplayerSetup');
    }
    
    if (e.target.id === 'startMultiplayerBtn' || e.target.parentElement.id === 'startMultiplayerBtn') {
        e.preventDefault();
        connectToMultiplayerGame();
    }
    
    if (e.target.id === 'backToMenuBtn' || e.target.parentElement.id === 'backToMenuBtn') {
        e.preventDefault();
        showScreen('mainMenu');
    }
}, { passive: false });


    </script>
</body>
</html>
