<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.1/socket.io.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>迷宫冒险 - 1.13.7</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            overflow: auto;
            min-height: 100vh;
        }
        
        /* 主菜单样式 */
        .main-menu {
            text-align: center;
            margin-top: 50px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            padding-bottom: 20px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .menu-title {
            font-size: 48px;
            margin-bottom: 30px;
            color: #4CAF50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
            letter-spacing: 3px;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .menu-button, .menu-btn {
            display: block;
            width: 250px;
            margin: 15px auto;
            padding: 14px;
            font-size: 18px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .menu-btn.highlight {
            background: linear-gradient(135deg, #FF9800, #F57C00);
            box-shadow: 0 5px 15px rgba(255, 152, 0, 0.4);
        }
        
        .badge {
            background-color: #FF5252;
            color: white;
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 12px;
            margin-left: 5px;
        }
        
        .menu-button:hover, .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            background: linear-gradient(135deg, #66BB6A, #388E3C);
        }
        
        .menu-btn.highlight:hover {
            background: linear-gradient(135deg, #FFA726, #FF8F00);
        }
        
        /* 关卡选择样式 */
        .level-select {
            text-align: center;
            margin-top: 20px;
            animation: slideIn 0.8s ease-out;
            position: relative;
            padding-top: 80px;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-50px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
.level-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 700px;
    margin: 30px auto;
    margin-top: 60px;
    max-height: calc(100vh - 200px);
    overflow-y: auto;
    padding: 20px;
    box-sizing: border-box;
    -webkit-overflow-scrolling: touch; /* iOS滑动流畅 */
    touch-action: pan-y; /* 优化触控行为 */
    overscroll-behavior: contain; /* 防止滚动传播到外层 */
}
        
        .level-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .level-container::-webkit-scrollbar-thumb {
            background: rgba(76, 175, 80, 0.5);
            border-radius: 4px;
        }
        
        .level-container::-webkit-scrollbar-thumb:hover {
            background: rgba(76, 175, 80, 0.8);
        }
        
        .level-button {
            width: 60px;
            height: 60px;
            margin: 12px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .level-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }
        
        .level-button.locked {
            background: linear-gradient(135deg, #555, #333);
            cursor: not-allowed;
        }
        
        .level-button.completed {
            background: linear-gradient(135deg, #FFC107, #FF9800);
        }

        .level-button.unsolvable {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            position: relative;
            overflow: hidden;
        }
        
        .level-button.unsolvable::after {
            content: "?";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: rgba(255,255,255,0.7);
        }
        
        /* 游戏画布样式 */
        #gameCanvas {
            display: block;
            margin: 20px auto;
            background-color: #111;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
        }
        
        /* 游戏信息样式 */
        .game-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-family: monospace;
            z-index: 10;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-width: 300px;
            transition: all 0.3s ease;
        }
        
        .game-info-item {
            display: flex;
            align-items: center;
            padding: 5px;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 4px;
            min-width: 80px;
        }
        
        /* 通关提示样式 */
        .level-complete {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            width: 400px;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.5);
            border: 2px solid #4CAF50;
            animation: popIn 0.5s ease-out;
        }
        
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        .level-complete h2 {
            font-size: 36px;
            margin-bottom: 25px;
            color: #4CAF50;
        }
        
        .level-complete p {
            font-size: 22px;
            margin-bottom: 30px;
            font-family: monospace;
        }
        
        .level-complete button {
            margin: 0 10px;
            padding: 12px 25px;
            font-size: 18px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .level-complete button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        /* 返回按钮样式 */
        .back-button {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 8px 16px;
            font-size: 16px;
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            z-index: 20;
        }
        
        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0,0,0,0.4);
        }
        
        /* 多人游戏设置样式 */
        .multiplayer-setup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            width: 400px;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
            border: 2px solid #4CAF50;
        }
        
        .multiplayer-setup h2 {
            font-size: 32px;
            margin-bottom: 30px;
            color: #4CAF50;
        }
        
        .setup-label {
            display: block;
            color: white;
            margin-bottom: 5px;
            font-size: 16px;
        }
        
        .setup-color-input {
            width: 100%;
            height: 40px;
            margin-bottom: 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .setup-input {
            margin: 15px 0;
            padding: 12px 15px;
            width: 100%;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid #4CAF50;
            border-radius: 5px;
            outline: none;
        }
        
        .setup-input:focus {
            border-color: #8BC34A;
            box-shadow: 0 0 10px rgba(139, 195, 74, 0.5);
        }
        
        .room-settings {
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #4CAF50;
        }
        
        .room-settings h4 {
            color: #4CAF50;
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        .room-settings .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .room-settings label {
            color: white;
            font-weight: bold;
        }
        
        /* 多人游戏界面样式 */
        .player-list {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            min-width: 180px;
            max-height: 400px;
            overflow-y: auto;
            -webkit-backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
            border: 1px solid #4CAF50;
        }
        
        .player-list h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #4CAF50;
            text-align: center;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        .player-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: white;
        }
        
        .player-color {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .connection-status {
            position: absolute;
            bottom: 15px;
            right: 15px;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-family: monospace;
            z-index: 10;
        }
        
        .connected {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }
        
        .disconnected {
            background: rgba(244, 67, 54, 0.8);
            color: white;
        }
        
        /* 隐藏类 */
        .hidden {
            display: none !important;
        }
        
        /* 游戏说明弹窗 */
        .instructions-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 600px;
            z-index: 1000;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.7);
            border: 2px solid #4CAF50;
        }
        
        .instructions-modal h2 {
            color: #4CAF50;
            text-align: center;
            margin-top: 0;
        }
        
        .instructions-modal p {
            line-height: 1.6;
            margin-bottom: 20px;
            font-family: monospace;
        }
        
        .instructions-modal ul {
            text-align: left;
            padding-left: 20px;
        }
        
        .instructions-modal li {
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        .instructions-modal button {
            display: block;
            margin: 20px auto 0;
            padding: 10px 25px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        /* 方向键控制面板 */
        .controls-panel {
            position: fixed;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            z-index: 10;
            transition: all 0.3s ease;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            width: 150px;
            height: 150px;
            box-sizing: border-box;
        }

        .control-button {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #4CAF50;
            border-radius: 5px;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-button:hover {
            background: rgba(76, 175, 80, 0.3);
            transform: scale(1.05);
        }

        .control-button:active {
            background: rgba(76, 175, 80, 0.5);
            transform: scale(0.95);
        }

        .control-up {
            grid-column: 2;
            grid-row: 1;
        }

        .control-left {
            grid-column: 1;
            grid-row: 2;
        }

        .control-right {
            grid-column: 3;
            grid-row: 2;
        }

        .control-down {
            grid-column: 2;
            grid-row: 3;
        }
        
        /* 关卡内控制按钮 */
        .level-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }
        
        .level-control-button {
            padding: 10px 20px;
            font-size: 16px;
            background: linear-gradient(135deg, #2196F3, #0D47A1);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        
        .level-control-button.reset {
            background: linear-gradient(135deg, #FF9800, #F57C00);
        }
        
        .level-control-button.exit {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }
        
        .level-control-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }
        
        /* 关卡选择标题样式 */
        .level-select-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            z-index: 10;
            width: 100%;
            text-align: center;
        }
        
        /* 追逐者样式 */
        .enemy-info {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 16px;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
            white-space: nowrap;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(244, 67, 54, 0.5); }
            50% { box-shadow: 0 0 20px rgba(244, 67, 54, 0.8); }
            100% { box-shadow: 0 0 5px rgba(244, 67, 54, 0.5); }
        }
        
        /* 钥匙和门样式 */
        .key-info {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 16px;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
            white-space: nowrap;
            animation: glow 1.5s infinite alternate;
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
            to { box-shadow: 0 0 15px rgba(255, 215, 0, 0.8); }
        }
        
        .unlock-timer {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 16px;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
            white-space: nowrap;
            animation: glow 1.5s infinite alternate;
        }
        
        /* 控制台样式 */
        .console-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            width: 500px;
            max-width: 90%;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.7);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            font-family: 'Courier New', monospace;
        }
        
        .console-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #4CAF50;
            margin-bottom: 10px;
        }
        
        .console-title {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .console-close {
            background: none;
            border: none;
            color: #f44336;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }
        
        .console-close:hover {
            background: rgba(244, 67, 54, 0.2);
        }
        
        .console-output {
            background: rgba(20, 20, 30, 0.9);
            height: 200px;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            overflow-y: auto;
            font-size: 14px;
            color: #ccc;
            white-space: pre-wrap;
        }
        
        .console-input-group {
            display: flex;
        }
        
        .console-prompt {
            color: #4CAF50;
            padding: 8px 10px 8px 0;
            font-weight: bold;
        }
        
        .console-input {
            flex: 1;
            background: rgba(30, 30, 40, 0.9);
            border: 1px solid #4CAF50;
            border-radius: 5px;
            padding: 8px 12px;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            outline: none;
        }
        
        .console-input:focus {
            border-color: #8BC34A;
            box-shadow: 0 0 8px rgba(139, 195, 74, 0.5);
        }
        
        .console-status {
            margin-top: 10px;
            padding: 5px 10px;
            background: rgba(30, 30, 40, 0.9);
            border-radius: 5px;
            font-size: 12px;
            color: #aaa;
        }
        
        .console-hidden {
            display: none;
        }
        
        /* 控制台提示 */
        .console-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-family: monospace;
            border: 1px solid #4CAF50;
            z-index: 100;
            animation: fadeInHint 0.5s;
        }
        
        @keyframes fadeInHint {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .console-hint.hidden {
            display: none;
        }
        
        /* UI设置面板样式 */
        .settings-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 3000;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.7);
            border: 2px solid #4CAF50;
        }
        
        /* 移动设备响应式调整 */
        @media (max-width: 768px) {
            .settings-modal {
                padding: 15px;
                width: 95%;
                max-height: 90vh;
            }
            
            .settings-modal h2 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }
            
            /* 确保输入框在手机上可点击 */
            .settings-modal input,
            .settings-modal button {
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }
            
            /* 控制台特定样式调整 */
            #consolePasswordInput,
            #consoleCommandInput {
                font-size: 16px !important;
            }
        }

        .settings-modal h2 {
            color: #4CAF50;
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .setting-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #4CAF50;
        }

        .setting-group h3 {
            color: #8BC34A;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }

        .setting-row label {
            width: 80px;
            margin-right: 15px;
            color: white;
        }

        .setting-row select, 
        .setting-row input[type="range"] {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #4CAF50;
            color: white;
            padding: 8px;
            border-radius: 5px;
        }

        .setting-row input[type="range"] {
            padding: 0;
        }
        
        .setting-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .setting-checkbox input {
            margin-right: 10px;
        }

        .buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .buttons button {
            padding: 10px 25px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .buttons button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }

        /* 音乐控制按钮样式 */
        .music-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .music-controls button {
            padding: 8px 15px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .music-controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        /* 设置按钮样式 */
        .settings-button {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 20;
            transition: all 0.3s;
        }

        .settings-button:hover {
            background: rgba(76, 175, 80, 0.8);
            transform: scale(1.1);
        }
        
        /* 游戏信息设置 */
        .info-settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .drag-handle {
            width: 100%;
            height: 20px;
            background: rgba(76, 175, 80, 0.2);
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
            cursor: move;
            position: absolute;
            top: -20px;
            left: 0;
            z-index: 1;
        }
        
        .controls-panel.draggable {
            cursor: grabbing;
        }
        
        /* 移动端控制面板拖拽样式 */
        .controls-panel {
            position: fixed;
            touch-action: none;
            transition: left 0.2s, top 0.2s;
        }
#controlsPanel {
    position: fixed;
    /* 初始位置（会被JS覆盖） */
    left: 20px;
    bottom: 20px;
    /* 平滑移动效果 */
    transition: left 0.2s, top 0.2s;
    /* 防止触摸高亮 */
    -webkit-tap-highlight-color: transparent;
}

#dragHandle {
    width: 100%;
    height: 30px;
    /* 触摸优化 */
    touch-action: none;
    cursor: grab;
}
.level-control-button.next {
    background: linear-gradient(135deg, #4CAF50, #2E7D32);
}

.level-control-button.skip {
    background: linear-gradient(135deg, #FF9800, #F57C00);
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 5px rgba(255, 152, 0, 0.7); }
    50% { box-shadow: 0 0 15px rgba(255, 152, 0, 0.9); }
    100% { box-shadow: 0 0 5px rgba(255, 152, 0, 0.7); }
}

        /* 新增样式：踢出按钮 */
        .kick-button {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 5px;
        }
        
        .kick-button:hover {
            background: linear-gradient(135deg, #ff5252, #ff1744);
        }
        
        /* 房间设置样式 */
        .room-settings {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #4CAF50;
        }
        
        .room-settings h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #8BC34A;
        }
/* 更多挑战样式 */
.challenges-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    max-width: 600px;
    margin: 30px auto;
    padding: 20px;
}

.challenge-card {
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #4CAF50;
    border-radius: 15px;
    padding: 25px;
    width: 100%;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: left;
}

.challenge-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(76, 175, 80, 0.3);
    background: rgba(0, 0, 0, 0.8);
}

.challenge-card h3 {
    color: #4CAF50;
    margin-top: 0;
    font-size: 24px;
}

.challenge-card p {
    color: #ccc;
    margin-bottom: 15px;
}

.challenge-stats {
    color: #8BC34A;
    font-size: 14px;
}

/* 成就系统样式 */
.achievements-container {
    max-width: 600px;
    margin: 30px auto;
    padding: 20px;
}

.achievement-item {
    display: flex;
    align-items: center;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #333;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}

.achievement-item.completed {
    border-color: #FFD700;
    background: rgba(255, 215, 0, 0.1);
}

.achievement-icon {
    font-size: 32px;
    margin-right: 15px;
}

.achievement-info {
    flex: 1;
}

.achievement-info h3 {
    color: #fff;
    margin: 0 0 5px 0;
    font-size: 18px;
}

.achievement-info p {
    color: #ccc;
    margin: 0 0 10px 0;
    font-size: 14px;
}

.achievement-progress {
    display: flex;
    align-items: center;
    gap: 10px;
}
.special-challenges {
    margin-top: 30px;
    border-top: 1px solid #4CAF50;
    padding-top: 20px;
}

.challenge-button {
    background: rgba(76, 175, 80, 0.2);
    border: 1px dashed #4CAF50;
    border-radius: 8px;
    padding: 15px;
    width: 100%;
    display: flex;
    align-items: center;
    cursor: pointer;
    transition: all 0.3s;
}

.challenge-button:hover {
    background: rgba(76, 175, 80, 0.4);
}

.challenge-icon {
    font-size: 30px;
    margin-right: 15px;
}
.progress-bar {
    flex: 1;
    height: 8px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(135deg, #4CAF50, #8BC34A);
    border-radius: 4px;
    transition: width 0.3s ease;
}

.achievement-status {
    padding: 5px 10px;
    background: #333;
    border-radius: 15px;
    font-size: 12px;
    color: #ccc;
}

.achievement-item.completed .achievement-status {
    background: #FFD700;
    color: #000;
    font-weight: bold;
}

/* 时间挑战提示 */
.time-challenge-info {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(244, 67, 54, 0.9);
    color: white;
    padding: 10px 15px;
    border-radius: 8px;
    font-family: monospace;
    z-index: 10;
    animation: pulse 1.5s infinite;
}
.replay-list {
    max-height: 400px;
    overflow-y: auto;
    margin: 15px 0;
    border: 1px solid #333;
    border-radius: 5px;
}

.replay-item {
    padding: 12px;
    border-bottom: 1px solid #444;
    cursor: pointer;
    transition: background 0.2s;
}

.replay-item:hover {
    background: rgba(76, 175, 80, 0.1);
}

.replay-meta {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
}

.player-container {
    margin-top: 20px;
    background: #111;
    padding: 15px;
    border-radius: 5px;
}

.player-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 15px;
}

.speed-control {
    margin-left: auto;
}
/* 事件通知样式 */
#event-notifications {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
}

.event-notification {
  background: rgba(0,0,0,0.8);
  color: #fff;
  padding: 10px 15px;
  border-radius: 5px;
  border-left: 4px solid #FF9800;
  margin-bottom: 5px;
  animation: fadeIn 0.3s;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}
/* 商店模态框样式 */
.shop-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.shop-content {
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border: 2px solid #4CAF50;
    border-radius: 15px;
    padding: 25px;
    width: 90%;
    max-width: 600px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 0 40px rgba(76, 175, 80, 0.5);
}

.shop-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #4CAF50;
}

.shop-header h2 {
    color: #4CAF50;
    margin: 0;
}

.shop-close-btn {
    background: none;
    border: none;
    color: #f44336;
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.3s;
}

.shop-close-btn:hover {
    background: rgba(244, 67, 54, 0.2);
}

.shop-items {
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-height: calc(90vh - 150px);
    overflow-y: auto;
}

/* 自定义滚动条 */
.shop-items::-webkit-scrollbar {
    width: 8px;
}

.shop-items::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
}

.shop-items::-webkit-scrollbar-thumb {
    background: rgba(76, 175, 80, 0.6);
    border-radius: 4px;
}

.shop-items::-webkit-scrollbar-thumb:hover {
    background: rgba(76, 175, 80, 0.8);
}

.shop-item {
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid #4CAF50;
    border-radius: 10px;
    padding: 12px;
    display: flex;
    align-items: center;
    transition: all 0.3s ease;
    box-sizing: border-box;
}

.shop-item:hover {
    background: rgba(76, 175, 80, 0.1);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.4);
}

.item-icon {
    font-size: 40px;
    margin-right: 20px;
}

.item-info {
    flex: 1;
}

.item-info h3 {
    color: #8BC34A;
    margin: 0 0 5px 0;
    font-size: 20px;
}

.item-info p {
    color: #ccc;
    margin: 0;
    font-size: 14px;
}

.item-price {
    display: flex;
    align-items: center;
    margin: 0 20px;
}

.coin-icon {
    color: gold;
    font-size: 20px;
    margin-right: 5px;
}

.price-amount {
    color: gold;
    font-weight: bold;
    font-size: 18px;
}

.buy-btn {
    padding: 8px 20px;
    background: linear-gradient(135deg, #FFC107, #FF9800);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s;
}

.buy-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 3px 10px rgba(255, 152, 0, 0.5);
}

/* 当金币不足时，按钮变灰且不可点击 */
.buy-btn:disabled {
    background: #555;
    cursor: not-allowed;
    transform: scale(1);
}

        /* 统计数据页面样式 */
        .statistics-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            margin-top: 60px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .statistic-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }
        
        .statistic-icon {
            font-size: 36px;
            margin-right: 20px;
            min-width: 50px;
        }
        
        .statistic-info {
            text-align: center;
            flex: 1;
        }
        
        .statistic-info h3 {
            margin: 0 0 5px 0;
            font-size: 18px;
            color: #4CAF50;
        }
        
        .statistic-info p {
            margin: 0;
            font-size: 24px;
            font-weight: bold;
        }
    
    /* 历史更新样式 */
    #historyUpdates {
        padding: 20px;
        box-sizing: border-box;
        height: 100vh;
        overflow: hidden;
    }
    
    .updates-container {
        max-width: 800px;
        margin: 0 auto;
        height: calc(100vh - 120px);
        overflow-y: auto;
        padding: 20px 0;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 20px;
        scrollbar-width: thin;
        scrollbar-color: #4CAF50 rgba(255, 255, 255, 0.1);
    }
    
    /* Webkit浏览器滚动条样式 */
    .updates-container::-webkit-scrollbar {
        width: 8px;
    }
    
    .updates-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
    }
    
    .updates-container::-webkit-scrollbar-thumb {
        background: #4CAF50;
        border-radius: 4px;
    }
    
    .updates-container::-webkit-scrollbar-thumb:hover {
        background: #45a049;
    }
    
    .update-item {
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #4CAF50;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
        transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .update-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(76, 175, 80, 0.5);
    }
    
    .update-date {
        color: #4CAF50;
        font-size: 14px;
        margin-bottom: 5px;
    }
    
    .update-title {
        color: #fff;
        font-size: 20px;
        margin: 0 0 15px 0;
    }
    
    .update-content {
        color: #ccc;
    }
    
    .update-content ul {
        list-style-type: disc;
        margin-left: 20px;
        padding: 0;
    }
    
    .update-content li {
        margin: 5px 0;
        line-height: 1.5;
    }
    
    /* 每日挑战样式 */
    #dailyChallengeScreen {
        padding: 20px;
        box-sizing: border-box;
        height: 100vh;
        overflow: hidden;
    }
    
    .daily-challenge-container {
        max-width: 800px;
        margin: 0 auto;
        height: calc(100vh - 120px);
        overflow-y: auto;
        padding: 20px 0;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 20px;
        scrollbar-width: thin;
        scrollbar-color: #4CAF50 rgba(255, 255, 255, 0.1);
    }
    
    .daily-challenge-container::-webkit-scrollbar {
        width: 8px;
    }
    
    .daily-challenge-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
    }
    
    .daily-challenge-container::-webkit-scrollbar-thumb {
        background: #4CAF50;
        border-radius: 4px;
    }
    
    .daily-challenge-container::-webkit-scrollbar-thumb:hover {
        background: #45a049;
    }
    
    .challenge-header {
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #4CAF50;
        border-radius: 10px;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .challenge-date {
        color: #4CAF50;
        font-size: 18px;
        font-weight: bold;
    }
    
    .challenge-countdown {
        color: #FFD700;
        font-size: 16px;
    }
    
    .challenge-card {
        background: linear-gradient(135deg, rgba(76, 175, 80, 0.2) 0%, rgba(255, 215, 0, 0.1) 100%);
        border: 2px solid #4CAF50;
        border-radius: 15px;
        padding: 25px;
        display: flex;
        align-items: center;
        gap: 20px;
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        transition: transform 0.3s, box-shadow 0.3s;
    }
    
    .challenge-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
    }
    
    .challenge-icon {
        font-size: 64px;
        flex-shrink: 0;
    }
    
    .challenge-info {
        flex: 1;
    }
    
    .challenge-title {
        color: #fff;
        font-size: 24px;
        margin: 0 0 10px 0;
        font-weight: bold;
    }
    
    .challenge-description {
        color: #ccc;
        font-size: 16px;
        margin: 0 0 15px 0;
    }
    
    .challenge-rewards {
        display: flex;
        gap: 20px;
    }
    
    .reward-item {
        background: rgba(255, 215, 0, 0.2);
        border: 1px solid #FFD700;
        border-radius: 20px;
        padding: 8px 16px;
        font-size: 14px;
        color: #FFD700;
        font-weight: bold;
    }
    
    .challenge-status {
        flex-shrink: 0;
    }
    
    .challenge-status span {
        display: inline-block;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: bold;
    }
    
    .status-pending {
        background: rgba(255, 152, 0, 0.2);
        color: #FF9800;
        border: 1px solid #FF9800;
    }
    
    .status-completed {
        background: rgba(76, 175, 80, 0.2);
        color: #4CAF50;
        border: 1px solid #4CAF50;
    }
    
    .challenge-details {
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #4CAF50;
        border-radius: 10px;
        padding: 20px;
    }
    
    .challenge-details h4 {
        color: #4CAF50;
        margin: 0 0 15px 0;
        font-size: 18px;
    }
    
    .challenge-details ul {
        list-style-type: none;
        padding: 0;
        margin: 0;
    }
    
    .challenge-details li {
        color: #ccc;
        padding: 8px 0;
        border-bottom: 1px solid rgba(76, 175, 80, 0.3);
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .challenge-details li:last-child {
        border-bottom: none;
    }
    
    .challenge-details li::before {
        content: "✓";
        color: #4CAF50;
        font-weight: bold;
    }
    
    .challenge-progress {
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #4CAF50;
        border-radius: 10px;
        padding: 20px;
    }
    
    .challenge-progress h4 {
        color: #4CAF50;
        margin: 0 0 15px 0;
        font-size: 18px;
    }
    
    .progress-bar {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        height: 20px;
        overflow: hidden;
        margin-bottom: 10px;
    }
    
    .progress-fill {
        background: linear-gradient(90deg, #4CAF50 0%, #8BC34A 100%);
        height: 100%;
        transition: width 0.3s ease;
        border-radius: 10px;
    }
    
    .progress-text {
        color: #ccc;
        text-align: center;
        margin: 0;
        font-size: 14px;
    }
    
    .challenge-actions {
        display: flex;
        gap: 15px;
        justify-content: center;
    }
    
    .challenge-button {
        padding: 15px 40px;
        border: none;
        border-radius: 25px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    .challenge-button.primary {
        background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
    }
    
    .challenge-button.primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
    }
    
    .challenge-button.secondary {
        background: linear-gradient(135deg, #FFD700 0%, #FFA000 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    }
    
    .challenge-button.secondary:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
    }
    
    .challenge-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }
    
    .challenge-history {
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #4CAF50;
        border-radius: 10px;
        padding: 20px;
    }
    
    .challenge-history h4 {
        color: #4CAF50;
        margin: 0 0 15px 0;
        font-size: 18px;
    }
    
    .history-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .history-item {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(76, 175, 80, 0.3);
        border-radius: 8px;
        padding: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .history-item.completed {
        border-color: #4CAF50;
    }
    
    .history-item.failed {
        border-color: #f44336;
    }
    
    .history-date {
        color: #ccc;
        font-size: 14px;
    }
    
    .history-result {
        font-weight: bold;
        font-size: 14px;
    }
    
    .history-result.completed {
        color: #4CAF50;
    }
    
    .history-result.failed {
        color: #f44336;
    }
    
    /* 房间浏览器模态框样式 */
    .room-browser-list .room-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        margin: 5px 0;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        border: 1px solid rgba(76, 175, 80, 0.3);
        cursor: pointer;
        transition: all 0.3s;
    }
    
    .room-browser-list .room-item:hover {
        background: rgba(76, 175, 80, 0.2);
        transform: translateX(5px);
    }
    
    .room-browser-list .room-info {
        flex: 1;
    }
    
    .room-browser-list .room-name {
        font-weight: bold;
        color: #4CAF50;
        font-size: 16px;
        margin-bottom: 5px;
    }
    
    .room-browser-list .room-host {
        font-size: 14px;
        color: #999;
        margin-bottom: 5px;
    }
    
    .room-browser-list .room-players {
        font-size: 12px;
        color: #ccc;
    }
    
    .room-browser-list .room-status {
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 12px;
        margin-left: 8px;
        display: inline-block;
    }
    
    .room-browser-list .room-status.waiting {
        background: rgba(76, 175, 80, 0.3);
        color: #4CAF50;
    }
    
    .room-browser-list .room-status.playing {
        background: rgba(255, 152, 0, 0.3);
        color: #FF9800;
    }
    
    .room-browser-list .join-button {
        padding: 8px 16px;
        background: linear-gradient(135deg, #2196F3, #1976D2);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        white-space: nowrap;
    }
    
    .room-browser-list .join-button:hover {
        background: linear-gradient(135deg, #42A5F5, #1E88E5);
    }
    
    .room-browser-list::-webkit-scrollbar {
        width: 8px;
    }
    
    .room-browser-list::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
    }
    
    .room-browser-list::-webkit-scrollbar-thumb {
        background: rgba(76, 175, 80, 0.5);
        border-radius: 4px;
    }
    
    .room-browser-list::-webkit-scrollbar-thumb:hover {
        background: rgba(76, 175, 80, 0.8);
    }
    
    /* 回放模态框样式 */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
    }
    
    .modal-content {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid #4CAF50;
        border-radius: 15px;
        padding: 20px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 0 40px rgba(76, 175, 80, 0.5);
    }
    
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid #4CAF50;
    }
    
    .modal-header h2 {
        color: #4CAF50;
        margin: 0;
    }
    
    .close-btn {
        background: none;
        border: none;
        color: #f44336;
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
        border-radius: 5px;
        transition: all 0.3s ease;
    }
    
    .close-btn:hover {
        background: rgba(244, 67, 54, 0.2);
        transform: scale(1.1);
    }
    
    .replay-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 10px;
    }
    
    .filter-group {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .filter-group select {
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #4CAF50;
        color: white;
        border-radius: 5px;
        cursor: pointer;
    }
    
    .replay-list {
        max-height: 400px;
        overflow-y: auto;
        margin: 20px 0;
        border: 1px solid #4CAF50;
        border-radius: 10px;
        padding: 10px;
    }
    
    .replay-item {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #4CAF50;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .replay-item:hover {
        background: rgba(76, 175, 80, 0.2);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }
    
    .replay-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
    }
    
    .replay-item-title {
        font-weight: bold;
        color: #4CAF50;
    }
    
    .replay-item-meta {
        display: flex;
        gap: 15px;
        font-size: 14px;
        color: #ccc;
        margin-top: 5px;
    }
    
    .player-container {
        margin-top: 20px;
    }
    
    .player-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }
    
    .player-header h3 {
        color: #4CAF50;
        margin: 0;
    }
    
    .video-container {
        background: rgba(0, 0, 0, 0.7);
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
    }
    
    #replayCanvas {
        display: block;
        margin: 0 auto 15px;
        background: #111;
        border: 1px solid #4CAF50;
        border-radius: 5px;
    }
    
    .player-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 15px;
        margin-bottom: 15px;
        flex-wrap: wrap;
    }
    
    .player-controls button {
        padding: 10px 15px;
        background: linear-gradient(135deg, #4CAF50, #2E7D32);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 16px;
    }
    
    .player-controls button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }
    
    .player-controls span {
        color: white;
        font-family: monospace;
        min-width: 120px;
        text-align: center;
    }
    
    .progress-container {
        margin: 15px 0;
    }
    
    #replayProgress {
        width: 100%;
        height: 8px;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 4px;
        overflow: hidden;
    }
    
    #replayProgress::-webkit-progress-bar {
        background: rgba(255, 255, 255, 0.2);
    }
    
    #replayProgress::-webkit-progress-value {
        background: linear-gradient(90deg, #4CAF50, #8BC34A);
    }
    
    /* 可视化脚本编辑器样式 */
    .script-editor-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
    }
    
    .script-editor-content {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid #4CAF50;
        border-radius: 15px;
        padding: 20px;
        width: 95%;
        height: 95%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-shadow: 0 0 40px rgba(76, 175, 80, 0.5);
    }
    
    .script-editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid #4CAF50;
    }
    
    .script-editor-header h2 {
        color: #4CAF50;
        margin: 0;
    }
    
    .script-editor-body {
        display: flex;
        flex: 1;
        overflow: hidden;
        gap: 15px;
    }
    
    .sidebar {
        width: 200px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #4CAF50;
        border-radius: 10px;
        padding: 15px;
        overflow-y: auto;
    }
    
    .sidebar h3 {
        color: #4CAF50;
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 16px;
    }
    
    .node-palette {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .palette-node {
        background: rgba(76, 175, 80, 0.2);
        border: 1px solid #4CAF50;
        border-radius: 5px;
        padding: 10px;
        cursor: grab;
        transition: all 0.3s ease;
        user-select: none;
    }
    
    .palette-node:hover {
        background: rgba(76, 175, 80, 0.4);
        transform: translateY(-2px);
    }
    
    .palette-node:active {
        cursor: grabbing;
    }
    
    .editor-workspace {
        flex: 1;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid #4CAF50;
        border-radius: 10px;
        position: relative;
        overflow: hidden;
    }
    
    .workspace-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        cursor: crosshair;
    }
    
    .properties-panel {
        width: 300px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #4CAF50;
        border-radius: 10px;
        padding: 15px;
        overflow-y: auto;
    }
    
    .properties-panel h3 {
        color: #4CAF50;
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 16px;
    }
    
    .property-group {
        margin-bottom: 15px;
    }
    
    .property-group label {
        display: block;
        color: white;
        margin-bottom: 5px;
        font-size: 14px;
    }
    
    .property-group input, .property-group select {
        width: 100%;
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #4CAF50;
        color: white;
        border-radius: 5px;
        box-sizing: border-box;
    }
    
    .property-group textarea {
        width: 100%;
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #4CAF50;
        color: white;
        border-radius: 5px;
        box-sizing: border-box;
        resize: vertical;
        min-height: 80px;
    }
    
    .editor-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #4CAF50;
    }
    
    .editor-buttons {
        display: flex;
        gap: 10px;
    }
    
    .editor-buttons button {
        padding: 10px 20px;
        background: linear-gradient(135deg, #4CAF50, #2E7D32);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
    }
    
    .editor-buttons button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }
    
    .editor-buttons button.secondary {
        background: linear-gradient(135deg, #2196F3, #0D47A1);
    }
    
    .editor-buttons button.danger {
        background: linear-gradient(135deg, #f44336, #d32f2f);
    }
    
    /* 节点样式 */
    .node {
        position: absolute;
        background: rgba(30, 30, 50, 0.9);
        border: 2px solid #4CAF50;
        border-radius: 10px;
        padding: 15px;
        cursor: grab;
        min-width: 180px;
        transition: all 0.3s ease;
        user-select: none;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }
    
    .node:hover {
        border-color: #8BC34A;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
    }
    
    .node:active {
        cursor: grabbing;
    }
    
    .node-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .node-title {
        font-weight: bold;
        color: #4CAF50;
        font-size: 16px;
    }
    
    .node-type {
        font-size: 12px;
        color: #888;
        background: rgba(255, 255, 255, 0.1);
        padding: 2px 6px;
        border-radius: 10px;
    }
    
    .node-ports {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .port {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
    }
    
    .port.in {
        justify-content: flex-start;
    }
    
    .port.out {
        justify-content: flex-end;
    }
    
    .port-dot {
        width: 12px;
        height: 12px;
        background: #4CAF50;
        border: 2px solid white;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        z-index: 10;
    }
    
    .port-dot:hover {
        transform: scale(1.2);
        box-shadow: 0 0 10px rgba(76, 175, 80, 0.8);
    }
    
    .port-label {
        color: white;
        font-size: 12px;
    }
    
    /* 连接样式 */
    .connection {
        position: absolute;
        pointer-events: none;
        z-index: 5;
    }
    
    .connection-path {
        fill: none;
        stroke: #4CAF50;
        stroke-width: 3;
        stroke-linecap: round;
        stroke-linejoin: round;
    }
    
    .connection.selected .connection-path {
        stroke: #FFD700;
        stroke-width: 4;
    }
    </style>
</head>

<body>
    <div id="shopModal" class="shop-modal hidden">
        <div class="shop-content">
            <div class="shop-header">
                <h2>游戏商店</h2>
                <button class="shop-close-btn" onclick="closeShop()">×</button>
            </div>
    
    <!-- 玩家工坊 -->
    <div id="workshopMain" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">返回</button>
        <h2 class="level-select-title">玩家工坊</h2>
        
        <div class="workshop-container">
            <button class="workshop-button" onclick="showScreen('mazeEditor')">
                <div class="workshop-button-icon">🖌️</div>
                <div class="workshop-button-text">创建迷宫</div>
            </button>
            
            <button class="workshop-button" onclick="showScreen('myMazes')">
                <div class="workshop-button-icon">📁</div>
                <div class="workshop-button-text">我的迷宫</div>
            </button>
            
            <button class="workshop-button" onclick="showScreen('browseMazes')">
                <div class="workshop-button-icon">🔍</div>
                <div class="workshop-button-text">浏览迷宫</div>
            </button>
            
            <button class="workshop-button" onclick="showScreen('popularMazes')">
                <div class="workshop-button-icon">⭐</div>
                <div class="workshop-button-text">热门迷宫</div>
            </button>
        </div>
    </div>
    
    <!-- 迷宫编辑器 -->
    <div id="mazeEditor" class="hidden">
        <button class="back-button" onclick="showScreen('workshopMain')">返回</button>
        <h2 class="level-select-title">迷宫编辑器</h2>
        
        <div class="editor-container">
            <!-- 工具栏 -->
            <div class="editor-toolbar">
                <h3>工具栏</h3>
                <div class="tool-group">
                    <button class="tool-button active" data-tool="wall">墙壁</button>
                    <button class="tool-button" data-tool="path">通道</button>
                    <button class="tool-button" data-tool="exit">出口</button>
                    <button class="tool-button" data-tool="key">钥匙</button>
                    <button class="tool-button" data-tool="door">门</button>
                    <button class="tool-button" data-tool="teleporter">传送门</button>
                </div>
                
                <div class="maze-properties">
                    <h3>迷宫属性</h3>
                    <div class="property-group">
                        <label for="mazeName">名称:</label>
                        <input type="text" id="mazeName" placeholder="输入迷宫名称">
                    </div>
                    <div class="property-group">
                        <label for="mazeDescription">描述:</label>
                        <textarea id="mazeDescription" placeholder="输入迷宫描述" rows="3"></textarea>
                    </div>
                    <div class="property-group">
                        <label for="mazeDifficulty">难度:</label>
                        <select id="mazeDifficulty">
                            <option value="简单">简单</option>
                            <option value="中等" selected>中等</option>
                            <option value="困难">困难</option>
                        </select>
                    </div>
                </div>
                
                <div class="editor-actions">
                    <button class="menu-button" onclick="newMaze()">新建</button>
                    <button class="menu-button" onclick="saveMaze()">保存到本地</button>
                    <button class="menu-button" onclick="publishMaze()">发布</button>
                    <button class="menu-button" onclick="previewMaze()">预览</button>
                </div>
            </div>
            
            <!-- 迷宫编辑画布 -->
            <div class="editor-canvas-container">
                <div class="canvas-header">
                    <h3>迷宫编辑区域</h3>
                    <div class="canvas-info">15x15 网格</div>
                </div>
                <div id="mazeCanvas" class="maze-canvas"></div>
            </div>
        </div>
    </div>
    
    <!-- 我的迷宫 -->
    <div id="myMazes" class="hidden">
        <button class="back-button" onclick="showScreen('workshopMain')">返回</button>
        <h2 class="level-select-title">我的迷宫</h2>
        
        <div class="mazes-container">
            <div id="myMazesList" class="maze-list"></div>
        </div>
    </div>
    
    <!-- 浏览迷宫 -->
    <div id="browseMazes" class="hidden">
        <button class="back-button" onclick="showScreen('workshopMain')">返回</button>
        <h2 class="level-select-title">浏览迷宫</h2>
        
        <div class="browse-container">
            <div class="search-bar">
                <input type="text" id="searchMazes" placeholder="搜索迷宫名称或作者">
                <select id="filterDifficulty">
                    <option value="">所有难度</option>
                    <option value="简单">简单</option>
                    <option value="中等">中等</option>
                    <option value="困难">困难</option>
                </select>
                <button class="menu-button" onclick="searchMazes()">搜索</button>
            </div>
            
            <div id="browseMazesList" class="maze-list"></div>
        </div>
    </div>
    
    <!-- 热门迷宫 -->
    <div id="popularMazes" class="hidden">
        <button class="back-button" onclick="showScreen('workshopMain')">返回</button>
        <h2 class="level-select-title">热门迷宫</h2>
        
        <div class="mazes-container">
            <div id="popularMazesList" class="maze-list"></div>
        </div>
    </div>
            <div class="shop-items">
                <!-- 道具1：效果清除 -->
                <div class="shop-item" data-item="clear-events">
                    <div class="item-icon">✨</div>
                    <div class="item-info">
                        <h3>效果清除</h3>
                        <p>清除当前触发的所有随机事件（如控制反转）。</p>
                    </div>
                    <div class="item-price">
                        <span class="coin-icon">🪙</span>
                        <span class="price-amount">20</span>
                    </div>
                    <button class="buy-btn" onclick="buyItem('clear-events')">购买</button>
                </div>
                
                <!-- 道具3：传送 -->
                <div class="shop-item" data-item="teleport">
                    <div class="item-icon">🌀</div>
                    <div class="item-info">
                        <h3>传送</h3>
                        <p>在单人游戏中，让你传送到地图上的任意位置。</p>
                        <p class="item-note" style="color: #888; font-size: 12px;">*仅限单人游戏</p>
                    </div>
                    <div class="item-price">
                        <span class="coin-icon">🪙</span>
                        <span class="price-amount">25</span>
                    </div>
                    <button class="buy-btn" onclick="buyItem('teleport')">购买</button>
                </div>

                <!-- 道具5：无敌护盾 -->
                <div class="shop-item" data-item="invincibility">
                    <div class="item-icon">🛡️</div>
                    <div class="item-info">
                        <h3>无敌护盾</h3>
                        <p>免疫陷阱伤害，持续20秒。</p>
                    </div>
                    <div class="item-price">
                        <span class="coin-icon">🪙</span>
                        <span class="price-amount">50</span>
                    </div>
                    <button class="buy-btn" onclick="buyItem('invincibility')">购买</button>
                </div>

                <!-- 道具6：迷宫提示 -->
                <div class="shop-item" data-item="hint">
                    <div class="item-icon">🧭</div>
                    <div class="item-info">
                        <h3>迷宫提示</h3>
                        <p>显示一条通往出口的路径。</p>
                    </div>
                    <div class="item-price">
                        <span class="coin-icon">🪙</span>
                        <span class="price-amount">10</span>
                    </div>
                    <button class="buy-btn" onclick="buyItem('hint')">购买</button>
                </div>
            </div>
        </div>
    </div>    <div id="statisticsScreen" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">返回</button>
        <h2 class="level-select-title">游戏统计</h2>
        
        <div class="statistics-container">
            <div class="statistic-item">
                <div class="statistic-icon">⏱️</div>
                <div class="statistic-info">
                    <h3>总游戏时间</h3>
                    <p id="totalPlayTime">0 分钟</p>
                </div>
            </div>
            
            <div class="statistic-item">
                <div class="statistic-icon">🎮</div>
                <div class="statistic-info">
                    <h3>总移动次数</h3>
                    <p id="totalMoves">0</p>
                </div>
            </div>
            
            <div class="statistic-item">
                <div class="statistic-icon">🏆</div>
                <div class="statistic-info">
                    <h3>通关总关卡数</h3>
                    <p id="totalLevelsCompleted">0</p>
                </div>
            </div>
            
            <div class="statistic-item">
                <div class="statistic-icon">⚡</div>
                <div class="statistic-info">
                    <h3>触发陷阱次数</h3>
                    <p id="totalTrapsTriggered">0</p>
                </div>
            </div>
            
            <div class="statistic-item">
                <div class="statistic-icon">💰</div>
                <div class="statistic-info">
                    <h3>收集金币总数</h3>
                    <p id="totalCoinsCollected">0</p>
                </div>
            </div>
            
            <div class="statistic-item">
                <div class="statistic-icon">🧩</div>
                <div class="statistic-info">
                    <h3>解谜关卡完成数</h3>
                    <p id="puzzleLevelsCompleted">0</p>
                </div>
            </div>
            
            <div class="statistic-item">
                <div class="statistic-icon">⏰</div>
                <div class="statistic-info">
                    <h3>最快通关时间</h3>
                    <p id="timeChallengeBest">0 秒</p>
                </div>
            </div>
            
            <div class="statistic-item">
                <div class="statistic-icon">📊</div>
                <div class="statistic-info">
                    <h3>平均每关移动次数</h3>
                    <p id="averageMovesPerLevel">0</p>
                </div>
            </div>
            
            <div class="statistic-item">
                <div class="statistic-icon">✅</div>
                <div class="statistic-info">
                    <h3>通关率</h3>
                    <p id="completionRate">0%</p>
                </div>
            </div>
        </div>
        
        <button class="menu-button" onclick="resetStatistics()" style="margin-top: 20px;">重置统计数据</button>
    </div>    <!-- 主菜单 -->
    <div id="mainMenu" class="main-menu">
        <h1 class="menu-title">迷宫冒险</h1>
        <button class="menu-button" onclick="showScreen('singlePlayerLevelSelect')">单人游戏</button>
        <button class="menu-button" onclick="showScreen('multiplayerSetup')">局域网多人游戏 iOS请确保服务器开启</button>
        <button class="menu-button" onclick="showInstructions()">游戏说明</button>
        <div id="playTimeDisplay" class="game-info" style="margin: 15px auto; display: inline-block;"></div>
        <button class="menu-button" onclick="showScreen('achievementsScreen')">成就系统</button>
        <button class="menu-button" onclick="showScreen('statisticsScreen')">统计数据</button>
        <!-- <button class="menu-button" onclick="showScreen('moreChallengesScreen')">更多挑战</button> -->
        <!-- <button class="menu-button" onclick="showSaveLoadMenu()">存档/读档</button> -->
        <button class="menu-button" onclick="showUISettings()">UI设置</button>
        <button class="menu-button" onclick="openShop()">游戏商店</button>
        <button class="menu-button" onclick="openConsolePasswordModal()" ontouchstart="openConsolePasswordModal()" style="cursor: pointer; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">控制台</button>
        <button class="menu-button" onclick="showScreen('dailyChallengeScreen')">每日挑战</button>
        <button class="menu-button" onclick="showScreen('historyUpdates')">历史更新</button>
        <button class="menu-button" onclick="openReplayModal()">游戏回放</button>
        <button class="menu-button" onclick="openVisualScriptEditor()">可视化脚本编辑器</button>
        
        <!-- 新增玩家工坊按钮
        <button id="workshopBtn" class="menu-btn highlight">
            玩家工坊
            <span class="badge" id="newLevelsBadge">12</span>
        </button>
        
        <button id="playBtn" class="menu-btn">
            <i class="icon-play"></i> 开始游戏
        </button> -->
        </div>
    
    <!-- 存档/读档管理界面 - 已隐藏 -->
    <!-- <div id="saveLoadModal" class="instructions-modal hidden">
        <h2>存档管理</h2>
        <div style="display: flex; flex-direction: column; gap: 20px; max-height: 80vh; overflow-y: auto;">
            <div class="save-slot">
                <h3>存档位置 1</h3>
                <div class="slot-info">空存档</div>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button class="menu-button" onclick="saveGame(0)">保存</button>
                    <button class="menu-button" onclick="confirmLoadGame(0)" disabled>加载</button>
                    <button class="menu-button" onclick="deleteSave(0)" disabled>删除</button>
                </div>
            </div>
            <div class="save-slot">
                <h3>存档位置 2</h3>
                <div class="slot-info">空存档</div>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button class="menu-button" onclick="saveGame(1)">保存</button>
                    <button class="menu-button" onclick="confirmLoadGame(1)" disabled>加载</button>
                    <button class="menu-button" onclick="deleteSave(1)" disabled>删除</button>
                </div>
            </div>
            <div class="save-slot">
                <h3>存档位置 3</h3>
                <div class="slot-info">空存档</div>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button class="menu-button" onclick="saveGame(2)">保存</button>
                    <button class="menu-button" onclick="confirmLoadGame(2)" disabled>加载</button>
                    <button class="menu-button" onclick="deleteSave(2)" disabled>删除</button>
                </div>
            </div>
        </div>
        <button style="margin-top: 20px;" onclick="closeSaveLoadMenu()">关闭</button>
    </div> -->
    
    <div id="moreChallengesScreen" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">返回</button>
        <h2 class="level-select-title">更多挑战</h2>
        <div class="challenges-container">
            <div class="challenge-card" onclick="startTimeChallenge()">
                <h3>时间挑战</h3>
                <p>在60秒内尽可能通过更多关卡！</p>
                <div class="challenge-stats">最佳记录: <span id="timeChallengeBest">0</span>秒</div>
            </div>
            <div class="challenge-card" onclick="startPuzzleMode()">
                <h3>解谜模式</h3>
                <p>解开精心设计的谜题关卡。</p>
                <div class="challenge-stats">已完成: <span id="puzzleCompleted">0</span>/10</div>
            </div>
        </div>
    </div>
    <!-- 成就系统界面 -->
    <div id="achievementsScreen" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">返回</button>
        <h2 class="level-select-title">成就系统</h2>
        
        <div class="achievements-container">
            <div class="achievement-item" id="achievement1">
                <div class="achievement-icon">🏆</div>
                <div class="achievement-info">
                    <h3>迷宫大师</h3>
                    <p>通关所有关卡</p>
                    <div class="achievement-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress1"></div>
                        </div>
                        <span id="progressText1">0/80</span>
                    </div>
                </div>
                <div class="achievement-status" id="status1">未完成</div>
            </div>
            
            <div class="achievement-item" id="achievement2">
                <div class="achievement-icon">👥</div>
                <div class="achievement-info">
                    <h3>社交达人</h3>
                    <p>通关10次多人联机挑战</p>
                    <div class="achievement-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress2"></div>
                        </div>
                        <span id="progressText2">0/10</span>
                    </div>
                </div>
                <div class="achievement-status" id="status2">未完成</div>
            </div>
            
            <div class="achievement-item" id="achievement3">
                <div class="achievement-icon">💥</div>
                <div class="achievement-info">
                    <h3>陷阱专家</h3>
                    <p>走到陷阱30次</p>
                    <div class="achievement-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress3"></div>
                        </div>
                        <span id="progressText3">0/30</span>
                    </div>
                </div>
                <div class="achievement-status" id="status3">未完成</div>
            </div>
            
            <!-- 隐藏成就：伟大的国家，勿忘国耻 -->
            <div class="achievement-item hidden" id="achievement4">
                <div class="achievement-icon">🇨🇳</div>
                <div class="achievement-info">
                    <h3>伟大的国家，勿忘国耻</h3>
                    <p>使用中国国旗表情包</p>
                    <div class="achievement-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress4"></div>
                        </div>
                        <span id="progressText4">0/1</span>
                    </div>
                </div>
                <div class="achievement-status" id="status4">未完成</div>
            </div>
        </div>
    </div>
    
    <!-- 每日挑战界面 -->
    <div id="dailyChallengeScreen" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">返回</button>
        <h2 class="level-select-title">每日挑战</h2>
        
        <div class="daily-challenge-container">
            <div class="challenge-header">
                <div class="challenge-date" id="challengeDate"></div>
                <div class="challenge-countdown" id="challengeCountdown"></div>
            </div>
            
            <div class="challenge-card" id="currentChallengeCard">
                <div class="challenge-icon" id="challengeIcon">⚡</div>
                <div class="challenge-info">
                    <h3 class="challenge-title" id="challengeTitle">加载中...</h3>
                    <p class="challenge-description" id="challengeDescription">正在获取今日挑战</p>
                    <div class="challenge-rewards">
                        <span class="reward-item">🪙 <span id="rewardCoins">0</span> 金币</span>
                        <span class="reward-item">⭐ <span id="rewardStars">0</span> 星星</span>
                    </div>
                </div>
                <div class="challenge-status" id="challengeStatus">
                    <span class="status-pending">未完成</span>
                </div>
            </div>
            
            <div class="challenge-details" id="challengeDetails">
                <h4>挑战目标</h4>
                <ul id="challengeGoals"></ul>
            </div>
            
            <div class="challenge-progress" id="challengeProgressSection" style="display: none;">
                <h4>当前进度</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
                </div>
                <p class="progress-text" id="progressText">0 / 0</p>
            </div>
            
            <div class="challenge-actions">
                <button class="challenge-button primary" id="startChallengeBtn" onclick="startDailyChallenge()">开始挑战</button>
                <button class="challenge-button secondary" id="claimRewardBtn" onclick="claimDailyReward()" style="display: none;">领取奖励</button>
            </div>
            
            <div class="challenge-history">
                <h4>历史记录</h4>
                <div class="history-list" id="challengeHistory"></div>
            </div>
        </div>
    </div>
    
    <!-- 历史更新 -->
    <div id="historyUpdates" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">返回</button>
        <h2 class="level-select-title">历史更新</h2>
        
        <div class="updates-container">
            <!-- 更新内容将由用户填写 -->
            <div class="update-item">
                <div class="update-title">版本 1.13.7</div>
                <div class="update-content">
                    <ul>
                        <li>新增每日挑战系统，提供3种不同类型的挑战任务</li>
                        <li>优化多人聊天系统，确保消息撤回功能仅发送者可用</li>
                        <li>改进音频录制稳定性，修复录音后麦克风持续占用问题</li>
                        <li>增强消息安全性，限制仅本人可操作自己发送的消息</li>
                        <li>优化Blob资源处理，解决跨会话音频加载失败问题</li>
                        <li>修复多处UI显示异常，提升整体交互体验</li>
                    </ul>
                </div>
            </div>
            <div class="update-item">
                <div class="update-title">版本 1.11.5</div>
                <div class="update-content">
                    <ul>
                        <li>新增语音转文字功能，支持语音消息转换为文字显示</li>
                        <li>添加了完整的游戏商店系统，包含各种道具和装饰品</li>
                        <li>优化了多人游戏的语音消息系统稳定性</li>
                        <li>修复了录音功能的多个bug，提升用户体验</li>
                        <li>改进了成就系统显示界面</li>
                        <li>优化了游戏整体性能和加载速度</li>
                    </ul>
                </div>
            </div>
            
            <div class="update-item">
                <div class="update-title">版本 1.10.4</div>
                <div class="update-content">
                    <ul>
                        <li>完善了语音消息系统，支持最长60秒录音</li>
                        <li>添加了录音状态实时显示功能</li>
                        <li>优化了多人游戏的连接稳定性</li>
                        <li>修复了房间加入时的卡死问题</li>
                        <li>改进了游戏界面的响应速度</li>
                        <li>添加了更多游戏道具和功能</li>
                    </ul>
                </div>
            </div>
            
            <div class="update-item">
                <div class="update-title">版本 1.9.1</div>
                <div class="update-content">
                    <ul>
                        <li>优化了迷宫生成算法，提供更多样化的地图布局</li>
                        <li>改进了多人游戏的同步机制</li>
                        <li>添加了更多的游戏设置选项</li>
                        <li>修复了多个已知的游戏bug</li>
                        <li>提升了游戏整体稳定性</li>
                    </ul>
                </div>
            </div>
            
            <div class="update-item">
                <div class="update-title">版本 1.8.3 - 房间搜索（特殊版本，未发布）</div>
                <div class="update-content">
                    <ul>
                        <li>新增房间搜索功能，方便玩家快速找到可加入的房间</li>
                        <li>优化了多人游戏的房间管理系统</li>
                        <li>改进了玩家匹配算法</li>
                        <li>添加了房间信息显示（玩家数量、游戏状态等）</li>
                        <li>提升了多人游戏的连接速度</li>
                    </ul>
                </div>
            </div>
            
            <div class="update-item">
                <div class="update-title">版本 1.7.4</div>
                <div class="update-content">
                    <ul>
                        <li>优化了游戏界面的视觉效果</li>
                        <li>改进了移动端触控体验</li>
                        <li>修复了多个UI显示问题</li>
                        <li>提升了游戏整体性能</li>
                        <li>优化了代码结构和加载效率</li>
                    </ul>
                </div>
            </div>
            
            <div class="update-item">
                <div class="update-title">版本 1.7.1</div>
                <div class="update-content">
                    <ul>
                        <li>优化了多人游戏的网络通信</li>
                        <li>改进了游戏状态的同步机制</li>
                        <li>修复了部分设备上的兼容性问题</li>
                        <li>提升了游戏运行稳定性</li>
                        <li>优化了内存使用效率</li>
                    </ul>
                </div>
            </div>
            
            <div class="update-item">
                <div class="update-title">版本 1.6.5</div>
                <div class="update-content">
                    <ul>
                        <li>优化了单人游戏的关卡设计</li>
                        <li>改进了游戏的难度平衡</li>
                        <li>添加了更多的游戏音效</li>
                        <li>优化了迷宫生成算法</li>
                        <li>提升了游戏整体体验</li>
                    </ul>
                </div>
            </div>
            
            <div class="update-item">
                <div class="update-title">版本 1.4.2 - 随机事件系统</div>
                <div class="update-content">
                    <ul>
                        <li>引入了随机事件系统，增加游戏趣味性</li>
                        <li>添加了控制反转等特殊事件</li>
                        <li>优化了游戏商店系统</li>
                        <li>改进了成就系统的显示效果</li>
                        <li>提升了游戏界面的美观度</li>
                        <li>修复了多个游戏机制问题</li>
                    </ul>
                </div>
            </div>
        
        </div>
    </div>
    
    <!-- 单人游戏界面 -->
    <div id="singlePlayerLevelSelect" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">返回</button>
        <h2 class="level-select-title">选择关卡</h2>
        <div class="level-container" id="levelContainer"></div>
    </div>

    <div id="singlePlayerGame" class="hidden">
        <button class="settings-button" onclick="showUISettings()">⚙️</button>
        <div class="game-info" id="gameInfo">
            <div class="game-info-item" id="levelDisplay">关卡: 1</div>
            <div class="game-info-item" id="timeDisplay">时间: 0:00</div>
            <div class="game-info-item" id="moveCount">移动: 0</div>
            <div class="game-info-item" id="trapHit">陷阱触发: 0</div>
            <div class="game-info-item" id="keyStatus">钥匙: 未获得</div>
            <div class="game-info-item" id="coinDisplay" style="display: none;">金币: 0</div>
        </div>
        <div id="enemyInfo" class="enemy-info hidden">移动敌人正在追逐你！</div>
        <div id="pathEnemyInfo" class="enemy-info hidden">当前有移动敌人，请停止前进。</div>
        <div id="keyInfo" class="key-info hidden">找到钥匙才能开门！</div>
        <div id="unlockTimer" class="unlock-timer hidden">开门倒计时: 10秒</div>


        <canvas id="singlePlayerCanvas"></canvas>
        <div class="level-controls">
            <button class="level-control-button reset" onclick="resetSinglePlayerLevel()">重置关卡</button>
            <button id="regularNextButton" class="level-control-button next" style="display:none;" onclick="loadNextLevel()">下一关</button>
            <button id="unsolvableNextButton" class="level-control-button skip" style="display:none;" onclick="loadNextLevel()">跳过无解关卡</button>
            <button class="level-control-button save" onclick="saveGame()">💾 保存游戏</button>
            <!-- <button class="level-control-button exit" onclick="showExitConfirmation()">退出关卡</button> -->
            <button class="level-control-button exit" onclick="showScreen('mainMenu')">退出关卡</button>
            <button class="level-control-button shop-trigger" onclick="openShop()">🛒 商店</button>
            <button class="level-control-button record" onclick="toggleRecording()" id="recordButton">📹 录制</button>
            <button class="level-control-button save-record" onclick="saveRecording()" id="saveRecordButton" style="display:none;">💾 保存回放</button>
        </div>
        <!-- 方向键控制面板 -->
        <div class="controls-panel hidden" id="singlePlayerControls">
            <div class="drag-handle" id="mobileDragHandle"></div>
            <div class="control-button control-up" onclick="handleControlButtonClick('ArrowUp')">↑</div>
            <div class="control-button control-left" onclick="handleControlButtonClick('ArrowLeft')">←</div>
            <div class="control-button control-right" onclick="handleControlButtonClick('ArrowRight')">→</div>
            <div class="control-button control-down" onclick="handleControlButtonClick('ArrowDown')">↓</div>
        </div>
    </div>

    <div id="singlePlayerComplete" class="level-complete hidden">
        <h2>关卡完成!</h2>
        <p id="singlePlayerCompleteTime">用时: 0:00</p>
        <p id="singlePlayerCompleteMoves">移动次数: 0</p>
        <button onclick="loadNextLevel()">下一关</button>
        <button onclick="showScreen('singlePlayerLevelSelect')">选择关卡</button>
    </div>

    <!-- 多人游戏界面 -->
    <div id="multiplayerSetup" class="hidden">
        <div class="multiplayer-setup">
            <h2>多人游戏设置</h2>
            <div>
                <input type="text" id="playerName" class="setup-input" placeholder="你的名字" maxlength="10" value="玩家">
            </div>
            <div>
                <label for="playerColor" class="setup-label">选择头像颜色:</label>
                <input type="color" id="playerColor" class="setup-color-input" value="#FF6B6B">
            </div>
            <div>
                <input type="text" id="roomCode" class="setup-input" placeholder="房间代码 (留空创建新房间)">
            </div>
            <div>
                <input type="password" id="roomPassword" class="setup-input" placeholder="房间密码 (可选)">
            </div>
            <div class="room-settings">
                <h4>房间设置 (仅创建房间时有效)</h4>
                <div class="setting-row">
                    <label for="maxPlayers">最大人数:</label>
                    <select id="maxPlayers" class="setup-input">
                        <option value="2">2人</option>
                        <option value="3">3人</option>
                        <option value="4">4人</option>
                        <option value="5">5人</option>
                        <option value="6">6人</option>
                        <option value="7">7人</option>
                        <option value="8">8人</option>
                    </select>
                </div>
            </div>
            <div id="roomStatus" style="margin: 10px 0; color: #4CAF50;"></div>
            <button class="menu-button" onclick="connectToMultiplayerGame()" id="multiplayerStartBtn">开始游戏</button>
            <button class="menu-button" onclick="openRoomBrowserModal()">浏览房间</button>
            <button class="menu-button" onclick="showScreen('mainMenu')">返回</button>
        </div>
    </div>
    
    <!-- 房间浏览器模态框 -->
    <div id="roomBrowserModal" class="room-browser-modal hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 99999; display: none; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto;">
        <div class="room-browser-content" style="background: rgba(30, 30, 30, 0.95); border: 2px solid #4CAF50; border-radius: 15px; padding: 30px; max-width: 600px; width: 90%; max-height: 90vh; display: flex; flex-direction: column; overflow: hidden; position: relative; z-index: 20001;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div style="font-size: 60px; margin-right: 15px;">🏠</div>
                <div>
                    <h2 style="color: #4CAF50; margin: 0 0 5px 0; font-size: 24px;">浏览房间</h2>
                    <p style="color: #ccc; margin: 0; font-size: 14px;">查找并加入公开房间</p>
                </div>
                <button onclick="closeRoomBrowserModal()" style="background: none; border: none; color: #aaa; font-size: 28px; cursor: pointer; padding: 5px; border-radius: 5px;">×</button>
            </div>
            
            <div class="search-container" style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <input type="text" id="roomBrowserSearch" style="flex: 1; min-width: 200px; padding: 12px; background: rgba(0, 0, 0, 0.5); border: 1px solid rgba(76, 175, 80, 0.5); border-radius: 5px; color: white; font-size: 16px;" placeholder="搜索房间或房主">
                <button onclick="searchRoomsInModal()" style="padding: 12px 24px; background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; white-space: nowrap;">搜索</button>
                <button onclick="loadRoomsInModal()" style="padding: 12px 24px; background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; white-space: nowrap;">刷新</button>
            </div>
            
            <div id="roomBrowserStatus" style="margin-bottom: 15px; color: #4CAF50; font-size: 14px;"></div>
            
            <div id="roomBrowserList" class="room-browser-list" style="flex: 1; max-height: 400px; overflow-y: auto; background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 10px; margin-bottom: 20px;">
                <!-- 房间列表将由JavaScript动态生成 -->
            </div>
            
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button onclick="closeRoomBrowserModal()" style="padding: 15px 40px; background: linear-gradient(135deg, #757575, #616161); color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 16px; font-weight: bold;">关闭</button>
            </div>
        </div>
    </div>

    <div id="multiplayerGame" class="hidden">
        <button class="settings-button" onclick="showUISettings()">⚙️</button>
        <div class="player-list" id="playerList">
            <h3>玩家列表</h3>
            <div id="playersContainer"></div>
        </div>
        <div class="game-info" id="multiplayerGameInfo">
            <div class="game-info-item" id="multiplayerRoomCode">房间: </div>
            <div class="game-info-item" id="multiplayerTimeDisplay">时间: 0:00</div>
            <div class="game-info-item" id="multiplayerMoveCount">移动: 0</div>
            <div class="game-info-item" id="multiplayerPlayerCount">玩家: 0/0</div>
        </div>
        <div id="connectionStatus" class="connection-status connected">已连接</div>
        <!-- 聊天按钮 -->
        <button id="chatButton" class="chat-button" onclick="openChatModal()" style="position: absolute; bottom: 20px; left: 20px; padding: 10px 15px; background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; z-index: 10;">💬 聊天</button>
        <!-- 聊天系统 -->
        <div id="chatContainer" class="chat-container" style="display: none;">
            <div id="chatMessages" class="chat-messages" style="flex: 1; overflow-y: auto; padding: 10px; font-size: 14px; font-family: monospace;"></div>
            <div style="display: flex; padding: 5px;">
                <textarea id="chatInput" class="chat-input" placeholder="输入消息..." style="flex: 1.5; padding: 8px; border: 1px solid #4CAF50; border-radius: 5px; background: rgba(255, 255, 255, 0.1); color: white; outline: none; resize: none; min-height: 36px; max-height: 100px;"></textarea>
                <input type="file" id="imageInput" accept="image/*" style="display: none;" onchange="handleImageSelect(event)">
                <button id="imageButton" class="image-button" onclick="document.getElementById('imageInput').click()" style="margin-left: 5px; padding: 8px; background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">🖼️</button>
                <button id="emojiButton" class="emoji-button" onclick="toggleEmojiPicker()" style="margin-left: 5px; padding: 8px; background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">😊</button>
                <button id="voiceButton" class="voice-button" onclick="toggleVoiceRecording()" style="margin-left: 5px; padding: 8px; background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">🎤</button>


                <button id="sendButton" class="send-button" onclick="sendChatMessage()" style="margin-left: 5px; padding: 8px 12px; background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 5px; cursor: pointer;">发送</button>
            </div>
        </div>
        <!-- 表情包选择面板 -->
        <div id="emojiPicker" class="emoji-picker" style="display: none; position: fixed; bottom: 100px; left: 20px; width: 300px; max-height: 200px; background: rgba(0, 0, 0, 0.9); border: 1px solid #4CAF50; border-radius: 10px; padding: 10px; overflow-y: auto; overflow-x: hidden; -webkit-overflow-scrolling: touch; z-index: 6000;"></div>
        
        <!-- 音频元素，用于播放背景音乐 -->
        <audio id="gameAudio" loop preload="auto">
            <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg">
            您的浏览器不支持音频播放。
        </audio>
        
        <!-- 音频文件选择输入框 -->
        <input type="file" id="musicFileInput" accept="audio/*" style="display: none;" onchange="handleMusicFileSelect(event)">
        
        <!-- 全屏聊天模态框 -->
        <div id="chatModal" class="chat-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 5000; display: none; flex-direction: column;">
            <!-- 聊天头部 -->
            <div class="chat-header" style="padding: 15px; background: rgba(76, 175, 80, 0.2); border-bottom: 1px solid #4CAF50; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; color: #4CAF50; font-size: 24px;">聊天窗口</h2>
                <button id="closeChatModal" onclick="closeChatModal()" style="background: rgba(244, 67, 54, 0.8); color: white; border: none; border-radius: 50%; width: 30px; height: 30px; font-size: 20px; cursor: pointer;">×</button>
            </div>
            
            <!-- 聊天消息区域 -->
            <div id="chatMessagesModal" class="chat-messages" style="flex: 1; overflow-y: auto; padding: 20px; font-size: 16px; font-family: monospace;"></div>
            
            <!-- 聊天输入区域 -->
            <div class="chat-input-area" style="padding: 20px; border-top: 1px solid #4CAF50; display: flex; gap: 10px; background: rgba(0, 0, 0, 0.8);">
                <textarea id="chatInputModal" class="chat-input" placeholder="输入消息..." style="flex: 1.5; padding: 12px; border: 1px solid #4CAF50; border-radius: 5px; background: rgba(255, 255, 255, 0.1); color: white; outline: none; font-size: 16px; resize: none; min-height: 40px; max-height: 150px;"></textarea>
                <input type="file" id="imageInputModal" accept="image/*" style="display: none;" onchange="handleImageSelect(event)">
                <button id="imageButtonModal" class="image-button" onclick="document.getElementById('imageInputModal').click()" style="padding: 12px; background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 18px;">🖼️</button>
                <button id="emojiButtonModal" class="emoji-button" onclick="toggleEmojiPicker()" style="padding: 12px; background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 18px;">😊</button>
                <button id="voiceButtonModal" class="voice-button" onclick="toggleVoiceRecording()" style="padding: 12px; background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 18px;">🎤</button>


                <button id="sendButtonModal" class="send-button" onclick="sendChatMessage()" style="padding: 12px 20px; background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">发送</button>
            </div>
        </div>

        <!-- 录音状态模态框 -->
        <div id="recordingModal" class="recording-modal hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 10000; display: none; flex-direction: column; justify-content: center; align-items: center;">
            <div class="recording-content" style="text-align: center;">
                <div class="recording-icon" style="font-size: 80px; margin-bottom: 20px; animation: pulse 1s infinite;">🎤</div>
                <div class="recording-status" style="color: #4CAF50; font-size: 28px; margin-bottom: 10px;">正在录音</div>
                <div id="recordingTimer" class="recording-timer" style="color: #fff; font-size: 48px; font-family: monospace; margin-bottom: 30px;">00:00</div>
                <div class="recording-progress" style="width: 300px; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; margin-bottom: 30px; overflow: hidden;">
                    <div id="recordingProgress" class="progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4CAF50, #2E7D32); transition: width 0.3s;"></div>
                </div>
                <div class="recording-buttons" style="display: flex; gap: 20px; justify-content: center;">
                    <button id="pauseRecordingBtn" class="recording-btn" onclick="togglePauseRecording()" style="padding: 15px 40px; background: linear-gradient(135deg, #FF9800, #F57C00); color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 18px;">⏸️ 暂停</button>
                    <button id="stopRecordingBtn" class="recording-btn" onclick="stopVoiceRecording()" style="padding: 15px 40px; background: linear-gradient(135deg, #f44336, #d32f2f); color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 18px;">⏹️ 停止</button>
                </div>
                <div class="recording-hint" style="color: #888; font-size: 14px; margin-top: 20px;">点击停止发送语音，点击暂停暂时停止录音</div>
            </div>
        </div>
        
        <!-- 音乐播放确认弹窗 -->
        <div id="musicPlayConfirmModal" class="music-confirm-modal hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 15000; display: none; flex-direction: column; justify-content: center; align-items: center;">
            <div class="music-confirm-content" style="background: rgba(30, 30, 30, 0.95); border: 2px solid #4CAF50; border-radius: 15px; padding: 30px; max-width: 400px; text-align: center;">
                <div style="font-size: 60px; margin-bottom: 20px;">🎵</div>
                <h2 style="color: #4CAF50; margin: 0 0 15px 0; font-size: 24px;">音乐播放请求</h2>
                <p style="color: #ccc; margin: 0 0 25px 0; font-size: 16px; line-height: 1.5;">有玩家想要播放背景音乐，是否同意播放？</p>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button id="acceptMusicBtn" onclick="acceptMusicPlay()" style="padding: 15px 40px; background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 16px; font-weight: bold;">同意播放</button>
                    <button id="rejectMusicBtn" onclick="rejectMusicPlay()" disabled style="padding: 15px 40px; background: linear-gradient(135deg, #f44336, #d32f2f); color: white; border: none; border-radius: 25px; cursor: not-allowed; font-size: 16px; font-weight: bold; opacity: 0.5;">拒绝 (<span id="rejectCountdown">10</span>秒)</button>
                </div>
            </div>
        </div>
        
        <!-- 踢出玩家界面 -->
        <div id="kickPlayerModal" class="kick-player-modal hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 16000; display: none; flex-direction: column; justify-content: center; align-items: center;">
            <div class="kick-player-content" style="background: rgba(30, 30, 30, 0.95); border: 2px solid #FF5252; border-radius: 15px; padding: 30px; max-width: 500px; text-align: center;">
                <div style="font-size: 60px; margin-bottom: 20px;">👥</div>
                <h2 style="color: #FF5252; margin: 0 0 15px 0; font-size: 24px;">踢出玩家</h2>
                <p style="color: #ccc; margin: 0 0 25px 0; font-size: 16px;">选择要踢出的玩家：</p>
                <div id="kickPlayerList" class="kick-player-list" style="max-height: 300px; overflow-y: auto; margin-bottom: 20px; background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
                    <!-- 玩家列表将由JavaScript动态生成 -->
                </div>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button onclick="closeKickPlayerModal()" style="padding: 15px 40px; background: linear-gradient(135deg, #757575, #616161); color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 16px; font-weight: bold;">取消</button>
                </div>
            </div>
        </div>

        <canvas id="multiplayerCanvas"></canvas>
        <div class="level-controls" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; z-index: 10; background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 25px; border: 1px solid #4CAF50;">
            <button class="level-control-button reset" onclick="resetMultiplayerPlayer()">重置位置</button>
            <button class="level-control-button shop-trigger" onclick="openShop()">🛒 商店</button>
            <button class="level-control-button exit" onclick="disconnectMultiplayer()">退出游戏</button>
        </div>
        <!-- 方向键控制面板 -->
        <div class="controls-panel hidden" id="multiplayerControls">
            <div class="drag-handle" id="mobileMultiplayerDragHandle"></div>
            <div class="control-button control-up" onclick="handleControlButtonClick('ArrowUp')">↑</div>
            <div class="control-button control-left" onclick="handleControlButtonClick('ArrowLeft')">←</div>
            <div class="control-button control-right" onclick="handleControlButtonClick('ArrowRight')">→</div>
            <div class="control-button control-down" onclick="handleControlButtonClick('ArrowDown')">↓</div>
        </div>
    </div>

    <!-- 游戏说明弹窗 -->
    <div id="instructionsModal" class="instructions-modal hidden">
        <h2>游戏说明</h2>
        <p><strong>单人模式：</strong>80个独特关卡，难度递增。使用方向键移动角色，避开陷阱，找到出口。</p>
        <p><strong style="color: #4CAF50">多人模式：</strong>与朋友合作或竞争。创建房间或加入已有房间，共同完成迷宫挑战。</p>
        <p><strong>迷宫元素：</strong></p>
        <ul>
            <li>绿色：玩家</li>
            <li>红色：出口</li>
            <li>黄色：陷阱（触碰后回到起点）</li>
            <li>青色：传送门（随机传送到另一个传送门）</li>
            <li>紫色：移动陷阱（会移动的危险区域）</li>
            <li><span style="color: #f44336">红色闪烁警告</span>：移动敌人正在追逐你！</li>
            <li><span style="color: gold">金色</span>：钥匙（特殊关卡需要钥匙才能开门）</li>
            <li><span style="color: #8B4513">棕色</span>：门（需要钥匙才能打开）</li>
        </ul>
        <p><strong>特殊关卡：</strong></p>
        <ul>
            <li>第30关和60关为螺旋迷宫，中心是出口，并有移动敌人追逐玩家！</li>
            <li>特殊关卡需要找到钥匙才能开门，拿到钥匙后需要10秒倒计时才能开门</li>
        </ul>
        <button onclick="document.getElementById('instructionsModal').classList.add('hidden')">关闭</button>
    </div>
    
    <!-- UI设置面板 -->
    <div id="uiSettingsModal" class="settings-modal hidden">
        <h2>UI设置</h2>

    <!-- 音乐解锁模态框 -->
    <div id="musicUnlockModal" class="settings-modal hidden">
        <h2>音乐解锁</h2>
        <p>请输入密码解锁音乐播放器</p>
        <input type="password" id="musicPasswordInput" placeholder="输入密码" style="width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #4CAF50; border-radius: 5px; background: rgba(255, 255, 255, 0.1); color: white; font-size: 16px;">
        <div class="error-message" id="passwordError" style="color: red; display: none; margin-bottom: 15px;">密码错误</div>
        <button onclick="validateMusicPassword()" style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">解锁</button>
    </div>
        
        <div class="setting-group">
            <h3>控制面板</h3>
            <label for="showControlsCheckbox">
                <input type="checkbox" id="showControlsCheckbox"> 显示控制面板
            </label>
            
            <div class="setting-row">
                <label for="controlsPosition">位置:</label>
                <select id="controlsPosition">
                    <option value="bottom-left">左下角</option>
                    <option value="bottom-right">右下角</option>
                    <option value="top-left">左上角</option>
                    <option value="top-right">右上角</option>
                    <option value="custom">自定义（实验性功能）</option>
                </select>
            </div>
            
            <div class="setting-row">
                <label for="controlsSize">大小:</label>
                <input type="range" id="controlsSize" min="80" max="150" value="100">
            </div>
            
            <div class="setting-row">
                <label for="controlsOpacity">透明度:</label>
                <input type="range" id="controlsOpacity" min="30" max="100" value="60">
            </div>
        </div>
        
        <div class="setting-group">
            <h3>游戏信息</h3>
            <label for="showGameInfoCheckbox">
                <input type="checkbox" id="showGameInfoCheckbox" checked> 显示游戏信息
            </label>
            
            <div class="info-settings">
                <div class="setting-checkbox">
                    <input type="checkbox" id="showLevelInfo" checked>
                    <label for="showLevelInfo">关卡信息</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showTimeInfo" checked>
                    <label for="showTimeInfo">时间信息</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showMoveInfo" checked>
                    <label for="showMoveInfo">移动次数</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showKeyInfo" checked>
                    <label for="showKeyInfo">钥匙状态</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showRoomInfo" checked>
                    <label for="showRoomInfo">房间代码</label>
                </div>
            </div>
        </div>
        <div class="setting-group">
            <h3>多人游戏设置</h3>
            <label for="showPlayerListCheckbox">
                <input type="checkbox" id="showPlayerListCheckbox" checked>
                显示玩家列表
            </label>
        </div>

        <div class="setting-group">
            <h3>音乐播放器</h3>
            <label for="musicEnabledCheckbox">
                <input type="checkbox" id="musicEnabledCheckbox"> 启用音乐
            </label>
            <div class="setting-row">
                <label for="musicVolume">音量:</label>
                <input type="range" id="musicVolume" min="0" max="100" value="50">
            </div>
            <div class="setting-row">
                <label>音乐选择:</label>
                <div id="musicSelectionList" style="display: flex; flex-direction: column; gap: 6px; max-height: 150px; overflow-y: auto; padding: 6px; border: 1px solid #4CAF50; border-radius: 5px; background: rgba(0, 0, 0, 0.3); font-size: 14px;">
                    <!-- 默认音乐选项 -->
                    <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="musicSelected" value="game-music-1" checked> 游戏音乐 1
                        </label>
                    </div>
                    <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="musicSelected" value="game-music-2"> 游戏音乐 2
                        </label>
                    </div>
                    <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="musicSelected" value="game-music-3"> 游戏音乐 3
                        </label>
                    </div>
                    <!-- 自定义音乐将动态添加在这里 -->
                </div>
                <div style="margin-top: 10px; display: flex; gap: 10px;">
                    <button id="deleteCustomMusicBtn" onclick="deleteSelectedCustomMusic()" disabled>删除选中项</button>
                    <button onclick="deleteAllCustomMusic()" disabled id="deleteAllMusicBtn">删除所有自定义音乐</button>
                </div>
            </div>
            <div class="setting-row">
                <label for="customMusicFile">导入自定义音乐:</label>
                <div>
                    <input type="text" id="customMusicName" placeholder="音乐名称" style="width: 150px; margin-right: 10px;">
                    <input type="file" id="customMusicFile" accept=".mp3" style="margin-right: 10px;">
                    <button onclick="importCustomMusic()">导入</button>
                </div>
            </div>
            <div class="music-controls">
                <button id="musicPlay">▶️ 播放</button>
                <button id="musicPause">⏸️ 暂停</button>
                <button id="musicStop">⏹️ 停止</button>
            </div>
        </div>

        <div class="buttons">
            <button onclick="saveUISettings()">保存</button>
            <button onclick="document.getElementById('uiSettingsModal').classList.add('hidden')">取消</button>
            <button onclick="checkServerVersion()">检查版本</button>
        </div>
    </div>
    
    <!-- 音乐解锁模态框 -->
    <div id="musicUnlockModal" class="settings-modal hidden">
        <h2>音乐解锁</h2>
        <p>请输入密码解锁音乐播放器</p>
        <input type="password" id="musicPasswordInput" placeholder="输入密码" style="width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #4CAF50; border-radius: 5px; background: rgba(255, 255, 255, 0.1); color: white; font-size: 16px;">
        <div class="error-message" id="passwordError" style="color: red; display: none; margin-bottom: 15px;">密码错误</div>
        <button onclick="validateMusicPassword()" style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">解锁</button>
    </div>
    
    <!-- 开发者控制台 -->
    <div id="console" class="console-container console-hidden">
        <div class="console-header">
            <div class="console-title">开发者控制台</div>
            <button class="console-close" onclick="toggleConsole()">×</button>
        </div>
        <div class="console-output" id="consoleOutput">> 欢迎使用开发者控制台
> 输入 'help' 查看可用命令</div>
        <div class="console-input-group">
            <div class="console-prompt">></div>
            <input type="text"class="console-input"id="consoleInput"placeholder="输入命令...">
        </div>
    </div>

    <!-- 控制台密码输入模态框 -->
    <div id="consolePasswordModal" class="settings-modal hidden">
        <h2>控制台密码</h2>
        <p>请输入控制台密码：</p>
        <input type="password" id="consolePasswordInput" placeholder="输入密码" style="width: 100%; padding: 10px; margin: 15px 0; border: 1px solid #4CAF50; border-radius: 5px; background: rgba(255, 255, 255, 0.1); color: #fff; font-size: 16px;" />
        <div style="display: flex; justify-content: center; gap: 20px;">
            <button class="menu-button" onclick="checkConsolePassword()" ontouchstart="checkConsolePassword()" style="cursor: pointer; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">确认</button>
            <button class="menu-button" onclick="closeConsolePasswordModal()" ontouchstart="closeConsolePasswordModal()" style="cursor: pointer; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">取消</button>
        </div>
    </div>


    <div id="consoleModal" class="settings-modal hidden">
        <h2>JavaScript控制台</h2>
        <div id="consoleContent" style="background: rgba(0, 0, 0, 0.8); padding: 15px; border-radius: 5px; max-height: 400px; overflow-y: auto; margin: 15px 0; font-family: monospace; font-size: 14px; line-height: 1.4; color: #fff;">
        </div>
        <div style="display: flex; margin: 15px 0; gap: 10px;">
            <input type="text" id="consoleCommandInput" placeholder="输入JavaScript命令..." style="flex: 1; padding: 10px; border: 1px solid #4CAF50; border-radius: 5px; background: rgba(255,255,255,0.1); color: #fff; font-family: monospace; font-size: 14px;" />
            <button class="menu-button" onclick="executeConsoleCommand()" ontouchstart="executeConsoleCommand()" style="cursor: pointer; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">执行</button>
        </div>
        <div style="display: flex; justify-content: center; gap: 20px;">
            <button class="menu-button" onclick="refreshConsole()" ontouchstart="refreshConsole()" style="cursor: pointer; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">刷新</button>
            <button class="menu-button" onclick="closeConsoleModal()" ontouchstart="closeConsoleModal()" style="cursor: pointer; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">关闭</button>
        </div>
    </div>

    <div id="replayModal" class="modal hidden">
        <div class="modal-content" style="max-width:800px">
            <div class="modal-header">
                <h2>游戏回放库</h2>
                <button class="close-btn" onclick="closeReplayModal()">×</button>
            </div>
            <div class="replay-controls">
                <div class="filter-group">
                    <select id="replayFilter">
                        <option value="all">全部录像</option>
                        <option value="recent">最近一周</option>
                        <option value="best">最佳通关</option>
                    </select>
                </div>
            </div>
            
            <div class="replay-list" id="replayList">
                <!-- 动态生成录像列表 -->
            </div>
            
            <div class="player-container hidden" id="playerContainer">
                <div class="player-header">
                    <h3 id="replayTitle">关卡1 - 2023-07-15</h3>
                    <button onclick="exitPlayer()">返回列表</button>
                </div>
                
                <div class="video-container">
                    <canvas id="replayCanvas"></canvas>
                    
                    <div class="player-controls">
                        <button onclick="seekBack()">⏪ 5秒</button>
                        <button onclick="togglePlay()" id="playBtn">▶️ 播放</button>
                        <button onclick="seekForward()">⏩ 5秒</button>
                        <span id="timeDisplay">00:00 / 02:30</span>
                        
                        <div class="speed-control">
                            <select id="playbackSpeed">
                                <option value="0.5">0.5×</option>
                                <option value="1" selected>1×</option>
                                <option value="2">2×</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="progress-container">
                        <progress id="replayProgress" value="0" max="100"></progress>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="event-notifications"></div>
    
    <!-- 图片预览模态框 -->
    <div id="imagePreviewModal" class="image-preview-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 7000; display: none; justify-content: center; align-items: center;">
        <div class="image-preview-content" style="position: relative; max-width: 90%; max-height: 90%;">
            <img id="previewImage" src="" alt="图片预览" style="max-width: 100%; max-height: 80vh; object-fit: contain; border-radius: 10px;">
            <button id="closePreview" class="close-preview" style="position: absolute; top: -30px; right: -30px; background: rgba(244, 67, 54, 0.8); color: white; border: none; border-radius: 50%; width: 30px; height: 30px; font-size: 20px; cursor: pointer;">×</button>
            <button id="downloadImage" class="download-preview" style="position: absolute; bottom: -30px; right: 50%; transform: translateX(50%); background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; border-radius: 5px; padding: 8px 15px; cursor: pointer; font-size: 14px;">下载图片</button>
        </div>
    </div>
    
    <!-- 版本信息显示 -->
    <div id="versionInfo" class="version-info" style="position: fixed; bottom: 10px; right: 10px; background: rgba(0, 0, 0, 0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px; z-index: 100;">迷宫冒险 - 1.13.7</div>
    
    <!-- 可视化脚本编辑器 -->
    <div id="visualScriptEditor" class="script-editor-modal hidden">
        <div class="script-editor-content">
            <div class="script-editor-header">
                <h2>可视化脚本编辑器</h2>
                <button class="close-btn" onclick="closeVisualScriptEditor()">×</button>
            </div>
            <div class="script-editor-body">
                <div class="sidebar">
                    <h3>节点库</h3>
                    <div class="node-palette">
                        <div class="palette-node" draggable="true" data-node-type="start">开始节点</div>
                        <div class="palette-node" draggable="true" data-node-type="move">移动节点</div>
                        <div class="palette-node" draggable="true" data-node-type="condition">条件节点</div>
                        <div class="palette-node" draggable="true" data-node-type="wait">等待节点</div>
                        <div class="palette-node" draggable="true" data-node-type="end">结束节点</div>
                    </div>
                </div>
                <div class="editor-workspace">
                    <canvas id="scriptCanvas" class="workspace-canvas"></canvas>
                    <div id="nodesContainer"></div>
                </div>
                <div class="properties-panel">
                    <h3>节点属性</h3>
                    <div id="nodeProperties"></div>
                </div>
            </div>
            <div class="editor-footer">
                <div class="editor-buttons">
                    <button onclick="newScript()">新建</button>
                    <button class="secondary" onclick="saveScript()">保存</button>
                    <button class="secondary" onclick="loadScript()">加载</button>
                    <button class="danger" onclick="clearWorkspace()">清空</button>
                </div>
                <div class="script-info">
                    <span id="scriptInfo">未保存</span>
                </div>
            </div>
        </div>
    </div>
    <script>
const CLIENT_VERSION = "1.13.7";
const GAME_SERVER_URL = 'https://maze-game-apiserver.onrender.com'; // 服务器URL，根据实际情况修改
async function checkServerVersion() {
    const button = event.target; // 获取被点击的按钮本身
    const originalText = button.textContent;
    
    // 禁用按钮并显示加载状态
    button.disabled = true;
    button.textContent = '检查中...';
    
    showNotification('正在检查服务器连接...', 3000);

    try {
        const fullUrl = GAME_SERVER_URL + '/api/version-check';

        // ===== 修改点：在 fetch 请求中添加自定义头信息 =====
        const response = await fetch(fullUrl, {
            method: 'GET', // GET 请求也可以带 headers
            headers: {
                // 'Content-Type': 'application/json', // GET 请求通常不需要这个
                'Client-Version': CLIENT_VERSION // 自定义的请求头，键为 'Client-Version', 值为我们的版本号
            }
        });

        if (!response.ok) {
            throw new Error(`服务器返回错误: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        console.log('服务器版本检查结果:', data);

        // 根据返回的状态处理结果
        switch(data.status) {
            case 'ok':
                showNotification(`✅ 版本检查成功！当前版本: ${data.version}`, 4000);
                break;
            case 'outdated':
                 // 如果需要，可以在这里显示更详细的服务器版本
                 const serverVerMsg = data.serverVersion ? `\n服务器最新版本: ${data.serverVersion}` : '';
                 const message = `⚠️ 提示: 您的游戏版本已过时！${serverVerMsg}\n\n请刷新页面或联系管理员更新游戏。`;
                 alert(message);
                 showNotification('请立即更新游戏以保证体验！', 7000);
                 break;
            case 'error':
            default:
                 showNotification(`❌ 错误: ${data.message || '服务器返回了错误信息'}`, 5000);
        }

    } catch (error) {
        console.error('版本检查请求失败:', error);
        showNotification(`❌ 无法连接到服务器！\n请确保服务器正在运行且IP地址正确。`, 6000);
    } finally {
        button.disabled = false;
        button.textContent = originalText;
    }
}
let teleportSelectionMode = false;
const modal = document.createElement('div');
window.addEventListener('load', function() {
    const levelContainer = document.getElementById('levelContainer');
    let startY = 0;
    let isScrolling = false;
    // 触摸开始事件
    levelContainer.addEventListener('touchstart', function(e) {
        startY = e.touches[0].clientY;
        isScrolling = true;
    }, { passive: true }); // 使用passive改善滚动性能
    // 触摸移动事件
    levelContainer.addEventListener('touchmove', function(e) {
        if (!isScrolling) return;
        
        const y = e.touches[0].clientY;
        const scrollTop = levelContainer.scrollTop;
        const scrollerHeight = levelContainer.scrollHeight;
        const containerHeight = levelContainer.clientHeight;
        
        // 防止在顶部下拉或底部上拉
        if ((scrollTop <= 0 && y > startY) || 
            (scrollTop >= scrollerHeight - containerHeight && y < startY)) {
            e.preventDefault();
        }
        
        startY = y;
    }, { passive: false });
    // 触摸结束事件
    levelContainer.addEventListener('touchend', function() {
        isScrolling = false;
    }, { passive: true });
});
// 全局游戏状态变量
let singlePlayerGame = {
    canvas: null,
    ctx: null,
    maze: [],
    player: { x: 1, y: 1 },
    exit: { x: 0, y: 0 },
    cellSize: 30,
    startTime: 0,
    timerInterval: null,
    moveCount: 0,
    teleporters: [],
    movingTraps: [],
    movingEnemies: [],
    difficultySettings: [
                { size: 7, wallDensity: 0.3, traps: 0, movingTraps: 0, oneWayPaths: 0 },
                { size: 9, wallDensity: 0.35, traps: 1, movingTraps: 0, oneWayPaths: 0 },
                { size: 11, wallDensity: 0.4, traps: 2, movingTraps: 1, oneWayPaths: 0 },
                { size: 13, wallDensity: 0.45, traps: 4, movingTraps: 1, oneWayPaths: 1 },
                { size: 15, wallDensity: 0.5, traps: 6, movingTraps: 2, oneWayPaths: 1 },
                { size: 17, wallDensity: 0.55, traps: 8, movingTraps: 3, oneWayPaths: 2 },
                { size: 19, wallDensity: 0.6, traps: 10, movingTraps: 4, oneWayPaths: 3 },
                { size: 21, wallDensity: 0.65, traps: 12, movingTraps: 5, oneWayPaths: 4 },
                { size: 23, wallDensity: 0.7, traps: 14, movingTraps: 6, oneWayPaths: 5 },
                { size: 25, wallDensity: 0.75, traps: 16, movingTraps: 7, oneWayPaths: 6 }
            ],
    hasKey: false,
    doorPosition: null,
    keyPosition: null,
    isUnlocking: false,
    unlockTimeLeft: 0,
    unlockTimer: null
};

        class Random {
            constructor(seed) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
        }
let consoleVisible = false;
let consoleHistory = [];
let historyIndex = -1;
let autoSaveTimer = null; // 自动保存计时器
// 游戏状态
let gameState = {
    autoSaveSlot: 0, // 自动保存使用的存档槽位
    // 游戏时长统计
    totalPlayTime: parseInt(localStorage.getItem('totalPlayTime')) || 0, // 总游戏时长（毫秒）
    sessionStartTime: Date.now(), // 当前会话开始时间
    lastSavedTime: Date.now(), // 最后保存时间
    coins: 0, // 玩家持有的金币数量
    currentScreen: 'mainMenu',
    unlockedLevel: parseInt(localStorage.getItem('unlockedLevel')) || 1,
    completedLevels: JSON.parse(localStorage.getItem('completedLevels')) || [],
    currentLevel: 1,
    playerName: '玩家' + Math.floor(Math.random() * 1000),
    unsolvableLevels: [], // 空的无解关卡列表（用户自定义）
    specialLevels: [30,50], // 空的特殊关卡列表（用户自定义）
    controlsReversed: false,
    showPathHint: false, // 控制是否显示路径提示
    pathHintTimer: null, // 路径提示定时器
    lastPortal: null, // 上一次使用的传送门
    lastPathLength: 0, // 上一次的路径长度
    developerMode: false, // 开发者模式标志
    playerData: {
        coins: 0,
        skins: {
            current: 'default',
            unlocked: ['default'],
            available: [
                { id: 'default', name: '默认角色', icon: '👤', price: 0 },
                { id: 'warrior', name: '勇士', icon: '⚔️', price: 100 },
                { id: 'mage', name: '法师', icon: '🧙', price: 200 },
                { id: 'ninja', name: '忍者', icon: '🥷', price: 300 },
                { id: 'robot', name: '机器人', icon: '🤖', price: 500 },
                { id: 'alien', name: '外星人', icon: '👽', price: 800 },
                { id: 'knight', name: '骑士', icon: '🛡️', price: 1200 },
                { id: 'dragon', name: '龙', icon: '🐉', price: 2000 }
            ]
        }
    },
    multiplayer: {
        connected: false,
        peer: null,
        connections: {},
        players: {},
        currentPlayerId: null,
        roomCode: null,
        roomPassword: '',
        isHost: false,
        maze: [],
        startTime: 0,
        timerInterval: null,
        moveCount: 0,
        maxPlayers: 2, // 默认最大人数
        protectedPlayers: {}, // 受保护玩家列表
        showPlayerList: true,
        unlockTimeLeft:10
    },
    devMode: false,
    uiSettings: JSON.parse(localStorage.getItem('uiSettings')) || {
        showControls: true,
        controlsPosition: 'bottom-left',
        controlsSize: 100,
        controlsOpacity: 60,
        showGameInfo: true,
        showLevelInfo: true,
        showTimeInfo: true,
        showMoveInfo: true,
        showKeyInfo: true,
        showRoomInfo: true,
        customX: null,
        customY: null,
        showPlayerList: true,
        // 音乐设置
        musicEnabled: false,
        musicVolume: 50,
        musicSelected: 'game-music-1',
        // 自定义音乐数组
        customMusic: [],
        // 添加自定义位置的x和y坐标
        customX: null,
        customY: null
    },
    // 新功能状态
    achievements: JSON.parse(localStorage.getItem('achievements')) || {
        allLevelsCompleted: false,
        multiplayerWins: 0,
        trapHits: 0,
        chineseEmojiUsed: false
    },
    // 音乐播放器状态
    musicPlayer: {
        audio: null,
        isPlaying: false,
        currentTrack: null
    },
    
    gameStats: JSON.parse(localStorage.getItem('gameStats')) || {
        timeChallengeBest: 0,
        puzzleLevelsCompleted: 0,
        totalLevelsCompleted: 0,
        totalPlayTime: 0,
        totalMoves: 0,
        totalTrapsTriggered: 0,
        totalCoinsCollected: 0,
        averageMovesPerLevel: 0,
        completionRate: 0
    },
    
    settings: JSON.parse(localStorage.getItem('gameSettings')) || {
        autoSave: true
    },
    
    currentChallenge: null, // 'time' 或 'puzzle'
    saveSlots: JSON.parse(localStorage.getItem('saveSlots')) || [{}, {}, {}],
    currentSaveSlot: 0,
    autoSave: false,
    
    // 每日挑战系统
    dailyChallenge: JSON.parse(localStorage.getItem('dailyChallenge')) || {
        currentDate: null,
        challengeType: null,
        challengeData: null,
        isCompleted: false,
        isClaimed: false,
        progress: 0,
        history: []
    },
    
    // 回放相关属性
    replayEvents: [], // 游戏事件记录
    isRecording: false, // 是否正在记录
    
    // 回放系统
    replaySystem: {
        recordings: [], // 保存的回放记录
        currentRecording: null, // 当前正在播放的回放
        isPlaying: false, // 是否正在播放
        playbackSpeed: 1, // 播放速度
        currentFrame: 0, // 当前播放帧
        playbackInterval: null // 播放定时器
    }
    };

// 初始化回放系统
function initReplaySystem() {
    try {
        const savedRecordings = localStorage.getItem('gameRecordings');
        if (savedRecordings) {
            const parsedRecordings = JSON.parse(savedRecordings);
            if (Array.isArray(parsedRecordings)) {
                gameState.replaySystem.recordings = parsedRecordings;
            } else {
                // 数据格式不正确，重置为默认值
                gameState.replaySystem.recordings = [];
                localStorage.setItem('gameRecordings', JSON.stringify([]));
            }
        }
    } catch (error) {
        console.error('加载回放记录失败:', error);
        // 加载失败，重置为默认值
        gameState.replaySystem.recordings = [];
        localStorage.setItem('gameRecordings', JSON.stringify([]));
    }
}

// 自动保存功能
function startAutoSave() {
    // 清除之前的计时器（如果存在）
    if (autoSaveTimer) {
        clearInterval(autoSaveTimer);
    }
    
    // 每2分钟（120000毫秒）自动保存一次
    autoSaveTimer = setInterval(() => {
        if (gameState.currentScreen === 'singlePlayerGame') {
            saveGame(gameState.autoSaveSlot);
        }
    }, 120000); // 2分钟
}

// 停止自动保存
function stopAutoSave() {
    if (autoSaveTimer) {
        clearInterval(autoSaveTimer);
        autoSaveTimer = null;
    }
}

// 存档功能实现
function saveGame(slot = 0) {
    if (gameState.currentScreen !== 'singlePlayerGame') {
        showNotification('请在单人游戏中保存进度！');
        return;
    }
    
    const saveData = {
        playerData: {
            x: singlePlayerGame.player.x,
            y: singlePlayerGame.player.y,
            hasKey: singlePlayerGame.hasKey
        },
        currentLevel: gameState.currentLevel,
        mazeState: JSON.parse(JSON.stringify(singlePlayerGame.maze)),
        moveCount: singlePlayerGame.moveCount,
        keyPosition: singlePlayerGame.keyPosition,
        doorPosition: singlePlayerGame.doorPosition,
        startTime: singlePlayerGame.startTime,
        timestamp: new Date().toLocaleString()
    };
    
    gameState.saveSlots[slot] = saveData;
    localStorage.setItem('saveSlots', JSON.stringify(gameState.saveSlots));
    showNotification('保存成功！');
    
    // 更新自动保存计时器
    if (autoSaveTimer) {
        clearInterval(autoSaveTimer);
        startAutoSave();
    }
}


function deleteSave(slot = 0) {
    if (confirm('确定要删除该存档吗？')) {
        gameState.saveSlots[slot] = {};
        localStorage.setItem('saveSlots', JSON.stringify(gameState.saveSlots));
        showNotification(`已删除存档位置 ${slot+1} 的存档`);
        updateSaveLoadMenu();
    }
}

function showSaveLoadMenu() {
    document.getElementById('saveLoadModal').classList.remove('hidden');
    updateSaveLoadMenu();
}

function closeSaveLoadMenu() {
    document.getElementById('saveLoadModal').classList.add('hidden');
}

// 扩展存档槽功能
function expandSaveSlots() {
    const password = prompt('请输入扩展存档槽的密码：');
    if (password === '11save++') {
        const currentSlots = gameState.saveSlots;
        // 创建20个槽位的新数组
        const newSlots = Array(20).fill({});
        // 保留原有存档数据
        for (let i = 0; i < currentSlots.length; i++) {
            if (currentSlots[i] && Object.keys(currentSlots[i]).length > 0) {
                newSlots[i] = currentSlots[i];
            }
        }
        // 更新游戏状态
        gameState.saveSlots = newSlots;
        localStorage.setItem('saveSlots', JSON.stringify(gameState.saveSlots));
        showNotification('存档槽已成功扩展至20个！');
        updateSaveLoadMenu();
    } else {
        showNotification('密码错误，无法扩展存档槽！');
    }
}

function updateSaveLoadMenu() {
    const slots = document.querySelectorAll('.save-slot');
    slots.forEach((slot, index) => {
        const saveData = gameState.saveSlots[index];
        const slotInfo = slot.querySelector('.slot-info');
        const buttons = slot.querySelectorAll('.menu-button');
        const loadBtn = buttons[1]; // 第二个按钮是加载按钮
        const deleteBtn = buttons[2]; // 第三个按钮是删除按钮
        
        if (saveData && Object.keys(saveData).length > 0) {
            slotInfo.innerHTML = `关卡: ${saveData.currentLevel}<br>玩家位置: (${saveData.playerData.x}, ${saveData.playerData.y})<br>是否有钥匙: ${saveData.playerData.hasKey ? '是' : '否'}<br>移动次数: ${saveData.moveCount}<br>时间: ${saveData.timestamp}`;
            loadBtn.disabled = false;
            deleteBtn.disabled = false;
        } else {
            slotInfo.innerHTML = '空存档';
            loadBtn.disabled = true;
            deleteBtn.disabled = true;
        }
    });
}

// 墙壁消失模式
let wallRemovalMode = false;
function startWallRemovalMode() {
    if (gameState.currentScreen !== 'singlePlayerGame' && !(gameState.currentScreen === 'multiplayerGame' && gameState.developerMode)) {
        showNotification('请在单人游戏中使用此道具！');
        return;
    }
    wallRemovalMode = true;
    showNotification('墙壁消失模式已激活，点击地图上的墙壁来移除它。');
    
    // 根据当前游戏模式设置正确的画布光标样式
    if (gameState.currentScreen === 'singlePlayerGame') {
        document.getElementById('singlePlayerCanvas').style.cursor = 'crosshair';
    } else if (gameState.currentScreen === 'multiplayerGame') {
        document.getElementById('multiplayerCanvas').style.cursor = 'crosshair';
    }
}

// 打开商店
function openShop() {
    // 隐藏所有屏幕
    const screens = [
        'mainMenu', 'singlePlayerLevelSelect', 'singlePlayerGame', 
        'singlePlayerComplete', 'multiplayerSetup', 'multiplayerGame',
        'achievementsScreen', 'moreChallengesScreen', 'statisticsScreen'
    ];
    
    screens.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.classList.add('hidden');
        }
    });
    
    document.getElementById('shopModal').classList.remove('hidden');
    // 打开商店时更新所有按钮的状态
    updateShopButtons();
}

// 关闭商店
function closeShop() {
    document.getElementById('shopModal').classList.add('hidden');
    // 恢复之前显示的屏幕
    const currentScreen = gameState.currentScreen;
    if (currentScreen) {
        const screenElement = document.getElementById(currentScreen);
        if (screenElement) {
            screenElement.classList.remove('hidden');
        }
    }
}

// 更新商店按钮的可用状态
function updateShopButtons() {
    const buttons = document.querySelectorAll('.buy-btn');
    buttons.forEach(btn => {
        const itemKey = btn.parentElement.dataset.item;
        const item = SHOP_ITEMS[itemKey];
        if (item && gameState.coins < item.price) {
            btn.disabled = true;
            btn.textContent = '金币不足';
        } else {
            btn.disabled = false;
            btn.textContent = '购买';
        }
    });
}

// 商店物品配置
const SHOP_ITEMS = {
    'clear-events': { price: 20, name: '效果清除', description: '清除所有随机事件' },
    'remove-wall': { price: 15, name: '墙壁消失', description: '移除任意一个墙壁' },
    'teleport': { price: 25, name: '传送门', description: '传送到迷宫任意位置' },
    'speed-boost': { price: 30, name: '速度提升', description: '移动速度提升50%，持续30秒' },
    'invincibility': { price: 50, name: '无敌护盾', description: '免疫陷阱伤害，持续20秒' },
    'hint': { price: 10, name: '迷宫提示', description: '显示一条通往出口的路径' }
};

// 购买物品
function buyItem(itemKey) {
    const item = SHOP_ITEMS[itemKey];
    if (!item) return;

    if (gameState.coins >= item.price) {
        gameState.coins -= item.price;
        gameState.playerData.coins = gameState.coins;
        updateCoinDisplay();
        updateShopButtons(); // 更新按钮状态
        showNotification(`成功购买 ${item.name}！`);
        
        // 道具添加到背包，这里简化处理，直接激活效果
        // 在实际中，你可能需要一个背包系统来存储道具
        activateItem(itemKey);
        
    } else {
        showNotification('金币不足，无法购买！');
    }
}

// 激活道具效果
function activateItem(itemKey) {
    switch(itemKey) {
        case 'clear-events':
            if (gameState.currentScreen === 'singlePlayerGame' || (gameState.currentScreen === 'multiplayerGame' && gameState.developerMode)) {
                if (Object.keys(EventSystem.activeEvents).length > 0) {
                    // 调用所有事件的清理函数
                    Object.values(EventSystem.activeEvents).forEach(event => {
                        if (event.cleanup) event.cleanup();
                    });
                    EventSystem.activeEvents = {}; // 清空事件
                    showNotification('所有随机事件已清除！');
                } else {
                    showNotification('当前没有触发的随机事件。');
                }
            } else {
                showNotification('此道具仅在单人游戏中可用！');
            }
            break;
            
        case 'remove-wall':
            startWallRemovalMode();
            break;
            
        case 'teleport':
            if (gameState.currentScreen === 'singlePlayerGame' || (gameState.currentScreen === 'multiplayerGame' && gameState.developerMode)) {
                startTeleportSelectionMode();
            } else {
                showNotification('此道具仅在单人游戏中可用！');
            }
            break;
            
        case 'speed-boost':
            if (gameState.currentScreen === 'singlePlayerGame' || (gameState.currentScreen === 'multiplayerGame' && gameState.developerMode)) {
                // 保存原始速度
                if (!gameState.originalSpeed) {
                    gameState.originalSpeed = 120;
                }
                // 提升速度
                clearInterval(gameState.keyboardInputTimer);
                gameState.keyboardInputTimer = setInterval(handleKeyboardInput, 80);
                showNotification('速度提升！持续30秒。');
                // 30秒后恢复原始速度
                setTimeout(() => {
                    clearInterval(gameState.keyboardInputTimer);
                    gameState.keyboardInputTimer = setInterval(handleKeyboardInput, gameState.originalSpeed);
                    showNotification('速度提升效果已结束。');
                }, 30000);
            } else {
                showNotification('此道具仅在单人游戏中可用！');
            }
            break;
            
        case 'vision-enhance':
            if (gameState.currentScreen === 'singlePlayerGame' || (gameState.currentScreen === 'multiplayerGame' && gameState.developerMode)) {
                // 保存原始视野
                if (!gameState.originalVisionRange) {
                    gameState.originalVisionRange = gameState.visionRange || 1;
                }
                // 扩大视野
                gameState.visionRange = 3;
                showNotification('视野增强！持续60秒。');
                // 重新绘制迷宫以应用新视野
                if (gameState.currentScreen === 'singlePlayerGame') {
                    drawSinglePlayerMaze();
                } else {
                    drawMultiplayerMaze();
                }
                // 60秒后恢复原始视野
                setTimeout(() => {
                    gameState.visionRange = gameState.originalVisionRange;
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        drawSinglePlayerMaze();
                    } else {
                        drawMultiplayerMaze();
                    }
                    showNotification('视野增强效果已结束。');
                }, 60000);
            } else {
                showNotification('此道具仅在单人游戏中可用！');
            }
            break;
            
        case 'invincibility':
            if ((gameState.currentScreen === 'singlePlayerGame' || (gameState.currentScreen === 'multiplayerGame' && gameState.developerMode)) && !gameState.invincible) {
                // 激活无敌
                gameState.invincible = true;
                showNotification('无敌护盾激活！持续20秒。');
                // 20秒后取消无敌
                setTimeout(() => {
                    gameState.invincible = false;
                    showNotification('无敌护盾效果已结束。');
                }, 20000);
            } else {
                showNotification('此道具仅在单人游戏中可用！');
            }
            break;
            
        case 'coin-magnet':
            if (gameState.currentScreen === 'singlePlayerGame' || (gameState.currentScreen === 'multiplayerGame' && gameState.developerMode)) {
                // 激活金币磁铁
                gameState.coinMagnetActive = true;
                showNotification('金币磁铁激活！持续45秒。');
                // 45秒后取消金币磁铁
                setTimeout(() => {
                    gameState.coinMagnetActive = false;
                    showNotification('金币磁铁效果已结束。');
                }, 45000);
            } else {
                showNotification('此道具仅在单人游戏中可用！');
            }
            break;
            
        case 'hint':
            if (gameState.currentScreen === 'singlePlayerGame' || (gameState.currentScreen === 'multiplayerGame' && gameState.developerMode)) {
                // 寻找从当前位置到出口的路径
                const maze = gameState.currentScreen === 'singlePlayerGame' ? singlePlayerGame.maze : multiplayerGame.maze;
                const player = gameState.currentScreen === 'singlePlayerGame' ? singlePlayerGame.player : multiplayerGame.players[gameState.multiplayer.peerId];
                const exit = gameState.currentScreen === 'singlePlayerGame' ? singlePlayerGame.exit : multiplayerGame.exit;
                
                const path = findPathToExit(maze, 
                    player.x, player.y,
                    exit.x, exit.y);
                if (path && path.length > 0) {
                    showNotification('已显示通往出口的路径！');
                    // 标记需要显示路径
                    gameState.showPathHint = true;
                    // 在迷宫上绘制路径
                    drawPathHint(path);
                } else {
                    showNotification('无法找到通往出口的路径。');
                    addCoins(10);
                }
            } else {
                showNotification('此道具仅在单人游戏中可用！');
            }
            break;
    }
}

// 使用BFS寻找从当前位置到出口的路径
function findPathToExit(maze, startX, startY, endX, endY) {
    const rows = maze.length;
    const cols = maze[0].length;
    const visited = Array(rows).fill().map(() => Array(cols).fill(false));
    const queue = [];
    const prev = {};
    
    // 四个方向：上、右、下、左
    const directions = [
        { dx: -1, dy: 0 },
        { dx: 0, dy: 1 },
        { dx: 1, dy: 0 },
        { dx: 0, dy: -1 }
    ];
    
    // 将起点加入队列
    queue.push({ x: startX, y: startY });
    visited[startY][startX] = true;
    
    while (queue.length > 0) {
        const current = queue.shift();
        
        // 如果到达终点，回溯路径
        if (current.x === endX && current.y === endY) {
            const path = [];
            let node = current;
            while (node) {
                path.unshift({ x: node.x, y: node.y });
                node = prev[`${node.x},${node.y}`];
            }
            return path;
        }
        
        // 探索四个方向
        for (const dir of directions) {
            const newX = current.x + dir.dx;
            const newY = current.y + dir.dy;
            
            // 检查是否在迷宫范围内且未访问过且不是墙壁
            if (newY >= 0 && newY < rows && newX >= 0 && newX < cols &&
                !visited[newY][newX] && maze[newY][newX] !== 1) {
                
                visited[newY][newX] = true;
                queue.push({ x: newX, y: newY });
                prev[`${newX},${newY}`] = current;
            }
        }
    }
    
    // 没有找到路径
    return null;
}

// 在迷宫上绘制路径提示
function drawPathHint(path) {
    // 根据当前游戏模式选择画布和cellSize
    const gameMode = gameState.currentScreen;
    const ctx = gameMode === 'singlePlayerGame' ? 
        singlePlayerGame.canvas.getContext('2d') : 
        multiplayerGame.canvas.getContext('2d');
    const cellSize = gameMode === 'singlePlayerGame' ? 
        singlePlayerGame.cellSize : 
        multiplayerGame.cellSize;
    
    // 绘制路径
    ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
    ctx.lineWidth = 3;
    ctx.setLineDash([5, 5]);
    
    ctx.beginPath();
    ctx.moveTo(
        path[0].x * cellSize + cellSize / 2,
        path[0].y * cellSize + cellSize / 2
    );
    
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(
            path[i].x * cellSize + cellSize / 2,
            path[i].y * cellSize + cellSize / 2
        );
    }
    
    ctx.stroke();
    ctx.setLineDash([]);
    
    // 检查路径上是否有移动敌人
    checkEnemiesOnPath(path);
    
    // 清除之前的定时器（如果有的话）
    if (gameState.pathHintTimer) {
        clearTimeout(gameState.pathHintTimer);
    }
    
    // 30秒后清除路径并重置状态
    gameState.pathHintTimer = setTimeout(() => {
        gameState.showPathHint = false;
        document.getElementById('pathEnemyInfo').classList.add('hidden');
        // 根据游戏模式调用正确的绘制函数
        if (gameMode === 'singlePlayerGame') {
            drawSinglePlayerMaze();
        } else {
            drawMultiplayerMaze();
        }
    }, 30000);
}

function checkEnemiesOnPath(path) {
    const enemiesOnPath = [];
    const gameMode = gameState.currentScreen;
    
    // 获取当前游戏模式的移动敌人列表
    const movingEnemies = gameMode === 'singlePlayerGame' ? 
        singlePlayerGame.movingEnemies : 
        (multiplayerGame.movingEnemies || []);
    
    // 检查路径上的每个点是否有敌人
    for (const pathPoint of path) {
        for (const enemy of movingEnemies) {
            if (enemy.x === pathPoint.x && enemy.y === pathPoint.y) {
                enemiesOnPath.push(enemy);
                break;
            }
        }
    }
    
    // 如果有敌人，显示警告
    const pathEnemyInfo = document.getElementById('pathEnemyInfo');
    if (enemiesOnPath.length > 0) {
        pathEnemyInfo.classList.remove('hidden');
    } else {
        pathEnemyInfo.classList.add('hidden');
    }
    
    return enemiesOnPath;
}

function createCoinDisplay() {
    const coinDisplay = document.createElement('div');
    coinDisplay.id = 'coinDisplay';
    coinDisplay.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: gold;
        padding: 10px 15px;
        border-radius: 8px;
        font-family: monospace;
        font-size: 18px;
        font-weight: bold;
        z-index: 100;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        display: none; /* 默认隐藏 */
    `;
    coinDisplay.innerHTML = `
        <span style="color: gold;">🪙</span>
        <span id="coinCount">0</span>
    `;
    document.body.appendChild(coinDisplay);
}

// 显示金币UI
function showCoinDisplay() {
    document.getElementById('coinDisplay').style.display = 'block';
}

// 隐藏金币UI
function hideCoinDisplay() {
    document.getElementById('coinDisplay').style.display = 'none';
}

// 更新金币数量
function updateCoinDisplay() {
    document.getElementById('coinCount').textContent = gameState.coins;
}
function startTeleportSelectionMode(targetPlayerId = null) {
    // 保存当前游戏状态和目标玩家
    gameState.mapSelectionMode = true;
    gameState.mapSelectionTarget = targetPlayerId;
    
    // 添加地图点击事件监听
    if (gameState.currentScreen === 'singlePlayerGame') {
        singlePlayerGame.canvas.addEventListener('click', handleMapClick);
        document.getElementById('consoleOutput').innerHTML += 
            '\n地图选择模式已激活，点击地图上的位置进行传送';
            console.log('地图选择模式已激活');
            showNotification('地图选择模式已激活，点击地图上的位置进行传送');
    } else {
        document.getElementById('consoleOutput').innerHTML += 
            '\n地图选择模式只能在单人游戏中进行';
        gameState.mapSelectionMode = false;
    }
}
// 添加金币
function addCoins(amount) {
    gameState.coins += amount;
    // 同时也更新 playerData 中的，以便于保存
    gameState.playerData.coins = gameState.coins;
    updateCoinDisplay();
    
    // 在每日挑战模式下，也更新收集的金币数
    if (gameState.currentChallenge === 'daily' && singlePlayerGame.coinsCollected !== undefined) {
        singlePlayerGame.coinsCollected += amount;
    }
    
    // 显示获得金币的提示
    showNotification(`获得 ${amount} 个金币！`);
}

// 在页面加载时初始化金币显示
window.addEventListener('load', () => {
    createCoinDisplay();
    // 从 localStorage 加载金币，如果没有则初始化为0
    gameState.coins = parseInt(localStorage.getItem('playerCoins')) || 0;
    gameState.playerData.coins = gameState.coins;
    // 初始不显示，在游戏开始时再显示
});

const EventSystem = {
  events: [],
  activeEvents: {},
  cooldowns: {},

  init() {
    setInterval(() => this.checkEvents(), 5000); // 每5秒检查一次
  },

  register(event) {
    this.events.push(event);
  },

  checkEvents() {
    if (gameState.currentScreen !== 'singlePlayerGame') return;

    this.events.forEach(event => {
      if (this.shouldTrigger(event)) {
        this.trigger(event);
      }
    });
  },

  shouldTrigger(event) {
    // 检查冷却
    if (this.cooldowns[event.id] > Date.now()) return false;
    // 检查概率
    return Math.random() < (event.probability || 0.1);
  },

  trigger(event) {
    // 执行效果
    const cleanup = event.effect();
    
    // 设置冷却
    this.cooldowns[event.id] = Date.now() + (event.cooldown || 60000);
    if (!event || typeof event.effect !== 'function') {
        console.error('错误的事件:', event);
        return; // 直接返回，防止报错
    }
    // 存储清理函数
    if (cleanup) {
      this.activeEvents[event.id] = {
        endTime: Date.now() + (event.duration || 10000),
        cleanup
      };
    }

    // 显示通知
    this.showNotification(event.name, event.description);
  },

  showNotification(title, text) {
    const div = document.createElement('div');
    div.className = 'event-notification';
    div.innerHTML = `<b>${title}</b>: ${text}`;
    document.getElementById('event-notifications').appendChild(div);
    setTimeout(() => div.remove(), 5000);
  },

  update() {
    const now = Date.now();
    Object.keys(this.activeEvents).forEach(id => {
      if (now >= this.activeEvents[id].endTime) {
        this.activeEvents[id].cleanup();
        delete this.activeEvents[id];
      }
    });
  },
  triggerById(eventId) {
    const event = this.events.find(e => 
    e.id.toLowerCase() === eventId.toLowerCase()
    );
    if (!event) {
      console.error(`事件不存在: ${eventId}`);
      return;
    }
    // 执行效果
    const cleanup = event.effect();
    
    // 设置冷却（即使强制触发也仍然应用冷却）
    this.cooldowns[event.id] = Date.now() + (event.cooldown || 60000);
    
    // 存储清理函数
    if (cleanup) {
      this.activeEvents[event.id] = {
        endTime: Date.now() + (event.duration || 10000),
        cleanup
      };
    }
    // 显示通知
    this.showNotification(event.name, `[强制触发] ${event.description}`);
    }
}
// 初始化
EventSystem.init();

// 游戏回放功能
// 记录游戏事件
function recordGameEvent(eventType, data) {
    if (!gameState.isRecording) return;
    
    const event = {
        type: eventType,
        data: data,
        timestamp: Date.now(),
        frame: gameState.replayEvents.length
    };
    
    gameState.replayEvents.push(event);
}

// 开始录制
function startRecording() {
    gameState.isRecording = true;
    gameState.replayEvents = [];
    showNotification('开始录制游戏回放');
    
    // 记录游戏开始事件
    recordGameEvent('game_start', {
        level: gameState.currentLevel,
        timestamp: Date.now(),
        playerName: gameState.playerName
    });
}

// 停止录制
function stopRecording() {
    if (!gameState.isRecording) return;
    
    gameState.isRecording = false;
    
    // 记录游戏结束事件
    recordGameEvent('game_end', {
        level: gameState.currentLevel,
        moveCount: singlePlayerGame.moveCount,
        timestamp: Date.now()
    });
    
    showNotification('停止录制游戏回放');
}

// 保存录制
function saveRecording() {
    if (gameState.replayEvents.length === 0) {
        showNotification('没有可保存的录制内容');
        return;
    }
    
    const recording = {
        id: Date.now(),
        level: gameState.currentLevel,
        timestamp: Date.now(),
        duration: gameState.replayEvents[gameState.replayEvents.length - 1].timestamp - gameState.replayEvents[0].timestamp,
        moveCount: singlePlayerGame.moveCount,
        events: [...gameState.replayEvents],
        playerName: gameState.playerName
    };
    
    gameState.replaySystem.recordings.unshift(recording);
    localStorage.setItem('gameRecordings', JSON.stringify(gameState.replaySystem.recordings));
    
    showNotification('游戏回放已保存');
}

// 切换录制状态
function toggleRecording() {
    if (gameState.isRecording) {
        // 停止录制
        stopRecording();
        document.getElementById('recordButton').textContent = '📹 录制';
        document.getElementById('saveRecordButton').style.display = 'inline-block';
    } else {
        // 开始录制
        startRecording();
        document.getElementById('recordButton').textContent = '⏹️ 停止录制';
        document.getElementById('saveRecordButton').style.display = 'none';
    }
}

// 播放回放
function playRecording(recordingId) {
    const recording = gameState.replaySystem.recordings.find(r => r.id === recordingId);
    if (!recording) return;
    
    gameState.replaySystem.currentRecording = recording;
    gameState.replaySystem.isPlaying = true;
    gameState.replaySystem.currentFrame = 0;
    
    // 显示回放播放器
    document.getElementById('replayList').classList.add('hidden');
    document.getElementById('playerContainer').classList.remove('hidden');
    document.getElementById('replayTitle').textContent = `关卡 ${recording.level} - ${new Date(recording.timestamp).toLocaleString()}`;
    
    // 初始化回放环境
    gameState.currentLevel = recording.level;
    generateMaze(recording.level);
    singlePlayerGame.player.x = 0;
    singlePlayerGame.player.y = 0;
    singlePlayerGame.moveCount = 0;
    singlePlayerGame.hasKey = false;
    singlePlayerGame.gameCompleted = false;
    singlePlayerGame.gameFailed = false;
    draw();
    
    // 开始播放
    if (gameState.replaySystem.playbackInterval) {
        clearInterval(gameState.replaySystem.playbackInterval);
    }
    
    gameState.replaySystem.playbackInterval = setInterval(() => {
        if (!gameState.replaySystem.isPlaying) return;
        
        const currentFrame = gameState.replaySystem.currentFrame;
        const events = recording.events;
        
        if (currentFrame >= events.length) {
            clearInterval(gameState.replaySystem.playbackInterval);
            gameState.replaySystem.playbackInterval = null;
            gameState.replaySystem.isPlaying = false;
            document.getElementById('playBtn').textContent = '▶️ 播放';
            showNotification('回放播放完毕');
            return;
        }
        
        // 处理当前帧事件
        const event = events[currentFrame];
        if (event.type === 'move') {
            const direction = event.data.direction;
            const newX = singlePlayerGame.player.x + (direction === 'right' ? 1 : direction === 'left' ? -1 : 0);
            const newY = singlePlayerGame.player.y + (direction === 'down' ? 1 : direction === 'up' ? -1 : 0);
            
            if (isValidMove(newX, newY)) {
                singlePlayerGame.player.x = newX;
                singlePlayerGame.player.y = newY;
                singlePlayerGame.moveCount++;
                
                if (singlePlayerGame.player.x === singlePlayerGame.maze[0].length - 1 && singlePlayerGame.player.y === singlePlayerGame.maze.length - 1) {
                    singlePlayerGame.gameCompleted = true;
                }
            }
        }
        
        gameState.replaySystem.currentFrame++;
        draw();
    }, 1000 / gameState.replaySystem.playbackSpeed);
    
    showNotification('开始播放回放');
}

// 打开回放模态框
function openReplayModal() {
    // 加载回放列表
    loadReplayList();
    
    // 显示模态框
    document.getElementById('replayModal').classList.remove('hidden');
    document.getElementById('replayModal').style.display = 'flex';
}

// 关闭回放模态框
function closeReplayModal() {
    document.getElementById('replayModal').classList.add('hidden');
    document.getElementById('replayModal').style.display = 'none';
}

// 加载回放列表
function loadReplayList() {
    const replayList = document.getElementById('replayList');
    replayList.innerHTML = '';
    
    if (gameState.replaySystem.recordings.length === 0) {
        replayList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">暂无保存的回放记录</div>';
        return;
    }
    
    gameState.replaySystem.recordings.forEach(recording => {
        const replayItem = document.createElement('div');
        replayItem.className = 'replay-item';
        replayItem.onclick = () => playRecording(recording.id);
        
        replayItem.innerHTML = `
            <div class="replay-item-header">
                <span class="replay-item-title">关卡 ${recording.level}</span>
                <span style="color: #888; font-size: 12px;">${Math.floor(recording.duration / 1000)}秒</span>
            </div>
            <div class="replay-item-meta">
                <span>移动次数: ${recording.moveCount}</span>
                <span>${new Date(recording.timestamp).toLocaleString()}</span>
                <span>${recording.playerName}</span>
            </div>
        `;
        
        replayList.appendChild(replayItem);
    });
}

// 退出播放器
function exitPlayer() {
    document.getElementById('playerContainer').classList.add('hidden');
    document.getElementById('replayList').classList.remove('hidden');
    
    // 停止回放
    if (gameState.replaySystem.isPlaying) {
        togglePlay();
    }
    
    // 清除播放间隔
    if (gameState.replaySystem.playbackInterval) {
        clearInterval(gameState.replaySystem.playbackInterval);
        gameState.replaySystem.playbackInterval = null;
    }
}

// 开始回放播放
function startReplayPlayback() {
    if (gameState.replaySystem.playbackInterval) {
        clearInterval(gameState.replaySystem.playbackInterval);
    }
    
    const recording = gameState.replaySystem.currentRecording;
    if (!recording) return;
    
    const events = recording.events;
    
    gameState.replaySystem.playbackInterval = setInterval(() => {
        if (!gameState.replaySystem.isPlaying) return;
        
        const currentFrame = gameState.replaySystem.currentFrame;
        
        if (currentFrame >= events.length) {
            clearInterval(gameState.replaySystem.playbackInterval);
            gameState.replaySystem.playbackInterval = null;
            gameState.replaySystem.isPlaying = false;
            document.getElementById('playBtn').textContent = '▶️ 播放';
            showNotification('回放播放完毕');
            return;
        }
        
        // 处理当前帧事件
        const event = events[currentFrame];
        if (event.type === 'move') {
            const direction = event.data.direction;
            const newX = singlePlayerGame.player.x + (direction === 'right' ? 1 : direction === 'left' ? -1 : 0);
            const newY = singlePlayerGame.player.y + (direction === 'down' ? 1 : direction === 'up' ? -1 : 0);
            
            if (isValidMove(newX, newY)) {
                singlePlayerGame.player.x = newX;
                singlePlayerGame.player.y = newY;
                singlePlayerGame.moveCount++;
                
                if (singlePlayerGame.player.x === singlePlayerGame.maze[0].length - 1 && singlePlayerGame.player.y === singlePlayerGame.maze.length - 1) {
                    singlePlayerGame.gameCompleted = true;
                }
            }
        }
        
        gameState.replaySystem.currentFrame++;
        draw();
    }, 1000 / gameState.replaySystem.playbackSpeed);
}

// 回放控制函数
function seekBack() {
    // 实现向后快进5秒的逻辑
    showNotification('向后快进5秒');
}

function seekForward() {
    // 实现向前快进5秒的逻辑
    showNotification('向前快进5秒');
}

function togglePlay() {
    gameState.replaySystem.isPlaying = !gameState.replaySystem.isPlaying;
    const playBtn = document.getElementById('playBtn');
    
    if (gameState.replaySystem.isPlaying) {
        playBtn.textContent = '⏸️ 暂停';
        showNotification('继续播放回放');
        // 如果没有播放间隔，重新开始播放
        if (!gameState.replaySystem.playbackInterval) {
            const recording = gameState.replaySystem.currentRecording;
            if (recording) {
                startReplayPlayback();
            }
        }
    } else {
        playBtn.textContent = '▶️ 播放';
        showNotification('暂停播放回放');
    }
}

// 可视化脚本编辑器函数
// 打开可视化脚本编辑器
function openVisualScriptEditor() {
    document.getElementById('visualScriptEditor').classList.remove('hidden');
    document.getElementById('visualScriptEditor').style.display = 'flex';
    
    // 初始化画布
    initScriptCanvas();
}

// 关闭可视化脚本编辑器
function closeVisualScriptEditor() {
    document.getElementById('visualScriptEditor').classList.add('hidden');
    document.getElementById('visualScriptEditor').style.display = 'none';
}

// 初始化脚本画布
function initScriptCanvas() {
    const canvas = document.getElementById('scriptCanvas');
    const ctx = canvas.getContext('2d');
    
    // 设置画布大小
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    
    // 清空画布
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 绘制网格线
    ctx.strokeStyle = 'rgba(76, 175, 80, 0.2)';
    ctx.lineWidth = 1;
    
    const gridSize = 20;
    for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    
    for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
    
    // 绘制所有连接
    drawAllConnections();
}

// 新建脚本
function newScript() {
    if (confirm('确定要新建脚本吗？当前未保存的内容将丢失。')) {
        clearWorkspace();
        document.getElementById('scriptInfo').textContent = '未保存';
    }
}

// 保存脚本
function saveScript() {
    // 收集节点和连接数据
    const nodes = collectNodesData();
    const connections = collectConnectionsData();
    
    const script = {
        id: Date.now(),
        name: prompt('请输入脚本名称:', '新脚本'),
        nodes: nodes,
        connections: connections,
        timestamp: Date.now()
    };
    
    // 保存到localStorage
    const savedScripts = JSON.parse(localStorage.getItem('visualScripts')) || [];
    savedScripts.unshift(script);
    localStorage.setItem('visualScripts', JSON.stringify(savedScripts));
    
    showNotification('脚本已保存');
    document.getElementById('scriptInfo').textContent = script.name;
}

// 加载脚本
function loadScript() {
    const savedScripts = JSON.parse(localStorage.getItem('visualScripts')) || [];
    if (savedScripts.length === 0) {
        showNotification('没有保存的脚本');
        return;
    }
    
    const scriptName = prompt('请输入要加载的脚本名称:');
    if (!scriptName) return;
    
    const script = savedScripts.find(s => s.name === scriptName);
    if (!script) {
        showNotification('找不到指定脚本');
        return;
    }
    
    // 清空当前工作区
    clearWorkspace();
    
    // 加载节点和连接
    loadNodesData(script.nodes);
    loadConnectionsData(script.connections);
    
    document.getElementById('scriptInfo').textContent = script.name;
    showNotification('脚本已加载');
}

// 清空工作区
function clearWorkspace() {
    // 清空节点容器
    document.getElementById('nodesContainer').innerHTML = '';
    
    // 清空连接列表
    connections = [];
    
    // 清空画布
    initScriptCanvas();
    
    // 清空属性面板
    document.getElementById('nodeProperties').innerHTML = '';
    
    document.getElementById('scriptInfo').textContent = '未保存';
    showNotification('工作区已清空');
}

// 收集节点数据
function collectNodesData() {
    const nodes = [];
    const nodeElements = document.querySelectorAll('.node');
    
    nodeElements.forEach(element => {
        const node = {
            id: element.dataset.nodeId,
            type: element.dataset.nodeType,
            x: parseInt(element.style.left),
            y: parseInt(element.style.top),
            title: element.querySelector('.node-title').textContent,
            properties: {}
        };
        nodes.push(node);
    });
    
    return nodes;
}

// 收集连接数据
function collectConnectionsData() {
    return connections;
}

// 加载节点数据
function loadNodesData(nodes) {
    // 简化处理，实际项目中需要根据节点数据创建节点元素
    nodes.forEach(nodeData => {
        createNode(nodeData.type, nodeData.x, nodeData.y, nodeData.id);
    });
}

// 加载连接数据
function loadConnectionsData(loadedConnections) {
    connections = loadedConnections;
    drawAllConnections();
}

// 节点连接功能
let connecting = false;
let startPort = null;
let currentConnection = null;
let connections = [];
let longPressTimer = null;
let longPressThreshold = 500; // 长按阈值（毫秒）
let dragStart = false;

// 绘制连接
function drawConnection(ctx, startX, startY, endX, endY) {
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.bezierCurveTo(startX + 50, startY, endX - 50, endY, endX, endY);
    ctx.strokeStyle = '#4CAF50';
    ctx.lineWidth = 3;
    ctx.stroke();
}

// 绘制所有连接
function drawAllConnections() {
    const canvas = document.getElementById('scriptCanvas');
    const ctx = canvas.getContext('2d');
    
    // 清空画布
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 绘制网格线
    ctx.strokeStyle = 'rgba(76, 175, 80, 0.2)';
    ctx.lineWidth = 1;
    
    const gridSize = 20;
    for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    
    for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
    
    // 绘制所有连接
    connections.forEach(conn => {
        drawConnection(ctx, conn.startX, conn.startY, conn.endX, conn.endY);
    });
    
    // 绘制当前正在创建的连接
    if (connecting && startPort && currentConnection) {
        drawConnection(ctx, startPort.x, startPort.y, currentConnection.endX, currentConnection.endY);
    }
}

// 获取端口的位置
function getPortPosition(portElement) {
    const portRect = portElement.getBoundingClientRect();
    const canvasRect = document.getElementById('scriptCanvas').getBoundingClientRect();
    
    return {
        x: portRect.left - canvasRect.left + portRect.width / 2,
        y: portRect.top - canvasRect.top + portRect.height / 2
    };
}

// 处理端口鼠标按下事件 - 用于开始连接
function handlePortMouseDown(e) {
    e.stopPropagation();
    if (connecting) return;
    const portElement = e.target;
    const portType = portElement.dataset.portType;
    
    if (portType === 'out') {
        longPressTimer = setTimeout(() => {
            startConnection(e);
        }, longPressThreshold);
    }
}

// 处理端口鼠标释放事件
function handlePortMouseUp(e) {
    e.stopPropagation();
    if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
    }
}

// 处理端口鼠标离开事件
function handlePortMouseLeave(e) {
    e.stopPropagation();
    if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
    }
}

// 开始连接
function startConnection(e) {
    const portElement = e.target;
    const portType = portElement.dataset.portType;
    const portId = portElement.dataset.portId;
    const nodeElement = portElement.closest('.node');
    const nodeId = nodeElement.dataset.nodeId;
    
    connecting = true;
    startPort = {
        element: portElement,
        nodeId: nodeId,
        portId: portId,
        type: portType,
        ...getPortPosition(portElement)
    };
    
    currentConnection = {
        startNodeId: nodeId,
        startPortId: portId,
        startX: startPort.x,
        startY: startPort.y,
        endX: startPort.x,
        endY: startPort.y
    };
    
    // 添加鼠标移动事件
    document.addEventListener('mousemove', handleMouseMove);
    // 添加鼠标点击事件
    document.addEventListener('click', handleMouseClick);
}

// 处理端口点击事件
function handlePortClick(e) {
    e.stopPropagation();
    const portElement = e.target;
    const portType = portElement.dataset.portType;
    const portId = portElement.dataset.portId;
    const nodeElement = portElement.closest('.node');
    const nodeId = nodeElement.dataset.nodeId;
    
    if (!connecting) {
        // 开始连接
        if (portType === 'out') {
            connecting = true;
            startPort = {
                element: portElement,
                nodeId: nodeId,
                portId: portId,
                type: portType,
                ...getPortPosition(portElement)
            };
            
            currentConnection = {
                startNodeId: nodeId,
                startPortId: portId,
                startX: startPort.x,
                startY: startPort.y,
                endX: startPort.x,
                endY: startPort.y
            };
            
            // 添加鼠标移动事件
            document.addEventListener('mousemove', handleMouseMove);
            // 添加鼠标点击事件
            document.addEventListener('click', handleMouseClick);
        }
    } else {
        // 结束连接
        if (portType === 'in') {
            // 检查是否连接到同一个节点
            if (nodeId === startPort.nodeId) {
                cancelConnection();
                return;
            }
            
            // 创建连接
            const endPort = {
                element: portElement,
                nodeId: nodeId,
                portId: portId,
                type: portType,
                ...getPortPosition(portElement)
            };
            
            // 添加到连接列表
            const connection = {
                id: Date.now(),
                startNodeId: startPort.nodeId,
                startPortId: startPort.portId,
                endNodeId: endPort.nodeId,
                endPortId: endPort.portId,
                startX: startPort.x,
                startY: startPort.y,
                endX: endPort.x,
                endY: endPort.y
            };
            
            connections.push(connection);
            
            // 绘制连接
            drawAllConnections();
            
            cancelConnection();
        }
    }
}

// 处理鼠标移动
function handleMouseMove(e) {
    if (connecting && startPort) {
        const canvasRect = document.getElementById('scriptCanvas').getBoundingClientRect();
        currentConnection.endX = e.clientX - canvasRect.left;
        currentConnection.endY = e.clientY - canvasRect.top;
        
        // 重新绘制连接
        drawAllConnections();
    }
}

// 处理鼠标点击
function handleMouseClick(e) {
    // 检查是否点击了画布
    if (e.target.id === 'scriptCanvas') {
        cancelConnection();
    }
}

// 取消连接
function cancelConnection() {
    connecting = false;
    startPort = null;
    currentConnection = null;
    
    // 移除事件监听器
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('click', handleMouseClick);
    
    // 重新绘制连接
    drawAllConnections();
}

// 创建节点
function createNode(type, x, y, id = null) {
    const nodeId = id || Date.now();
    const nodeContainer = document.getElementById('nodesContainer');
    
    const node = document.createElement('div');
    node.className = 'node';
    node.dataset.nodeId = nodeId;
    node.dataset.nodeType = type;
    node.style.left = x + 'px';
    node.style.top = y + 'px';
    
    // 设置节点标题
    const typeTitles = {
        'start': '开始',
        'move': '移动',
        'condition': '条件',
        'wait': '等待',
        'end': '结束'
    };
    
    node.innerHTML = `
        <div class="node-header">
            <div class="node-title">${typeTitles[type]}</div>
            <div class="node-type">${type}</div>
        </div>
        <div class="node-ports">
            ${type !== 'start' ? '<div class="port in"><div class="port-dot" data-port-id="in" data-port-type="in"></div><div class="port-label">输入</div></div>' : ''}
            ${type !== 'end' ? '<div class="port out"><div class="port-label">输出</div><div class="port-dot" data-port-id="out" data-port-type="out"></div></div>' : ''}
        </div>
    `;
    
    // 添加端口事件
    const portDots = node.querySelectorAll('.port-dot');
    portDots.forEach(dot => {
        dot.addEventListener('click', handlePortClick);
        dot.addEventListener('mousedown', handlePortMouseDown);
        dot.addEventListener('mouseup', handlePortMouseUp);
        dot.addEventListener('mouseleave', handlePortMouseLeave);
    });
    
    // 添加拖拽功能
    makeNodeDraggable(node);
    
    // 添加点击事件
    node.addEventListener('click', () => selectNode(nodeId));
    
    nodeContainer.appendChild(node);
    
    return node;
}

// 使节点可拖拽
function makeNodeDraggable(node) {
    let isDragging = false;
    let offsetX = 0;
    let offsetY = 0;
    
    node.addEventListener('mousedown', (e) => {
        // 如果点击的是端口，不触发拖拽
        if (e.target.classList.contains('port-dot')) {
            return;
        }
        isDragging = true;
        offsetX = e.clientX - parseInt(node.style.left);
        offsetY = e.clientY - parseInt(node.style.top);
        node.style.zIndex = 100;
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const container = document.querySelector('.editor-workspace');
        const rect = container.getBoundingClientRect();
        
        let x = e.clientX - rect.left - offsetX;
        let y = e.clientY - rect.top - offsetY;
        
        // 限制节点在容器内
        x = Math.max(0, Math.min(x, rect.width - node.offsetWidth));
        y = Math.max(0, Math.min(y, rect.height - node.offsetHeight));
        
        node.style.left = x + 'px';
        node.style.top = y + 'px';
    });
    
    document.addEventListener('mouseup', () => {
        if (isDragging) {
            isDragging = false;
            node.style.zIndex = 10;
        }
    });
}

// 选择节点
function selectNode(nodeId) {
    // 移除所有节点的选中状态
    document.querySelectorAll('.node').forEach(n => {
        n.style.borderColor = '#4CAF50';
    });
    
    // 选中当前节点
    const selectedNode = document.querySelector(`[data-node-id="${nodeId}"]`);
    if (selectedNode) {
        selectedNode.style.borderColor = '#FFD700';
        
        // 显示节点属性
        showNodeProperties(nodeId, selectedNode.dataset.nodeType);
    }
}

// 显示节点属性
function showNodeProperties(nodeId, nodeType) {
    const propertiesPanel = document.getElementById('nodeProperties');
    
    // 根据节点类型显示不同的属性
    let propertiesHTML = '';
    
    switch (nodeType) {
        case 'start':
            propertiesHTML = `
                <div class="property-group">
                    <label for="nodeTitle">节点名称:</label>
                    <input type="text" id="nodeTitle" value="开始">
                </div>
                <div class="property-group">
                    <label for="startDelay">延迟时间 (毫秒):</label>
                    <input type="number" id="startDelay" value="0">
                </div>
            `;
            break;
        case 'move':
            propertiesHTML = `
                <div class="property-group">
                    <label for="nodeTitle">节点名称:</label>
                    <input type="text" id="nodeTitle" value="移动">
                </div>
                <div class="property-group">
                    <label for="moveDirection">方向:</label>
                    <select id="moveDirection">
                        <option value="up">上</option>
                        <option value="down">下</option>
                        <option value="left">左</option>
                        <option value="right">右</option>
                    </select>
                </div>
                <div class="property-group">
                    <label for="moveDistance">距离:</label>
                    <input type="number" id="moveDistance" value="1">
                </div>
            `;
            break;
        case 'condition':
            propertiesHTML = `
                <div class="property-group">
                    <label for="nodeTitle">节点名称:</label>
                    <input type="text" id="nodeTitle" value="条件">
                </div>
                <div class="property-group">
                    <label for="conditionType">条件类型:</label>
                    <select id="conditionType">
                        <option value="wall">前方有墙</option>
                        <option value="trap">前方有陷阱</option>
                        <option value="exit">前方有出口</option>
                    </select>
                </div>
            `;
            break;
        case 'wait':
            propertiesHTML = `
                <div class="property-group">
                    <label for="nodeTitle">节点名称:</label>
                    <input type="text" id="nodeTitle" value="等待">
                </div>
                <div class="property-group">
                    <label for="waitTime">等待时间 (毫秒):</label>
                    <input type="number" id="waitTime" value="1000">
                </div>
            `;
            break;
        case 'end':
            propertiesHTML = `
                <div class="property-group">
                    <label for="nodeTitle">节点名称:</label>
                    <input type="text" id="nodeTitle" value="结束">
                </div>
            `;
            break;
    }
    
    propertiesPanel.innerHTML = propertiesHTML;
}

// 初始化节点拖拽功能
function initNodeDrag() {
    const paletteNodes = document.querySelectorAll('.palette-node');
    
    paletteNodes.forEach(node => {
        node.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('nodeType', node.dataset.nodeType);
        });
    });
    
    const workspace = document.querySelector('.editor-workspace');
    workspace.addEventListener('dragover', (e) => {
        e.preventDefault();
    });
    
    workspace.addEventListener('drop', (e) => {
        e.preventDefault();
        const nodeType = e.dataTransfer.getData('nodeType');
        
        if (nodeType) {
            const rect = workspace.getBoundingClientRect();
            const x = e.clientX - rect.left - 100; // 居中放置
            const y = e.clientY - rect.top - 50;  // 居中放置
            
            createNode(nodeType, x, y);
        }
    });
}

// 页面加载完成后初始化
window.addEventListener('load', () => {
    initNodeDrag();
});

// 控制反转事件
// 修改后的反转控制事件
EventSystem.register({
  id: 'reverse-controls',
  name: '方向混乱',
  description: '控制方向暂时反转!持续时间: 20秒',
  probability: 0.1,  // 10%概率触发
  cooldown: 30000,   // 30秒冷却
  effect: () => {
    const originalHandler = handleSinglePlayerKeyDown;
    
    // 显示提示
    const notification = document.createElement('div');
    notification.className = 'event-notification';
    notification.innerHTML = '<b>方向混乱！</b> 方向控制已暂时反转';
    document.getElementById('event-notifications').appendChild(notification);
    setTimeout(() => notification.remove(), 3000);
    
    // 反转控制状态
    gameState.controlsReversed = true;
    
    // 50秒后自动恢复
    setTimeout(() => {
      gameState.controlsReversed = false;
      const endNotification = document.createElement('div');
      endNotification.className = 'event-notification';
      endNotification.innerHTML = '<b>方向恢复正常</b>';
      document.getElementById('event-notifications').appendChild(endNotification);
      setTimeout(() => endNotification.remove(), 3000);
    }, 20000);

    return () => {
      
      gameState.controlsReversed = false;
    };
  }
});

// 解谜模式状态
gameState.puzzleMode = {
    buttons: [], // 按钮位置数组 [{x, y, id, pressed, color}]
    correctSequence: [], // 正确顺序 [buttonId1, buttonId2, ...]
    currentSequence: [], // 当前玩家按下的顺序
    doorPosition: null, // 大门位置
    doorOpened: false // 大门是否已打开
};
// 随机事件系统

// 解谜模式
function startPuzzleMode() {
    gameState.currentChallenge = 'puzzle';
    gameState.currentLevel = 1;
    showScreen('singlePlayerGame');
    
    // 初始化解谜模式
    initPuzzleMode();
}

// 初始化解谜模式
function initPuzzleMode() {
    // 显示解谜模式UI
    document.getElementById('puzzleInfo').classList.remove('hidden');
    document.getElementById('sequenceDisplay').classList.remove('hidden');
    
    // 重置解谜状态
    gameState.puzzleMode = {
        buttons: [],
        correctSequence: [],
        currentSequence: [],
        doorPosition: null,
        doorOpened: false
    };
    
    // 生成解谜迷宫
    generatePuzzleMaze();
    
    // 更新序列显示
    updateSequenceDisplay();
}


// 生成解谜迷宫
function generatePuzzleMaze() {
    const size = 15;
    singlePlayerGame.maze = Array(size).fill().map(() => Array(size).fill(1));
    
    // 使用Prim算法生成基本迷宫
    const walls = [];
    singlePlayerGame.maze[1][1] = 0;
    walls.push(...getCellWalls(1, 1, singlePlayerGame.maze));
    
    while (walls.length > 0) {
        const wallIndex = Math.floor(Math.random() * walls.length);
        const wall = walls[wallIndex];
        walls.splice(wallIndex, 1);
        
        const opposite = getOppositeCell(wall, singlePlayerGame.maze);
        
        if (opposite.x > 0 && opposite.x < size-1 && 
            opposite.y > 0 && opposite.y < size-1 && 
            singlePlayerGame.maze[opposite.y][opposite.x] === 1) {
            
            singlePlayerGame.maze[wall.y][wall.x] = 0;
            singlePlayerGame.maze[opposite.y][opposite.x] = 0;
            walls.push(...getCellWalls(opposite.x, opposite.y, singlePlayerGame.maze));
        }
    }
    
    // 设置起点和出口
    singlePlayerGame.player = { x: 1, y: 1 };
    singlePlayerGame.exit = { x: size-2, y: size-2 };
    
    // 添加按钮（4-5个按钮）
    const buttonCount = 4 + Math.floor(Math.random() * 2);
    const buttonColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
    
    for (let i = 0; i < buttonCount; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(Math.random() * (size-4)) + 2;
            y = Math.floor(Math.random() * (size-4)) + 2;
            attempts++;
        } while ((singlePlayerGame.maze[y][x] !== 0 || 
                  isNearPlayer(x, y) ||
                  gameState.puzzleMode.buttons.some(b => b.x === x && b.y === y)) && 
                 attempts < 50);
        
        if (attempts < 50) {
            singlePlayerGame.maze[y][x] = 10 + i; // 10-14 表示按钮
            gameState.puzzleMode.buttons.push({
                x, y, 
                id: i,
                pressed: false,
                color: buttonColors[i]
            });
        }
    }
    
    // 设置正确顺序（随机打乱）
    gameState.puzzleMode.correctSequence = [];
    for (let i = 0; i < buttonCount; i++) {
        gameState.puzzleMode.correctSequence.push(i);
    }
    // 随机打乱顺序
    gameState.puzzleMode.correctSequence.sort(() => Math.random() - 0.5);
    
    // 添加大门
    let doorX = singlePlayerGame.exit.x;
    let doorY = singlePlayerGame.exit.y;
    
    // 在出口前放置门
    if (doorX < size-1 && singlePlayerGame.maze[doorY][doorX+1] === 0) {
        doorX++;
    } else if (doorX > 0 && singlePlayerGame.maze[doorY][doorX-1] === 0) {
        doorX--;
    } else if (doorY < size-1 && singlePlayerGame.maze[doorY+1][doorX] === 0) {
        doorY++;
    } else if (doorY > 0 && singlePlayerGame.maze[doorY-1][doorX] === 0) {
        doorY--;
    }
    
    singlePlayerGame.maze[doorY][doorX] = 9; // 9 表示门
    gameState.puzzleMode.doorPosition = {x: doorX, y: doorY};
    
    // 调整画布大小并绘制
    resizeSinglePlayerCanvas();
    drawSinglePlayerMaze();
}

// 检查是否靠近玩家起点
function isNearPlayer(x, y) {
    return Math.abs(x - 1) <= 2 && Math.abs(y - 1) <= 2;
}

// 处理按钮按下
function handleButtonPress(buttonId) {
    const button = gameState.puzzleMode.buttons.find(b => b.id === buttonId);
    if (!button || button.pressed) return;
    
    // 添加到当前序列
    gameState.puzzleMode.currentSequence.push(buttonId);
    
    // 标记按钮为已按下
    button.pressed = true;
    
    // 更新显示
    updateSequenceDisplay();
    
    // 检查序列是否正确
    checkSequence();
    
    // 重新绘制迷宫以显示按下的按钮
    drawSinglePlayerMaze();
}

// 更新序列显示
function updateSequenceDisplay() {
    const display = document.getElementById('sequenceDisplay');
    let sequenceText = '当前顺序: ';
    
    if (gameState.puzzleMode.currentSequence.length === 0) {
        sequenceText += '无';
        display.className = 'sequence-display';
    } else {
        sequenceText += gameState.puzzleMode.currentSequence.map(id => {
            const button = gameState.puzzleMode.buttons.find(b => b.id === id);
            return `<span style="color:${button.color}">●</span>`;
        }).join(' ');
        
        // 检查当前序列是否正确
        const isCorrectSoFar = gameState.puzzleMode.currentSequence.every((id, index) => 
            id === gameState.puzzleMode.correctSequence[index]
        );
        
        if (isCorrectSoFar) {
            display.className = 'sequence-display sequence-correct';
        } else {
            display.className = 'sequence-display sequence-wrong';
        }
    }
    
    display.innerHTML = sequenceText;
}

// 检查序列
function checkSequence() {
    const current = gameState.puzzleMode.currentSequence;
    const correct = gameState.puzzleMode.correctSequence;
    
    // 检查是否完全正确
    if (current.length === correct.length && 
        current.every((id, index) => id === correct[index])) {
        
        // 序列正确，打开大门
        openPuzzleDoor();
    } else if (current.length > 0) {
        // 检查当前部分是否正确
        const isCorrectSoFar = current.every((id, index) => id === correct[index]);
        
        if (!isCorrectSoFar) {
            // 序列错误，重置
            setTimeout(() => {
                resetPuzzleSequence();
                alert('顺序错误！请重新开始。');
            }, 500);
        }
    }
}

// 打开解谜大门
function openPuzzleDoor() {
    gameState.puzzleMode.doorOpened = true;
    
    // 将门变为通路
    singlePlayerGame.maze[gameState.puzzleMode.doorPosition.y][gameState.puzzleMode.doorPosition.x] = 0;
    
    // 显示成功信息
    document.getElementById('sequenceDisplay').innerHTML = 
        '<span style="color:#4CAF50">✓ 序列正确！大门已打开</span>';
    
    // 重新绘制迷宫
    drawSinglePlayerMaze();
    
    alert('恭喜！顺序正确，大门已经打开！');
}

// 重置解谜序列
function resetPuzzleSequence() {
    // 重置所有按钮状态
    gameState.puzzleMode.buttons.forEach(button => {
        button.pressed = false;
    });
    
    // 清空当前序列
    gameState.puzzleMode.currentSequence = [];
    
    // 更新显示
    updateSequenceDisplay();
    
    // 重新绘制迷宫
    drawSinglePlayerMaze();
}

// 修改绘制函数以显示按钮
function drawSinglePlayerMaze() {
    const ctx = singlePlayerGame.ctx;
    ctx.clearRect(0, 0, singlePlayerGame.canvas.width, singlePlayerGame.canvas.height);
    
    // 绘制迷宫（原有逻辑）
    for (let y = 0; y < singlePlayerGame.maze.length; y++) {
        for (let x = 0; x < singlePlayerGame.maze[y].length; x++) {
            const cellValue = singlePlayerGame.maze[y][x];
            let fillStyle = '#111';
            
            switch(cellValue) {
                case 1: fillStyle = '#333'; break; // 墙
                case 2: fillStyle = '#FF0'; break; // 陷阱
                case 3: fillStyle = '#0FF'; break; // 传送门
                case 9: fillStyle = '#8B4513'; break; // 门
                default: 
                    if (cellValue >= 10 && cellValue <= 20) {
                        // 按钮
                        const buttonId = cellValue - 10;
                        const button = gameState.puzzleMode.buttons.find(b => b.id === buttonId);
                        if (button) {
                            fillStyle = button.pressed ? '#666' : button.color;
                        }
                    }
            }
            
            ctx.fillStyle = fillStyle;
            ctx.fillRect(x * singlePlayerGame.cellSize, y * singlePlayerGame.cellSize, 
                        singlePlayerGame.cellSize, singlePlayerGame.cellSize);
            
            // 绘制按钮编号（如果是解谜模式）
            if (cellValue >= 10 && cellValue <= 20) {
                const buttonId = cellValue - 10;
                ctx.fillStyle = '#000';
                ctx.font = 'bold ' + (singlePlayerGame.cellSize/3) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((buttonId + 1).toString(), 
                    x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                    y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2
                );
            }
        }
    }
    
    // 绘制出口和玩家（原有逻辑）
    ctx.fillStyle = '#F00';
    ctx.fillRect(singlePlayerGame.exit.x * singlePlayerGame.cellSize, 
                singlePlayerGame.exit.y * singlePlayerGame.cellSize, 
                singlePlayerGame.cellSize, singlePlayerGame.cellSize);
    
    drawPlayerWithSkin(
        ctx,
        singlePlayerGame.player.x * singlePlayerGame.cellSize,
        singlePlayerGame.player.y * singlePlayerGame.cellSize,
        singlePlayerGame.cellSize
    );
    
    // 绘制玩家名字
    ctx.fillStyle = '#FFF';
    ctx.font = 'bold ' + (singlePlayerGame.cellSize/3) + 'px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    // 绘制文字背景以提高可读性
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    const textWidth = ctx.measureText(gameState.playerName).width;
    ctx.fillRect(
        singlePlayerGame.player.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2 - textWidth/2 - 4,
        singlePlayerGame.player.y * singlePlayerGame.cellSize - 2,
        textWidth + 8,
        singlePlayerGame.cellSize/4 + 4
    );
    // 绘制文字
    ctx.fillStyle = '#FFF';
    ctx.fillText(gameState.playerName, 
        singlePlayerGame.player.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
        singlePlayerGame.player.y * singlePlayerGame.cellSize
    );
    
    // 动态重新绘制路径提示（如果激活）
    if (gameState.showPathHint) {
        const path = findPathToExit(
            singlePlayerGame.maze,
            singlePlayerGame.player.x,
            singlePlayerGame.player.y,
            singlePlayerGame.exit.x,
            singlePlayerGame.exit.y
        );
        if (path) drawPathHint(path);
    }
}



        // 应用UI设置
        function applyUISettings() {
            const settings = gameState.uiSettings;
            
            // 应用控制面板设置 - 处理两个控制面板
            const singlePlayerControls = document.getElementById('singlePlayerControls');
            const multiplayerControls = document.getElementById('multiplayerControls');
            const controlsPanels = [singlePlayerControls, multiplayerControls];
            
            controlsPanels.forEach(controlsPanel => {
                if (controlsPanel) {
                    controlsPanel.classList.toggle('hidden', !settings.showControls);
                    
                    // 设置位置
                    controlsPanel.style.position = 'fixed';
                    controlsPanel.style.left = '';
                    controlsPanel.style.right = '';
                    controlsPanel.style.top = '';
                    controlsPanel.style.bottom = '';
                    
                    if (settings.controlsPosition === 'custom' && settings.customX !== null && settings.customY !== null) {
                        controlsPanel.style.left = settings.customX + 'px';
                        controlsPanel.style.top = settings.customY + 'px';
                        // 启用拖拽功能 - 移动端使用拖拽手柄
                        const dragHandle = controlsPanel.querySelector('.drag-handle');
                        if (dragHandle) {
                            dragHandle.style.display = 'block'; // 显示拖动把手
                            makeDraggable(controlsPanel, dragHandle);
                        }
                    } else {
                        // 移除拖拽功能
                        controlsPanel.removeAttribute('draggable');
                        // 隐藏拖动把手
                        const dragHandle = controlsPanel.querySelector('.drag-handle');
                        if (dragHandle) {
                            dragHandle.style.display = 'none';
                        }
                        // 移除可能的拖拽事件监听器（通过重新创建元素实现）
                        const newPanel = controlsPanel.cloneNode(true);
                        controlsPanel.parentNode.replaceChild(newPanel, controlsPanel);
                        
                        // 重新获取更新后的面板元素
                        const updatedPanel = newPanel;
                        if (updatedPanel) {
                            switch(settings.controlsPosition) {
                                case 'bottom-left':
                                    updatedPanel.style.left = '20px';
                                    updatedPanel.style.bottom = '20px';
                                    break;
                                case 'bottom-right':
                                    updatedPanel.style.right = '20px';
                                    updatedPanel.style.bottom = '20px';
                                    break;
                                case 'top-left':
                                    updatedPanel.style.left = '20px';
                                    updatedPanel.style.top = '20px';
                                break;
                            case 'top-right':
                                updatedPanel.style.right = '20px';
                                updatedPanel.style.top = '20px';
                                break;
                        }
                    }
                }
            }
            
            // 应用游戏信息设置
            const gameInfo = document.getElementById('gameInfo');
            const multiplayerGameInfo = document.getElementById('multiplayerGameInfo');
            
            if (gameInfo) {
                gameInfo.style.display = settings.showGameInfo ? 'flex' : 'none';
                // 隐藏/显示各个信息项
                const infoItems = ['levelDisplay', 'timeDisplay', 'moveCount', 'keyStatus'];
                infoItems.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = settings[`show${id.charAt(0).toUpperCase() + id.slice(1).replace('Display', 'Info').replace('Count', 'Info')}`] ? 'flex' : 'none';
                    }
                });
            }
            
            if (multiplayerGameInfo) {
                multiplayerGameInfo.style.display = settings.showGameInfo ? 'flex' : 'none';
                // 隐藏/显示各个信息项
                const multiplayerInfoItems = ['multiplayerRoomCode', 'multiplayerTimeDisplay', 'multiplayerMoveCount', 'multiplayerPlayerCount'];
                multiplayerInfoItems.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = settings[`show${id.includes('Room') ? 'Room' : id.includes('Time') ? 'Time' : id.includes('Move') ? 'Move' : 'Room'}Info`] ? 'flex' : 'none';
                    }
                });
            }
            
            // 应用玩家列表设置
            const playerList = document.getElementById('playerList');
            if (playerList) {
                playerList.style.display = gameState.uiSettings.showPlayerList ? 'block' : 'none';
            }
            })}
        function showScreen(screenId) {
            // 检查是否需要显示存档提示
            if (gameState.currentScreen === 'singlePlayerGame' && screenId !== 'singlePlayerComplete') {
                // 只在玩家有进度时提示
                if (singlePlayerGame.moveCount > 0) {
                    const shouldSave = confirm('你当前有未保存的进度，是否保存？');
                    if (shouldSave) {
                        // 让玩家选择存档槽
                        const slotChoice = prompt('请选择存档位置 (1-3):');
                        const slot = parseInt(slotChoice) - 1;
                        if (!isNaN(slot) && slot >= 0 && slot <= 2) {
                            saveGame(slot);
                        } else {
                            // 如果选择无效，默认保存到第一个位置
                            alert("选择无效，将保存至第一个存档槽")
                            saveGame(0);
                        }
                    }
                }
            }
            
            // 隐藏所有屏幕
            const screens = [
                'mainMenu', 'singlePlayerLevelSelect', 'singlePlayerGame', 
                'singlePlayerComplete', 'multiplayerSetup', 'multiplayerGame',
                'achievementsScreen', 'moreChallengesScreen', 'statisticsScreen',
                'historyUpdates', 'dailyChallengeScreen'
            ];
            
            screens.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.classList.add('hidden');
                }
            });
            
            // 显示请求的屏幕
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.remove('hidden');
            }
            
            gameState.currentScreen = screenId;
            
            // 执行屏幕特定的初始化
            switch(screenId) {
                case 'singlePlayerLevelSelect':
                    generateLevelButtons();
                    break;
                case 'singlePlayerGame':
                initSinglePlayerGame(gameState.isLoadingSave || false);
                EventSystem.init();
                    startPlayTimeTimer(); // 开始游戏时长计时
                    break;
                case 'multiplayerSetup':
                    document.getElementById('playerName').value = gameState.playerName;
                    break;
                case 'multiplayerGame':
                    startPlayTimeTimer(); // 开始游戏时长计时
                    break;
                case 'moreChallengesScreen':
                    updateChallengesStats();
                    break;
                case 'achievementsScreen':
                    updateAchievementProgress();
                    break;
                case 'statisticsScreen':
                    updateStatistics();
                    break;
                case 'dailyChallengeScreen':
                    initDailyChallenge();
                    break;
                case 'mainMenu':
                    stopPlayTimeTimer(); // 停止游戏时长计时
                    updatePlayTimeDisplay(); // 更新游戏时长显示
                    break;
            }

            // 显示/隐藏控制面板
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const singlePlayerControls = document.getElementById('singlePlayerControls');
            const multiplayerControls = document.getElementById('multiplayerControls');
            
            if (singlePlayerControls) {
                singlePlayerControls.classList.toggle('hidden', screenId !== 'singlePlayerGame' || !isMobile);
            }
            if (multiplayerControls) {
                multiplayerControls.classList.toggle('hidden', screenId !== 'multiplayerGame' || !isMobile);
            }
            
            // 应用UI设置
            applyUISettings();
        }     
        
        // 每日挑战系统
        const CHALLENGE_TYPES = {
            SPEED: {
                id: 'speed',
                name: '速度挑战',
                icon: '⚡',
                description: '在限定时间内完成关卡',
                rewards: { coins: 12, stars: 4 }
            },
            STEPS: {
                id: 'steps',
                name: '步数挑战',
                icon: '👣',
                description: '用最少的步数完成关卡',
                rewards: { coins: 12, stars: 4 }
            },
            NO_TRAPS: {
                id: 'no_traps',
                name: '无陷阱挑战',
                icon: '🛡️',
                description: '不触发任何陷阱完成关卡',
                rewards: { coins: 12, stars: 4 }
            },
        };
        
        function getTodayDateString() {
            const now = new Date();
            return now.toISOString().split('T')[0];
        }
        
        function generateDailyChallenge() {
            const today = getTodayDateString();
            const seed = today.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            const types = Object.values(CHALLENGE_TYPES);
            const typeIndex = seed % types.length;
            const challengeType = types[typeIndex];
            
            const level = (seed % 20) + 1;
            let challengeData = {
                level: level,
                target: 0,
                description: ''
            };
            
            switch(challengeType.id) {
                case 'speed':
                    const timeLimit = 30 + (seed % 60);
                    challengeData.target = timeLimit;
                    challengeData.description = `在${timeLimit}秒内完成第${level}关`;
                    break;
                case 'steps':
                    const maxSteps = 20 + (seed % 30);
                    challengeData.target = maxSteps;
                    challengeData.description = `用不超过${maxSteps}步完成第${level}关`;
                    break;
                case 'no_traps':
                    challengeData.target = 0;
                    challengeData.description = `在不触发任何陷阱的情况下完成第${level}关`;
                    break;
                case 'collection':
                    challengeData.target = 5 + (seed % 10);
                    challengeData.description = `收集至少${challengeData.target}个金币完成第${level}关`;
                    break;
            }
            
            return {
                currentDate: today,
                challengeType: challengeType,
                challengeData: challengeData,
                isCompleted: false,
                isClaimed: false,
                progress: 0,
                history: []
            };
        }
        
        function initDailyChallenge() {
            const today = getTodayDateString();
            
            if (gameState.dailyChallenge.currentDate !== today) {
                gameState.dailyChallenge = generateDailyChallenge();
                saveDailyChallenge();
            }
            
            updateDailyChallengeUI();
            startChallengeCountdown();
        }
        
        function updateDailyChallengeUI() {
            const challenge = gameState.dailyChallenge;
            
            document.getElementById('challengeDate').textContent = 
                new Date(challenge.currentDate).toLocaleDateString('zh-CN', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            
            document.getElementById('challengeIcon').textContent = challenge.challengeType.icon;
            document.getElementById('challengeTitle').textContent = challenge.challengeType.name;
            document.getElementById('challengeDescription').textContent = challenge.challengeData.description;
            document.getElementById('rewardCoins').textContent = challenge.challengeType.rewards.coins;
            document.getElementById('rewardStars').textContent = challenge.challengeType.rewards.stars;
            
            const statusElement = document.getElementById('challengeStatus');
            if (challenge.isCompleted) {
                if (challenge.isClaimed) {
                    statusElement.innerHTML = '<span class="status-completed">已领取</span>';
                } else {
                    statusElement.innerHTML = '<span class="status-completed">已完成</span>';
                }
            } else {
                statusElement.innerHTML = '<span class="status-pending">未完成</span>';
            }
            
            const goalsElement = document.getElementById('challengeGoals');
            goalsElement.innerHTML = '';
            const goals = getChallengeGoals(challenge);
            goals.forEach(goal => {
                const li = document.createElement('li');
                li.textContent = goal;
                goalsElement.appendChild(li);
            });
            
            const progressSection = document.getElementById('challengeProgressSection');
            const startBtn = document.getElementById('startChallengeBtn');
            const claimBtn = document.getElementById('claimRewardBtn');
            
            if (challenge.isCompleted) {
                progressSection.style.display = 'block';
                document.getElementById('progressFill').style.width = '100%';
                document.getElementById('progressText').textContent = '挑战完成！';
                
                if (challenge.isClaimed) {
                    startBtn.style.display = 'none';
                    claimBtn.style.display = 'none';
                } else {
                    startBtn.style.display = 'none';
                    claimBtn.style.display = 'block';
                }
            } else {
                progressSection.style.display = 'none';
                startBtn.style.display = 'block';
                claimBtn.style.display = 'none';
            }
            
            updateChallengeHistory();
        }
        
        function getChallengeGoals(challenge) {
            const goals = [];
            goals.push(`完成第${challenge.challengeData.level}关`);
            
            switch(challenge.challengeType.id) {
                case 'speed':
                    goals.push(`在${challenge.challengeData.target}秒内完成`);
                    break;
                case 'steps':
                    goals.push(`使用步数不超过${challenge.challengeData.target}步`);
                    break;
                case 'no_traps':
                    goals.push('不触发任何陷阱');
                    break;
                case 'collection':
                    goals.push(`收集至少${challenge.challengeData.target}个金币`);
                    break;
            }
            
            return goals;
        }
        
        function startChallengeCountdown() {
            updateCountdown();
            setInterval(updateCountdown, 1000);
        }
        
        function updateCountdown() {
            const now = new Date();
            const tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(0, 0, 0, 0);
            
            const diff = tomorrow - now;
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            
            document.getElementById('challengeCountdown').textContent = 
                `距离刷新: ${hours}小时 ${minutes}分钟 ${seconds}秒`;
        }
        
        function startDailyChallenge() {
            const challenge = gameState.dailyChallenge;
            gameState.currentLevel = challenge.challengeData.level;
            gameState.currentChallenge = 'daily';
            showScreen('singlePlayerGame');
        }
        
        function checkDailyChallengeCompletion() {
            if (gameState.currentChallenge !== 'daily') return;
            
            const challenge = gameState.dailyChallenge;
            const game = singlePlayerGame;
            
            let completed = false;
            
            switch(challenge.challengeType.id) {
                case 'speed':
                    const timeUsed = (Date.now() - game.startTime) / 1000;
                    completed = timeUsed <= challenge.challengeData.target;
                    break;
                case 'steps':
                    completed = game.moveCount <= challenge.challengeData.target;
                    break;
                case 'no_traps':
                    completed = game.trapHits === 0;
                    break;
                case 'collection':
                    completed = game.coinsCollected >= challenge.challengeData.target;
                    break;
            }
            
            if (completed) {
                challenge.isCompleted = true;
                challenge.history.push({
                    date: new Date().toISOString(),
                    result: 'completed',
                    type: challenge.challengeType.id
                });
                saveDailyChallenge();
                showNotification('🎉 每日挑战完成！', 3000);
            }
        }
        
        function claimDailyReward() {
            const challenge = gameState.dailyChallenge;
            
            if (!challenge.isCompleted || challenge.isClaimed) {
                showNotification('无法领取奖励', 2000);
                return;
            }
            
            gameState.playerData.coins += challenge.challengeType.rewards.coins;
            gameState.coins += challenge.challengeType.rewards.coins;
            challenge.isClaimed = true;
            
            saveDailyChallenge();
            saveGame();
            updateDailyChallengeUI();
            
            showNotification(`🎁 已领取 ${challenge.challengeType.rewards.coins} 金币和 ${challenge.challengeType.rewards.stars} 星星！`, 3000);
        }
        
        function updateChallengeHistory() {
            const historyContainer = document.getElementById('challengeHistory');
            const history = gameState.dailyChallenge.history;
            
            if (history.length === 0) {
                historyContainer.innerHTML = '<p style="color: #ccc; text-align: center;">暂无历史记录</p>';
                return;
            }
            
            historyContainer.innerHTML = '';
            history.slice(-7).reverse().forEach(record => {
                const item = document.createElement('div');
                item.className = `history-item ${record.result}`;
                
                const date = new Date(record.date);
                const dateStr = date.toLocaleDateString('zh-CN', {
                    month: 'short',
                    day: 'numeric'
                });
                
                const typeInfo = CHALLENGE_TYPES[record.type.toUpperCase()] || { name: '未知挑战' };
                const resultText = record.result === 'completed' ? '已完成' : '失败';
                
                item.innerHTML = `
                    <span class="history-date">${dateStr} - ${typeInfo.name}</span>
                    <span class="history-result ${record.result}">${resultText}</span>
                `;
                
                historyContainer.appendChild(item);
            });
        }
        
        function saveDailyChallenge() {
            localStorage.setItem('dailyChallenge', JSON.stringify(gameState.dailyChallenge));
        }
        
        // 游戏时长统计相关函数
        let playTimeTimer = null; // 游戏时长计时器

        // 启动游戏时长计时
        function startPlayTimeTimer() {
            if (playTimeTimer) { clearInterval(playTimeTimer); }
            gameState.sessionStartTime = Date.now();
            playTimeTimer = setInterval(() => {
                const now = Date.now();
                const sessionTime = now - gameState.sessionStartTime;
                gameState.totalPlayTime += sessionTime;
                gameState.sessionStartTime = now;
                if (now - gameState.lastSavedTime > 60000) { // 每分钟保存一次
                    localStorage.setItem('totalPlayTime', gameState.totalPlayTime.toString());
                    gameState.lastSavedTime = now;
                }
                updatePlayTimeDisplay();
            }, 1000);
        }

        // 停止游戏时长计时
        function stopPlayTimeTimer() {
            if (playTimeTimer) { 
                clearInterval(playTimeTimer); 
                playTimeTimer = null;
            }
            const now = Date.now();
            const sessionTime = now - gameState.sessionStartTime;
            gameState.totalPlayTime += sessionTime;
            localStorage.setItem('totalPlayTime', gameState.totalPlayTime.toString());
            gameState.lastSavedTime = now;
        }

        // 更新游戏时长显示
        function updatePlayTimeDisplay() {
            const playTimeElement = document.getElementById('playTimeDisplay');
            if (playTimeElement) {
                const minutes = Math.floor(gameState.totalPlayTime / (1000 * 60));
                const hours = Math.floor(minutes / 60);
                const days = Math.floor(hours / 24);
                if (days > 0) {
                    playTimeElement.textContent = `游戏时长: ${days}天 ${hours % 24}小时 ${minutes % 60}分钟`;
                } else if (hours > 0) {
                    playTimeElement.textContent = `游戏时长: ${hours}小时 ${minutes % 60}分钟`;
                } else {
                    playTimeElement.textContent = `游戏时长: ${minutes}分钟`;
                }
            }
        }

        // 聊天系统函数
        // 打开聊天模态框
        function openChatModal() {
            const chatModal = document.getElementById('chatModal');
            if (chatModal) {
                chatModal.style.display = 'flex';
            }
        }
        
        // 关闭聊天模态框
        function closeChatModal() {
            const chatModal = document.getElementById('chatModal');
            if (chatModal) {
                chatModal.style.display = 'none';
            }
        }
        
        function sendChatMessage() {
            // 检查两个输入框
            const messageInput1 = document.getElementById('chatInput');
            const messageInput2 = document.getElementById('chatInputModal');
            
            let message = '';
            let sourceInput = null;
            
            // 检查两个输入框，获取非空值和对应的输入框
            if (messageInput1 && messageInput1.value.trim()) {
                message = messageInput1.value.trim();
                sourceInput = messageInput1;
            } else if (messageInput2 && messageInput2.value.trim()) {
                message = messageInput2.value.trim();
                sourceInput = messageInput2;
            }
            
            if (message) {
                // 使用本地存储保存当前玩家的脏话计数和禁言时间，确保只影响当前玩家
                const now = Date.now();
                
                // 获取本地存储的禁言时间
                const localMuteEndTime = parseInt(localStorage.getItem('localMuteEndTime')) || 0;
                
                // 检查玩家是否处于禁言状态
                if (localMuteEndTime > now) {
                    const remainingTime = Math.ceil((localMuteEndTime - now) / 1000 / 60); // 转换为分钟
                    addChatMessage('系统', `您已被禁言，剩余 ${remainingTime} 分钟`, '#FF5252');
                    if (sourceInput) {
                        sourceInput.value = '';
                    }
                    return;
                }
                
                // 脏话检测和过滤
                // 脏话列表，包含中英文常见脏话
                const profanityList = [
                    // 中文脏话
                    '傻逼', '操你妈', '草泥马', '去死', '垃圾', '废物', '蠢货',
                    '脑残', '智障', '二百五', '王八蛋', '龟儿子', '杂种', '畜生',
                    '禽兽', '色狼', '变态', '婊子', '贱人', '傻屌', '妈蛋', '滚蛋',
                    '我操你妈','我草泥马','自杀','紫砂','毒品','冰糖','神经病','圣经并',
                    '杜平','毒瓶',
                    // 英文脏话
                    'fuck', 'shit', 'damn', 'bitch', 'asshole', 'dick', 'pussy',
                    'cunt', 'bastard', 'nigger', 'nigga', 'faggot', 'dyke', 'retard',
                    'whore', 'slut', 'douche', 'ass', 'shithead','sb','sbm','wcnm','fw',
                    'bt','die'
                ];
                
                // 检测文本中是否包含脏话
                function containsProfanity(text) {
                    const lowercaseText = text.toLowerCase();
                    return profanityList.some(profanity => 
                        lowercaseText.includes(profanity.toLowerCase())
                    );
                }
                
                // 过滤文本中的脏话，替换为星号
                function filterProfanity(text) {
                    let filteredText = text;
                    profanityList.forEach(profanity => {
                        const regex = new RegExp(profanity, 'gi');
                        filteredText = filteredText.replace(regex, '*'.repeat(profanity.length));
                    });
                    return filteredText;
                }
                
                // 检查消息是否包含脏话
                const hasProfanity = containsProfanity(message);
                if (hasProfanity) {
                    // 获取本地存储的脏话计数
                    let localProfanityCount = parseInt(localStorage.getItem('localProfanityCount')) || 0;
                    
                    // 增加脏话计数
                    localProfanityCount++;
                    
                    // 过滤脏话
                    message = filterProfanity(message);
                    
                    // 显示警告消息，包含当前脏话次数
                    addChatMessage('系统', `您的消息中包含不文明用语，已自动过滤。脏话次数: ${localProfanityCount}/10`, '#FF5252');
                    
                    // 检查是否达到禁言条件
                    if (localProfanityCount >= 10) {
                        // 设置禁言时间：5分钟
                        const newMuteEndTime = Date.now() + 5 * 60 * 1000;
                        // 保存禁言时间到本地存储
                        localStorage.setItem('localMuteEndTime', newMuteEndTime.toString());
                        // 重置脏话计数
                        localStorage.setItem('localProfanityCount', '0');
                        // 显示禁言消息
                        addChatMessage('系统', '您已累计10次使用不文明用语，已被禁言5分钟', '#FF5252');
                        // 清空输入框
                        if (sourceInput) {
                            sourceInput.value = '';
                        }
                        return;
                    }
                    
                    // 保存脏话计数到本地存储
                    localStorage.setItem('localProfanityCount', localProfanityCount.toString());
                }
                
                // 开发者命令处理
                if (message.startsWith('kick ')) {
                    // 踢人命令：kick {玩家名}
                    const playerName = message.substring(5).trim();
                    if (playerName && gameState.multiplayer && gameState.multiplayer.players) {
                        // 查找玩家
                        const playerId = Object.keys(gameState.multiplayer.players).find(id => 
                            gameState.multiplayer.players[id].name === playerName
                        );
                        if (playerId) {
                            // 显示踢出玩家界面
                            showKickPlayerModal();
                        } else {
                            addChatMessage('系统', `未找到玩家: ${playerName}`, '#FF5252');
                        }
                    }
                    
                    // 清空输入框
                    if (sourceInput) {
                        sourceInput.value = '';
                    }
                    return;
                } else if (message.startsWith('playmusic ')) {
                    // 播放音乐命令：支持两种方式
                    // 1. playmusic url [URL] - 播放指定URL的音乐
                    // 2. playmusic - 打开文件选择对话框让用户选择音乐文件
                    const parts = message.split(' ');
                    if (parts.length > 1 && parts[1] === 'url' && parts[2]) {
                        // 播放指定URL的音乐
                        const musicUrl = parts.slice(2).join(' ');
                        
                        // 播放音乐
                        const audio = document.getElementById('gameAudio');
                        if (audio) {
                            audio.src = musicUrl;
                            audio.play().catch(error => {
                                console.error('播放音乐失败:', error);
                                addChatMessage('系统', '播放音乐失败，可能是URL无效或浏览器限制', '#FF5252');
                            });
                            addChatMessage('系统', `背景音乐已开始播放: ${musicUrl}`, '#4CAF50');
                        } else {
                            addChatMessage('系统', '未找到音频元素', '#FF5252');
                        }
                        
                        // 广播给其他玩家
                        if (gameState.multiplayer && gameState.multiplayer.connections) {
                            const playerName = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId]?.name || '玩家';
                            const musicMessage = {
                                type: 'music-command',
                                command: 'play',
                                url: musicUrl
                            };
                            Object.values(gameState.multiplayer.connections).forEach(conn => {
                                if (conn.send) {
                                    conn.send(musicMessage);
                                }
                            });
                        }
                    } else {
                        // 打开文件选择对话框让用户选择音乐文件
                        const musicFileInput = document.getElementById('musicFileInput');
                        if (musicFileInput) {
                            // 触发文件选择对话框
                            musicFileInput.click();
                        } else {
                            addChatMessage('系统', '未找到音乐文件输入元素', '#FF5252');
                        }
                    }
                    
                    // 清空输入框
                    if (sourceInput) {
                        sourceInput.value = '';
                    }
                    return;
                }
                
                // 音乐文件选择处理函数
                function handleMusicFileSelect(event) {
                    const file = event.target.files[0];
                    if (file) {
                        const audio = document.getElementById('gameAudio');
                        const fileURL = URL.createObjectURL(file);
                        
                        // 更新音频元素的src
                        audio.src = fileURL;
                        
                        // 将音频文件转换为Base64
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const base64AudioData = e.target.result;
                            
                            // 尝试播放音乐
                            audio.play()
                                .then(() => {
                                    // 播放成功
                                    addChatMessage('系统', `背景音乐已开始播放: ${file.name}`, '#4CAF50');
                                    
                                    // 广播给其他玩家
                                    if (gameState.multiplayer && gameState.multiplayer.connections) {
                                        const playerName = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId]?.name || '玩家';
                                        const musicNotification = {
                                            type: 'music-command',
                                            command: 'play',
                                            audioData: base64AudioData, // 发送Base64音频数据
                                            fileName: file.name
                                        };
                                        Object.values(gameState.multiplayer.connections).forEach(conn => {
                                            if (conn.send) {
                                                conn.send(musicNotification);
                                            }
                                        });
                                    }
                                })
                                .catch(error => {
                                    console.error('播放音乐失败:', error);
                                    // 播放失败，显示确认弹窗（传递Base64数据）
                                    showMusicPlayConfirmModal(fileURL, base64AudioData);
                                });
                        };
                        reader.readAsDataURL(file);
                    }
                }
                
                if (message === 'stop') {
                    // 停止音乐命令：停止播放背景音乐
                    const audio = document.getElementById('gameAudio');
                    if (audio) {
                        audio.pause();
                        audio.currentTime = 0;
                        addChatMessage('系统', '背景音乐已停止', '#4CAF50');
                    } else {
                        addChatMessage('系统', '未找到音频元素', '#FF5252');
                    }
                    
                    // 通知其他玩家音乐已停止
                    if (gameState.multiplayer && gameState.multiplayer.connections) {
                        const playerName = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId]?.name || '玩家';
                        const stopNotification = {
                            type: 'chat-message',
                            from: gameState.multiplayer.currentPlayerId,
                            message: `[音乐] ${playerName} 已停止播放音乐`,
                            color: '#FFD700'
                        };
                        Object.values(gameState.multiplayer.connections).forEach(conn => {
                            if (conn.send) {
                                conn.send(stopNotification);
                                // 发送音乐停止命令
                                conn.send({
                                    type: 'music-command',
                                    command: 'stop'
                                });
                            }
                        });
                    }
                    
                    // 清空输入框
                    if (sourceInput) {
                        sourceInput.value = '';
                    }
                    return;
                } else if (message === 'help') {
                    // 帮助命令：显示所有可用指令
                    const helpMessage = `可用指令列表：\n` +
                        `• kick {玩家名} - 踢出指定玩家\n` +
                        `• playerlist - 显示当前房间玩家列表\n` +
                        `• kickall - 踢出除房主外的所有玩家\n` +
                        `• chatcolor - 打开聊天颜色选择框\n` +
                        `• playmusic url {音乐URL} - 播放指定URL的背景音乐并分享给其他玩家\n` +
                        `• playmusic - 选择本地音乐文件播放（仅本地）\n` +
                        `• stop - 停止播放背景音乐\n` +
                        `• help - 显示此帮助信息`;
                    addChatMessage('系统', helpMessage, '#4CAF50');
                    
                    // 清空输入框
                    if (sourceInput) {
                        sourceInput.value = '';
                    }
                    return;
                } else if (message === 'playerlist') {
                    // 玩家列表命令：显示当前房间的玩家列表
                    if (gameState.multiplayer && gameState.multiplayer.players) {
                        let playerList = '当前房间玩家列表：\n';
                        Object.entries(gameState.multiplayer.players).forEach(([id, player]) => {
                            const hostMark = player.isHost ? ' [房主]' : '';
                            playerList += `- ${player.name}${hostMark} (ID: ${id})\n`;
                        });
                        addChatMessage('系统', playerList, '#4CAF50');
                    } else {
                        addChatMessage('系统', '未找到玩家列表数据', '#FF5252');
                    }
                    
                    // 清空输入框
                    if (sourceInput) {
                        sourceInput.value = '';
                    }
                    return;
                } else if (message === 'kickall') {
                    // 踢出所有玩家命令：踢出除房主外的所有玩家
                    if (gameState.multiplayer && gameState.multiplayer.players) {
                        const currentPlayerId = gameState.multiplayer.currentPlayerId;
                        const currentPlayer = gameState.multiplayer.players[currentPlayerId];
                        
                        if (currentPlayer && currentPlayer.isHost) {
                            // 遍历所有玩家，踢出非房主玩家
                            let kickedCount = 0;
                            Object.entries(gameState.multiplayer.players).forEach(([id, player]) => {
                                if (id !== currentPlayerId && !player.isHost) {
                                    // 发送踢人消息
                                    const kickMessage = {
                                        type: 'kick-player',
                                        playerId: id
                                    };
                                    
                                    if (gameState.multiplayer.connections && gameState.multiplayer.connections[id]) {
                                        gameState.multiplayer.connections[id].send(kickMessage);
                                        gameState.multiplayer.connections[id].close();
                                    }
                                    
                                    // 从本地玩家列表中移除
                                    delete gameState.multiplayer.players[id];
                                    delete gameState.multiplayer.connections[id];
                                    
                                    kickedCount++;
                                }
                            });
                            
                            // 更新玩家列表显示
                            updatePlayerList();
                            
                            // 显示系统消息
                            addChatMessage('系统', `已踢出 ${kickedCount} 名玩家`, '#FF5252');
                        } else {
                            addChatMessage('系统', '只有房主可以使用此命令', '#FF5252');
                        }
                    } else {
                        addChatMessage('系统', '未找到玩家列表数据', '#FF5252');
                    }
                    
                    // 清空输入框
                    if (sourceInput) {
                        sourceInput.value = '';
                    }
                    return;
                } else if (message === 'chatcolor') {
                    // 聊天颜色命令：打开颜色选择框
                    // 创建一个模态对话框来显示颜色选择器，兼容手机端
                    const colorModal = document.createElement('div');
                    colorModal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; color: white;`;
                    
                    const modalContent = document.createElement('div');
                    modalContent.style.cssText = `background: linear-gradient(135deg, #1a1a2e, #16213e); padding: 30px; border-radius: 15px; text-align: center; box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);`;
                    
                    const title = document.createElement('h3');
                    title.textContent = '选择聊天颜色';
                    title.style.marginBottom = '20px';
                    title.style.color = '#4CAF50';
                    
                    const colorPicker = document.createElement('input');
                    colorPicker.type = 'color';
                    colorPicker.value = gameState.chatColor || '#4CAF50';
                    colorPicker.style.cssText = `width: 100px; height: 100px; border: none; border-radius: 10px; cursor: pointer; margin: 20px 0; box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);`;
                    
                    const confirmBtn = document.createElement('button');
                    confirmBtn.textContent = '确认';
                    confirmBtn.style.cssText = `background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; margin: 10px; transition: all 0.3s;`;
                    
                    confirmBtn.onclick = function() {
                        gameState.chatColor = colorPicker.value;
                        localStorage.setItem('chatColor', gameState.chatColor);
                        addChatMessage('系统', `聊天颜色已设置为 ${gameState.chatColor}`, '#4CAF50');
                        document.body.removeChild(colorModal);
                    };
                    
                    const cancelBtn = document.createElement('button');
                    cancelBtn.textContent = '取消';
                    cancelBtn.style.cssText = `background: linear-gradient(135deg, #f44336, #d32f2f); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; margin: 10px; transition: all 0.3s;`;
                    
                    cancelBtn.onclick = function() {
                        document.body.removeChild(colorModal);
                    };
                    
                    // 添加事件监听器，点击模态框外部关闭
                    colorModal.onclick = function(e) {
                        if (e.target === colorModal) {
                            document.body.removeChild(colorModal);
                        }
                    };
                    
                    // 组装模态框
                    modalContent.appendChild(title);
                    modalContent.appendChild(colorPicker);
                    modalContent.appendChild(confirmBtn);
                    modalContent.appendChild(cancelBtn);
                    colorModal.appendChild(modalContent);
                    
                    // 添加到DOM
                    document.body.appendChild(colorModal);
                    
                    // 清空输入框
                    if (sourceInput) {
                        sourceInput.value = '';
                    }
                    return;
                }
                
                // 检查是否处于多人游戏模式
                if (gameState.currentScreen === 'multiplayerGame' && gameState.multiplayer) {
                    // 获取当前玩家信息
                    const player = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
                    
                    // 生成消息ID
                    const messageId = Date.now() + Math.random().toString(36).substr(2, 9);
                    
                    // 向所有玩家发送消息
                    const chatMessage = {
                        type: 'chat-message',
                        from: gameState.multiplayer.currentPlayerId,
                        message: message,
                        color: gameState.chatColor || (player ? player.color : '#4CAF50'),
                        messageId: messageId
                    };
                    
                    // 发送给所有连接的玩家
                    if (gameState.multiplayer.connections) {
                        Object.values(gameState.multiplayer.connections).forEach(conn => {
                            if (conn.send) {
                                conn.send(chatMessage);
                            }
                        });
                    }
                    
                    // 自己也显示消息
                    if (player) {
                        addChatMessage(player.name, message, gameState.chatColor || player.color, null, messageId);
                    }
                } else {
                    // 单人游戏模式下只显示自己的消息
                    addChatMessage('我', message, gameState.chatColor || '#4CAF50');
                }
                
                // 只清空发送消息的输入框
                if (sourceInput) {
                    sourceInput.value = '';
                }
            }
        }

        // 语音聊天相关变量
        const MAX_RECORDING_DURATION = 60; // 最大录制时长（秒）
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let isPaused = false;
        let recordingStartTime = 0;
        let recordingTimer = null;
        let autoStopTimer = null;
        let recordingElapsed = 0; // 录制已过去的时间（秒）
        
        // 语音播放状态管理
        let currentAudio = null;
        let currentPlayingButton = null;
        let isPlaying = false;
        let playbackTimer = null; // 播放进度定时器
        
        // 音乐播放确认相关变量
        let musicPlayTimer = null;
        let musicPlayCountdown = 10;
        let pendingMusicUrl = null;
        let pendingMusicData = null; // 待发送的Base64音乐数据
        
        // 语音录制切换函数
        function toggleVoiceRecording() {
            if (isRecording) {
                stopVoiceRecording();
            } else {
                startVoiceRecording();
            }
        }

        // 初始化语音识别
        function initSpeechRecognition() {
            // 检查浏览器支持
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.error('当前浏览器不支持语音转文字功能');
                return null;
            }

            // 创建语音识别实例
            const recognition = new SpeechRecognition();
            recognition.continuous = true; // 持续识别
            recognition.interimResults = true; // 返回中间结果
            recognition.lang = 'zh-CN'; // 设置为中文
            recognition.maxAlternatives = 1; // 只返回一个结果

            // 监听识别结果
            recognition.onresult = function(event) {
                let interimTranscript = '';
                let finalTranscript = '';

                // 处理所有结果
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // 更新转录文本
                transcriptionText = finalTranscript + interimTranscript;
                updateTranscriptionDisplay();
            };

            // 监听错误
            recognition.onerror = function(event) {
                console.error('语音识别错误:', event.error);
                if (event.error === 'not-allowed') {
                    addChatMessage('系统', '无法访问麦克风，请检查权限设置', '#FF5252');
                }
                stopSpeechTranscription();
            };

            // 监听结束事件
            recognition.onend = function() {
                if (isTranscribing) {
                    // 如果还在转录状态，重新开始
                    recognition.start();
                }
            };

            return recognition;
        }

        // 切换语音转文字功能
        function toggleSpeechTranscription() {
            if (isTranscribing) {
                stopSpeechTranscription();
            } else {
                startSpeechTranscription();
            }
        }

        // 开始语音转文字
        function startSpeechTranscription() {
            // 初始化语音识别
            if (!speechRecognition) {
                speechRecognition = initSpeechRecognition();
                if (!speechRecognition) {
                    return;
                }
            }

            // 开始识别
            isTranscribing = true;
            transcriptionText = '';
            updateTranscriptionDisplay();
            updateTranscriptionButtonStatus();
            
            // 开始语音识别
            speechRecognition.start();

            // 设置10秒自动停止定时器
            recognitionTimer = setTimeout(() => {
                stopSpeechTranscription();
            }, 100000);
        }

        // 停止语音转文字
        function stopSpeechTranscription() {
            if (speechRecognition && isTranscribing) {
                isTranscribing = false;
                speechRecognition.stop();
                updateTranscriptionButtonStatus();
                clearTimeout(recognitionTimer);
            }
        }

        // 更新转录显示
        function updateTranscriptionDisplay() {
            // 获取聊天输入框
            const inputs = [
                document.getElementById('chatInput'),
                document.getElementById('chatInputModal')
            ];

            inputs.forEach(input => {
                if (input) {
                    input.value = transcriptionText;
                }
            });
        }

        // 更新转录按钮状态
        function updateTranscriptionButtonStatus() {
            const buttons = [
                document.getElementById('transcribeButton'),
                document.getElementById('transcribeButtonModal')
            ];
        }

        // 开始语音录制
        function startVoiceRecording() {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    mediaRecorder.ondataavailable = event => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        const duration = Math.floor((Date.now() - recordingStartTime) / 1000);
                        sendVoiceMessage(audioBlob, duration);
                        
                        // 重置录制状态
                        audioChunks = [];
                        isRecording = false;
                        updateVoiceButtonStatus();
                        clearInterval(recordingTimer);
                        clearTimeout(autoStopTimer);
                        
                        // 停止所有音频轨道
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    // 开始录制
                    mediaRecorder.start();
                    isRecording = true;
                    isPaused = false;
                    recordingStartTime = Date.now();
                    recordingElapsed = 0;
                    updateVoiceButtonStatus();
                    
                    // 显示录音状态模态框
                    showRecordingModal();
                    
                    // 显示录制时长
                    recordingTimer = setInterval(() => {
                        const duration = Math.floor((Date.now() - recordingStartTime) / 1000);
                        if (!isPaused) {
                            recordingElapsed = duration;
                            updateRecordingDuration(duration);
                        }
                    }, 1000);
                    
                    // 设置自动停止定时器
                    autoStopTimer = setTimeout(() => {
                        if (isRecording) {
                            mediaRecorder.stop();
                            // 关闭录音模态框
                            hideRecordingModal();
                            // 使用setTimeout延迟弹窗，确保录制已停止
                            setTimeout(() => {
                                addChatMessage('系统', `录制已自动停止，已达到最大录制时长 ${MAX_RECORDING_DURATION} 秒`, '#FF9800');
                            }, 100);
                        }
                    }, MAX_RECORDING_DURATION * 1000);
                })
                .catch(error => {
                    console.error('获取麦克风权限失败:', error);
                    alert('无法访问麦克风，请检查权限设置');
                });
        }
        
        // 停止语音录制
        function stopVoiceRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                // 关闭录音模态框
                hideRecordingModal();
            }
            // 清除自动停止定时器
            clearTimeout(autoStopTimer);
        }

        // 显示录音状态模态框
        function showRecordingModal() {
            const modal = document.getElementById('recordingModal');
            if (modal) {
                // 移除hidden类，并设置display样式
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
                // 重置状态
                recordingElapsed = 0;
                updateRecordingModalDisplay();
            }
        }

        // 隐藏录音状态模态框
        function hideRecordingModal() {
            const modal = document.getElementById('recordingModal');
            if (modal) {
                modal.style.display = 'none';
                modal.classList.add('hidden');
            }
            isPaused = false;
        }
        
        // 显示音乐播放确认弹窗
        function showMusicPlayConfirmModal(musicUrl, musicData) {
            const modal = document.getElementById('musicPlayConfirmModal');
            if (modal) {
                pendingMusicUrl = musicUrl;
                pendingMusicData = musicData;
                musicPlayCountdown = 10;
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
                
                // 更新倒计时显示
                const countdownElement = document.getElementById('rejectCountdown');
                if (countdownElement) {
                    countdownElement.textContent = musicPlayCountdown;
                }
                
                // 禁用拒绝按钮
                const rejectBtn = document.getElementById('rejectMusicBtn');
                if (rejectBtn) {
                    rejectBtn.disabled = true;
                    rejectBtn.style.opacity = '0.5';
                    rejectBtn.style.cursor = 'not-allowed';
                }
                
                // 启动倒计时
                startMusicPlayCountdown();
            }
        }
        
        // 隐藏音乐播放确认弹窗
        function hideMusicPlayConfirmModal() {
            const modal = document.getElementById('musicPlayConfirmModal');
            if (modal) {
                modal.style.display = 'none';
                modal.classList.add('hidden');
            }
            stopMusicPlayCountdown();
            pendingMusicUrl = null;
            pendingMusicData = null;
        }
        
        // 启动音乐播放倒计时
        function startMusicPlayCountdown() {
            stopMusicPlayCountdown(); // 先停止之前的倒计时
            
            musicPlayTimer = setInterval(() => {
                musicPlayCountdown--;
                const countdownElement = document.getElementById('rejectCountdown');
                const rejectBtn = document.getElementById('rejectMusicBtn');
                
                if (countdownElement) {
                    countdownElement.textContent = musicPlayCountdown;
                }
                
                // 倒计时结束，启用拒绝按钮
                if (musicPlayCountdown <= 0) {
                    if (rejectBtn) {
                        rejectBtn.disabled = false;
                        rejectBtn.style.opacity = '1';
                        rejectBtn.style.cursor = 'pointer';
                    }
                    stopMusicPlayCountdown();
                }
            }, 1000); // 每秒更新一次
        }
        
        // 停止音乐播放倒计时
        function stopMusicPlayCountdown() {
            if (musicPlayTimer) {
                clearInterval(musicPlayTimer);
                musicPlayTimer = null;
            }
        }
        
        // 同意播放音乐
        function acceptMusicPlay() {
            const audio = document.getElementById('gameAudio');
            if (audio) {
                // 优先使用Base64数据，否则使用URL
                const musicSource = pendingMusicData || pendingMusicUrl;
                if (musicSource) {
                    audio.src = musicSource;
                    audio.play()
                        .then(() => {
                            addChatMessage('系统', `背景音乐已开始播放`, '#4CAF50');
                            
                            // 广播给其他玩家
                            if (gameState.multiplayer && gameState.multiplayer.connections) {
                                const playerName = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId]?.name || '玩家';
                                const musicNotification = {
                                    type: 'chat-message',
                                    from: gameState.multiplayer.currentPlayerId,
                                    message: `[音乐] ${playerName} 已同意播放背景音乐`,
                                    color: '#FFD700',
                                    isSystem: true
                                };
                                Object.values(gameState.multiplayer.connections).forEach(conn => {
                                    if (conn.send) {
                                        conn.send(musicNotification);
                                    }
                                });
                            }
                        })
                        .catch(error => {
                            console.error('播放音乐失败:', error);
                            addChatMessage('系统', '播放音乐失败，可能是URL无效或浏览器限制', '#FF5252');
                        });
                }
            }
            hideMusicPlayConfirmModal();
        }
        
        // 拒绝播放音乐
        function rejectMusicPlay() {
            if (pendingMusicUrl) {
                addChatMessage('系统', '已拒绝播放背景音乐的请求', '#FF5252');
            }
            hideMusicPlayConfirmModal();
        }
        
        // 显示踢出玩家界面
        function showKickPlayerModal() {
            const modal = document.getElementById('kickPlayerModal');
            const playerList = document.getElementById('kickPlayerList');
            
            if (modal && playerList) {
                // 清空玩家列表
                playerList.innerHTML = '';
                
                // 生成玩家列表（排除房主）
                Object.entries(gameState.multiplayer.players).forEach(([playerId, player]) => {
                    if (playerId !== gameState.multiplayer.currentPlayerId) {
                        const playerItem = document.createElement('div');
                        playerItem.className = 'kick-player-item';
                        playerItem.style.cssText = `
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            padding: 10px 15px;
                            background: rgba(255, 255, 255, 0.05);
                            border-radius: 8px;
                            margin-bottom: 8px;
                            cursor: pointer;
                            transition: background 0.2s;
                        `;
                        playerItem.innerHTML = `
                            <span style="color: #fff; font-size: 16px;">${player.name}</span>
                            <button class="kick-player-btn" data-player-id="${playerId}" style="
                                padding: 8px 16px;
                                background: linear-gradient(135deg, #f44336, #d32f2f);
                                color: white;
                                border: none;
                                border-radius: 20px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: bold;
                            ">踢出</button>
                        `;
                        
                        // 点击玩家项选择该玩家
                        playerItem.addEventListener('click', () => {
                            // 移除其他玩家的选中状态
                            document.querySelectorAll('.kick-player-item').forEach(item => {
                                item.style.background = 'rgba(255, 255, 255, 0.05)';
                            });
                            // 高亮当前选中的玩家
                            playerItem.style.background = 'rgba(76, 175, 80, 0.3)';
                        });
                        
                        // 点击踢出按钮
                        const kickBtn = playerItem.querySelector('.kick-player-btn');
                        if (kickBtn) {
                            kickBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                kickPlayer(playerId, player.name);
                            });
                        }
                        
                        playerList.appendChild(playerItem);
                    }
                });
                
                // 显示模态框
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
            }
        }
        
        // 关闭踢出玩家界面
        function closeKickPlayerModal() {
            const modal = document.getElementById('kickPlayerModal');
            if (modal) {
                modal.style.display = 'none';
                modal.classList.add('hidden');
            }
        }
        
        // 踢出玩家
        function kickPlayer(playerId, playerName) {
            if (confirm(`确定要踢出玩家 "${playerName}" 吗？`)) {
                // 发送踢出消息
                const kickMessage = {
                    type: 'kick-player',
                    playerId: playerId
                };
                
                if (gameState.multiplayer.connections) {
                    Object.values(gameState.multiplayer.connections).forEach(conn => {
                        if (conn.send) {
                            conn.send(kickMessage);
                        }
                    });
                }
                
                // 从本地玩家列表中移除
                delete gameState.multiplayer.players[playerId];
                delete gameState.multiplayer.connections[playerId];
                
                // 更新玩家列表显示
                updatePlayerList();
                
                // 显示系统消息
                addChatMessage('系统', `玩家 ${playerName} 已被踢出房间`, '#FF5252');
                
                // 关闭踢出界面
                closeKickPlayerModal();
            }
        }

        // 切换暂停录制
        function togglePauseRecording() {
            const btn = document.getElementById('pauseRecordingBtn');
            if (btn) {
                if (isPaused) {
                    // 恢复录制
                    isPaused = false;
                    btn.innerHTML = '⏸️ 暂停';
                    btn.style.background = 'linear-gradient(135deg, #FF9800, #F57C00)';
                    // 恢复录制
                    if (mediaRecorder && mediaRecorder.state === 'paused') {
                        mediaRecorder.resume();
                        // 恢复录制计时，基于当前已录制时长
                        recordingStartTime = Date.now() - (recordingElapsed * 1000);
                    }
                } else {
                    // 暂停录制
                    isPaused = true;
                    btn.innerHTML = '▶️ 继续';
                    btn.style.background = 'linear-gradient(135deg, #4CAF50, #2E7D32)';
                    // 暂停录制
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.pause();
                        // 保存当前已录制的时长
                        recordingElapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                    }
                }
            }
        }

        // 更新录制模态框显示
        function updateRecordingModalDisplay() {
            const timerElement = document.getElementById('recordingTimer');
            const progressElement = document.getElementById('recordingProgress');
            
            if (timerElement) {
                const minutes = Math.floor(recordingElapsed / 60);
                const seconds = recordingElapsed % 60;
                timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
            
            if (progressElement) {
                const progress = (recordingElapsed / MAX_RECORDING_DURATION) * 100;
                progressElement.style.width = `${Math.min(progress, 100)}%`;
            }
        }
        
        // 更新语音按钮状态
        function updateVoiceButtonStatus() {
            const voiceButtons = [
                document.getElementById('voiceButton'),
                document.getElementById('voiceButtonModal')
            ];
            
            voiceButtons.forEach(button => {
                if (button) {
                    if (isRecording) {
                        button.style.background = 'linear-gradient(135deg, #f44336, #d32f2f)';
                        button.textContent = '⏹️';
                    } else {
                        button.style.background = 'linear-gradient(135deg, #4CAF50, #2E7D32)';
                        button.textContent = '🎤';
                    }
                }
            });
        }
        
        // 更新录制时长显示
        function updateRecordingDuration(duration) {
            // 更新录制模态框显示
            recordingElapsed = duration;
            updateRecordingModalDisplay();
            
            // 在控制台输出录制时长
            console.log(`录制时长: ${duration}/${MAX_RECORDING_DURATION}秒`);
            
            // 更新录制按钮的文本，显示剩余时长
            const voiceButtons = [
                document.getElementById('voiceButton'),
                document.getElementById('voiceButtonModal')
            ];
            
            voiceButtons.forEach(button => {
                if (button && isRecording) {
                    const remaining = MAX_RECORDING_DURATION - duration;
                    button.title = `正在录制: ${duration}/${MAX_RECORDING_DURATION}秒`;
                    button.style.fontSize = '12px';
                }
            });
        }
        
        // 发送语音消息
        function sendVoiceMessage(blob, duration) {
            if (gameState.currentScreen === 'multiplayerGame' && gameState.multiplayer) {
                // 将Blob转换为Base64
                const reader = new FileReader();
                reader.onload = function(e) {
                    const voiceData = e.target.result;
                    
                    // 生成消息ID
                    const messageId = Date.now() + Math.random().toString(36).substr(2, 9);
                    
                    // 向所有玩家发送语音消息
                    const voiceMessage = {
                        type: 'voice-message',
                        from: gameState.multiplayer.currentPlayerId,
                        voice: voiceData,
                        duration: duration,
                        timestamp: Date.now()
                    };
                    
                    // 发送给所有连接的玩家
                    if (gameState.multiplayer.connections) {
                        Object.values(gameState.multiplayer.connections).forEach(conn => {
                            if (conn.send) {
                                conn.send(voiceMessage);
                            }
                        });
                    }
                    
                    // 自己也显示语音消息
                    const player = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
                    if (player) {
                        addVoiceMessage(player.name, voiceData, duration, messageId);
                    }
                };
                reader.readAsDataURL(blob);
            }
        }
        
        // 添加语音消息到聊天界面
        function addVoiceMessage(sender, voiceData, duration, messageId) {
            // 获取两个聊天容器
            const chatMessagesElements = [
                document.getElementById('chatMessages'),
                document.getElementById('chatMessagesModal')
            ];
            
            // 根据时长计算按钮宽度（最小60px，最大200px）
            const minWidth = 60;
            const maxWidth = 200;
            const widthPerSecond = 2;
            const buttonWidth = Math.min(maxWidth, minWidth + duration * widthPerSecond);
            
            chatMessagesElements.forEach(chatMessagesElement => {
                if (chatMessagesElement) {
                    const messageElement = document.createElement('div');
                    messageElement.style.marginBottom = '10px';
                    messageElement.style.color = '#4CAF50';
                    messageElement.dataset.messageId = messageId || (Date.now() + Math.random().toString(36).substr(2, 9));
                    
                    let content = `<strong>${sender}:</strong> `;
                    content += `<button onclick="toggleVoicePlayback(this)" data-voice-data="${voiceData}" data-duration="${duration}" style="margin-left: 5px; padding: 4px 10px; background: rgba(76, 175, 80, 0.7); color: white; border: none; border-radius: 15px; cursor: pointer; font-size: 12px; min-width: ${buttonWidth}px; max-width: ${maxWidth}px; width: ${buttonWidth}px; text-align: center;">▶️ ${duration}秒</button>`;
                    
                    // 添加撤回按钮（只有自己的消息可以撤回）
                    if (sender === '我' || (gameState.multiplayer && sender === gameState.multiplayer.players[gameState.multiplayer.currentPlayerId]?.name)) {
                        content += `<button onclick="recallMessage('${messageElement.dataset.messageId}')" style="margin-left: 10px; padding: 2px 6px; background: rgba(244, 67, 54, 0.7); color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">撤回</button>`;
                    }
                    
                    messageElement.innerHTML = content;
                    chatMessagesElement.appendChild(messageElement);
                    
                    // 滚动到底部
                    chatMessagesElement.scrollTop = chatMessagesElement.scrollHeight;
                }
            });
        }
        
        // 播放语音消息
        function playVoiceMessage(voiceData, buttonElement) {
            // 如果当前有正在播放的语音，先停止
            if (isPlaying && currentAudio && currentPlayingButton) {
                // 如果点击的是同一个按钮，暂停播放
                if (currentPlayingButton === buttonElement) {
                    stopPlaybackTimer(); // 停止播放进度定时器
                    currentAudio.pause();
                    isPlaying = false;
                    updatePlayButtonStatus(currentPlayingButton, false);
                    return;
                } else {
                    // 否则停止当前播放，开始播放新的语音
                    stopCurrentAudio();
                }
            }
            
            // 创建新的Audio对象
            const audio = new Audio(voiceData);
            currentAudio = audio;
            currentPlayingButton = buttonElement;
            
            // 播放语音
            audio.play()
                .then(() => {
                    isPlaying = true;
                    updatePlayButtonStatus(buttonElement, true);
                    // 启动播放进度更新定时器
                    startPlaybackTimer(audio, buttonElement);
                })
                .catch(error => {
                    console.error('播放语音失败:', error);
                    isPlaying = false;
                    updatePlayButtonStatus(buttonElement, false);
                });
            
            // 监听播放结束事件
            audio.onended = function() {
                isPlaying = false;
                updatePlayButtonStatus(buttonElement, false);
                stopPlaybackTimer();
                resetPlayState();
            };
            
            // 监听暂停事件
            audio.onpause = function() {
                stopPlaybackTimer();
            };
        }
        
        // 停止当前播放的音频
        function stopCurrentAudio() {
            stopPlaybackTimer(); // 停止播放进度定时器
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
            }
            if (currentPlayingButton) {
                updatePlayButtonStatus(currentPlayingButton, false);
            }
            resetPlayState();
        }
        
        // 重置播放状态
        function resetPlayState() {
            isPlaying = false;
            currentAudio = null;
            currentPlayingButton = null;
        }
        
        // 更新播放按钮状态
        function updatePlayButtonStatus(buttonElement, isPlaying) {
            if (buttonElement) {
                if (isPlaying) {
                    buttonElement.innerHTML = '⏸️ 播放中...';
                    buttonElement.style.background = 'linear-gradient(135deg, #FFC107, #FFA000)';
                } else {
                    const duration = buttonElement.dataset.duration || '0';
                    buttonElement.innerHTML = `▶️ ${duration}秒`;
                    buttonElement.style.background = 'rgba(76, 175, 80, 0.7)';
                }
            }
        }
        
        // 启动播放进度更新定时器
        function startPlaybackTimer(audio, buttonElement) {
            stopPlaybackTimer(); // 先停止之前的定时器
            
            playbackTimer = setInterval(() => {
                if (audio && buttonElement) {
                    const currentTime = Math.floor(audio.currentTime);
                    let duration = Math.floor(audio.duration);
                    
                    // 检查duration是否为有效值
                    if (!isFinite(duration) || isNaN(duration) || duration <= 0) {
                        // 如果duration无效，显示播放中状态
                        buttonElement.innerHTML = '⏸️ 播放中...';
                        return;
                    }
                    
                    buttonElement.innerHTML = `⏸️ ${currentTime}/${duration}秒`;
                }
            }, 1000); // 每秒更新一次
        }
        
        // 停止播放进度定时器
        function stopPlaybackTimer() {
            if (playbackTimer) {
                clearInterval(playbackTimer);
                playbackTimer = null;
            }
        }
        
        // 切换语音播放/暂停
        function toggleVoicePlayback(buttonElement) {
            const voiceData = buttonElement.dataset.voiceData;
            playVoiceMessage(voiceData, buttonElement);
        }

        // 转写已有语音消息
        function transcribeExistingVoice(voiceData) {
            // 这里应该实现语音转文字的逻辑
            // 由于浏览器限制，我们无法直接将音频数据转换为文字
            // 但可以提示用户使用语音转文字功能
            addChatMessage('系统', '🎙️ 语音转文字功能需要实时录制，无法直接转换已发送的语音消息', '#FF9800');
        }

        // 异步处理图片背景并显示消息
        async function addChatMessage(sender, message, color, imageData, messageId) {
            // 处理图片背景
            let processedImageData = imageData;
            if (imageData) {
                processedImageData = await processImageBackground(imageData);
            }
            
            // 获取两个聊天容器
            const chatMessagesElements = [
                document.getElementById('chatMessages'),
                document.getElementById('chatMessagesModal')
            ];
            
            chatMessagesElements.forEach(chatMessagesElement => {
                if (chatMessagesElement) {
                const messageElement = document.createElement('div');
                messageElement.style.marginBottom = '10px';
                messageElement.style.color = color || 'white';
                const finalMessageId = messageId || (Date.now() + Math.random().toString(36).substr(2, 9)); // 生成或使用提供的消息ID
                messageElement.dataset.messageId = finalMessageId;
                
                let content = `<strong>${sender}:</strong>`;
                if (processedImageData) {
                    content += `<br><img src="${processedImageData}" onclick="openImagePreview('${processedImageData}')" style="max-width: 250px; max-height: 200px; border-radius: 5px; margin-top: 5px; cursor: pointer;">`;
                }
                if (message) {
                    // 将换行符转换为HTML换行标签
                    let formattedMessage = message.replace(/\n/g, '<br>');
                    
                    // 检测并转换URL为超链接
                    // 支持：完整URL、无协议域名、IP地址
                    const urlRegex = /(https?:\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?)|((?:[a-zA-Z0-9\-]+\.)+[a-zA-Z]{2,}(?:\/[\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?)|((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?::[0-9]+)?(?:\/[\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?)/g;
                    formattedMessage = formattedMessage.replace(urlRegex, function(match) {
                        // 如果URL没有协议前缀，添加http://
                        const url = match.startsWith('http') ? match : `http://${match}`;
                        return `<a href="${url}" target="_blank" style="color: #4CAF50; text-decoration: underline; cursor: pointer;">${match}</a>`;
                    });
                    
                    content += ` ${formattedMessage}`;
                }
                
                // 添加撤回按钮（只有自己的消息可以撤回）
                if (sender === '我' || (gameState.multiplayer && sender === gameState.multiplayer.players[gameState.multiplayer.currentPlayerId]?.name)) {
                    content += `<button onclick="recallMessage('${messageElement.dataset.messageId}')" style="margin-left: 10px; padding: 2px 6px; background: rgba(244, 67, 54, 0.7); color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">撤回</button>`;
                }
                
                messageElement.innerHTML = content;
                chatMessagesElement.appendChild(messageElement);
                
                // 滚动到底部
                chatMessagesElement.scrollTop = chatMessagesElement.scrollHeight;
            }
            });
        }

        // 表情包相关函数
        const emojis = ['😊', '😂', '😍', '😎', '😢', '😡', '👍', '👎', '🎉', '🎈', '🎮', '🚀', '❤️', '🔥', '⭐', '🤔', '😱', '😴', '🤣', '😤', '👀', '🙏', '👏', '🤝', '🤞', '🤩', '😇', '😈', '👻', '💀', '👽', '🤖', '💪', '🌟', '✨', '💫', '🎊', '🎁', '🎂', '🎃', '🎄', '🎆', '🎇', '🎵', '🎶', '🎸', '🎹', '🎺', '🎻', '🎧', '🎮', '🎯', '🎲', '🎳', '🎨', '📸', '📹', '🎬', '📱', '💻', '⌨️', '🖱️', '🖥️', '📡', '🚁', '✈️', '🚀', '🚗', '🚕', '🚙', '🚌', '🚎', '🏎️', '🚓', '🚑', '🚒', '🚐', '🚚', '🚛', '🚜', '🚲', '🛴', '🛵', '🏍️', '🛺', '🚨', '🚥', '🚦', '🛣️', '🛤️', '🛢️', '⛽', '🚧', '🏁', '🎌', '🏴󠁧󠁢󠁥󠁮󠁧󠁿', '🏴󠁧󠁢󠁳󠁣󠁴󠁿', '🏴󠁧󠁢󠁷󠁬󠁳󠁿', '🏴󠁵󠁳󠁣󠁡󠁿', '🇨🇳', '🇯🇵', '🇰🇷', '🇺🇸', '🇬🇧', '🇫🇷', '🇩🇪', '🇮🇹', '🇪🇸', '🇷🇺', '🇮🇳', '🇧🇷', '🇦🇺', '🇳🇿', '🇨🇦', '🇲🇽', '🇧🇪', '🇳🇱', '🇩🇰', '🇸🇪', '🇳🇴', '🇫🇮', '🇨🇭', '🇦🇹', '🇵🇹', '🇮🇪', '🇬🇷', '🇷🇴', '🇺🇦', '🇵🇱', '🇨🇿', '🇭🇺', '🇸🇰', '🇸🇮', '🇧🇬', '🇷🇸', '🇲🇩', '🇦🇱', '🇲🇪', '🇦🇫', '🇦🇽', '🇦🇱', '🇦🇸', '🇦🇩', '🇦🇴', '🇦🇮', '🇦🇶', '🇦🇬', '🇦🇷', '🇦🇲', '🇦🇼', '🇦🇺', '🇦🇹', '🇦🇿', '🇧🇸', '🇧🇭', '🇧🇩', '🇧🇧', '🇧🇾', '🇧🇪', '🇧🇿', '🇧🇯', '🇧🇲', '🇧🇹', '🇧🇴', '🇧🇦', '🇧🇼', '🇧🇷', '🇮🇴', '🇻🇬', '🇧🇳', '🇧🇬', '🇧🇫', '🇧🇮', '🇧🇹', '🇧🇱', '🇧🇾', '🇧🇲', '🇧🇹', '🇧🇴', '🇧🇦', '🇧🇼', '🇧🇷', '🇮🇴', '🇻🇬', '🇧🇳', '🇧🇬', '🇧🇫', '🇧🇮', '🇧🇹', '🇧🇱', '❤️', '🧡', '💛', '💚', '💙', '💜', '🖤', '🤍', '🤎', '💔', '❣️', '💕', '💞', '💓', '💗', '💖', '💘', '💝', '💟', '☮️', '✝️', '☪️', '🕉️', '☸️', '✡️', '🔯', '🕎', '☯️', '☦️', '🛐', '⛎', '♈', '♉', '♊', '♋', '♌', '♍', '♎', '♏', '♐', '♑', '♒', '♓', '🆔', '🉑', '☑️', '✅', '❎', '🗳️', '📳', '📴', '🈶', '🈚', '🈸', '🈺', '🈷️', '🈴', '🈵', '🈹', '🈲', '🅰️', '🅱️', '🆎', '🆑', '🅾️', '🆘', '🆔', '🉐', '🈹', '🈴', '🈵', '🈷️', '🈶', '🈚', '🈲', '🅰️', '🅱️', '🆎', '🆑', '🅾️', '🆘', '🆔', '🉐', '💮', '㊙️', '㊗️', '🀄', '🃏', '🎴', '🀄', '🎎', '👘', '🥷', '👺', '👹', '💂', '🤴', '👸', '👳', '👲', '🧕', '🤵', '👰', '👼', '🎅', '🤶', '🧑', '👦', '👧', '🧒', '👶', '👩', '👨', '🧔', '👵', '👴', '🧓', '👲', '👳', '🧕', '🤵', '👰', '👼', '🎅', '🤶', '🧑', '👦', '👧', '🧒', '👶', '👩', '👨', '🧔', '👵', '👴', '🧓','█','⊞','▁','▓','░','■','▧','▭','◙','▚','▟','◪','☀','℉','℃','⚡','⛅','⛈','☼','✭','❋','↑','←','→','↓','↔','↕','↖','↩','↪','↺','↻','⇠','⇢','⇡','⇣','⇦','⇧','⇩','⇨','➢','➣','➵'];
        
        function toggleEmojiPicker() {
            const emojiPicker = document.getElementById('emojiPicker');
            if (emojiPicker) {
                if (emojiPicker.style.display === 'none') {
                    loadEmojis();
                    emojiPicker.style.display = 'block';
                } else {
                    emojiPicker.style.display = 'none';
                }
            }
        }
        
        function loadEmojis() {
            const emojiPicker = document.getElementById('emojiPicker');
            if (emojiPicker && emojiPicker.innerHTML === '') {
                emojis.forEach(emoji => {
                    const emojiButton = document.createElement('button');
                    emojiButton.textContent = emoji;
                    emojiButton.style.fontSize = '20px';
                    emojiButton.style.padding = '5px 10px';
                    emojiButton.style.margin = '2px';
                    emojiButton.style.background = 'rgba(255, 255, 255, 0.1)';
                    emojiButton.style.border = '1px solid rgba(255, 255, 255, 0.3)';
                    emojiButton.style.borderRadius = '5px';
                    emojiButton.style.color = 'white';
                    emojiButton.style.fontFamily = 'Segoe UI Emoji, Apple Color Emoji, Noto Color Emoji, EmojiOne, sans-serif';
                    emojiButton.style.cursor = 'pointer';
                    emojiButton.style.display = 'inline-block';
                    emojiButton.style.minWidth = '30px';
                    emojiButton.style.minHeight = '30px';
                    emojiButton.style.textAlign = 'center';
                    emojiButton.onclick = () => insertEmoji(emoji);
                    
                    // 添加悬停效果
                    emojiButton.addEventListener('mouseenter', function() {
                        this.style.background = 'rgba(76, 175, 80, 0.3)';
                        this.style.borderColor = '#4CAF50';
                    });
                    
                    emojiButton.addEventListener('mouseleave', function() {
                        this.style.background = 'rgba(255, 255, 255, 0.1)';
                        this.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                    });
                    
                    emojiPicker.appendChild(emojiButton);
                });
            }
        }
        
        function insertEmoji(emoji) {
            // 检查当前活跃的聊天输入框
            const chatInput = document.getElementById('chatInput');
            const chatInputModal = document.getElementById('chatInputModal');
            
            // 检查模态框是否显示，优先使用模态框输入框
            let activeInput;
            const chatModal = document.getElementById('chatModal');
            if (chatModal && chatModal.style.display !== 'none') {
                activeInput = chatInputModal;
            } else {
                activeInput = chatInput;
            }
            
            if (activeInput) {
                const start = activeInput.selectionStart;
                const end = activeInput.selectionEnd;
                const text = activeInput.value;
                activeInput.value = text.substring(0, start) + emoji + text.substring(end);
                activeInput.focus();
                activeInput.setSelectionRange(start + emoji.length, start + emoji.length);
            }
            
            // 检测中国国旗表情包并解锁成就
            if (emoji === '🇨🇳' && !gameState.achievements.chineseEmojiUsed) {
                gameState.achievements.chineseEmojiUsed = true;
                // 奖励50金币
                gameState.coins += 50;
                saveGameData();
                updateAchievementProgress();
                showAchievementUnlocked('伟大的国家，勿忘国耻', '使用中国国旗表情包，获得50金币奖励');
            }
            
            toggleEmojiPicker();
        }
        
        // 点击页面其他地方关闭表情包面板
        document.addEventListener('click', function(e) {
            const emojiPicker = document.getElementById('emojiPicker');
            const emojiButton = document.getElementById('emojiButton');
            const emojiButtonModal = document.getElementById('emojiButtonModal');
            if (emojiPicker && emojiPicker.style.display === 'block' && 
                !emojiPicker.contains(e.target) && 
                e.target !== emojiButton && 
                e.target !== emojiButtonModal) {
                emojiPicker.style.display = 'none';
            }
        });
        
        // 图片预览功能
        function openImagePreview(imageData) {
            const modal = document.getElementById('imagePreviewModal');
            const previewImage = document.getElementById('previewImage');
            if (modal && previewImage) {
                previewImage.src = imageData;
                modal.style.display = 'flex';
            }
        }
        
        // 关闭图片预览
        document.getElementById('closePreview')?.addEventListener('click', function() {
            const modal = document.getElementById('imagePreviewModal');
            if (modal) {
                modal.style.display = 'none';
            }
        });
        
        // 点击模态框外部关闭预览
        document.getElementById('imagePreviewModal')?.addEventListener('click', function(e) {
            if (e.target === this) {
                this.style.display = 'none';
            }
        });
        
        // 图片下载功能
        function downloadImage() {
            const previewImage = document.getElementById('previewImage');
            if (previewImage && previewImage.src) {
                const a = document.createElement('a');
                a.href = previewImage.src;
                a.download = `maze-adventure-${Date.now()}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        }
        
        // 绑定下载按钮事件
        document.getElementById('downloadImage')?.addEventListener('click', downloadImage);
        
        // 消息撤回功能
        function recallMessage(messageId) {
            // 在两个聊天容器中查找并撤回消息
            const chatContainers = [
                document.getElementById('chatMessages'),
                document.getElementById('chatMessagesModal')
            ];
            
            chatContainers.forEach(chatMessages => {
                if (chatMessages) {
                    const messageElement = chatMessages.querySelector(`[data-message-id="${messageId}"]`);
                    if (messageElement) {
                    // 发送撤回消息给其他玩家
                    if (gameState.currentScreen === 'multiplayerGame' && gameState.multiplayer) {
                        const recallMessage = {
                            type: 'chat-recall',
                            from: gameState.multiplayer.currentPlayerId,
                            messageId: messageId
                        };
                        
                        // 发送给所有连接的玩家
                        if (gameState.multiplayer.connections) {
                            Object.values(gameState.multiplayer.connections).forEach(conn => {
                                if (conn.send) {
                                    conn.send(recallMessage);
                                }
                            });
                        }
                    }
                    
                    // 在本地撤回消息
                    messageElement.innerHTML = '<strong>系统消息:</strong> 消息已撤回';
                    messageElement.style.color = '#888';
                    
                    // 3秒后自动删除撤回提示
                    setTimeout(() => {
                        if (messageElement.parentElement) {
                            messageElement.parentElement.removeChild(messageElement);
                        }
                    }, 3000);
                    }
                }
            });
        }
        
        // 检测并处理图片背景
        function processImageBackground(imageData) {
            return new Promise((resolve) => {
                // 创建Image对象
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = function() {
                    // 创建Canvas元素
                    const canvas = document.createElement('canvas');
                    canvas.width = this.width;
                    canvas.height = this.height;
                    const ctx = canvas.getContext('2d');
                    
                    // 绘制图片
                    ctx.drawImage(this, 0, 0);
                    
                    // 获取图片数据
                    const pixelData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = pixelData.data;
                    
                    // 检测背景颜色（检查四个角落的像素）
                    const cornerPixels = [
                        {x: 0, y: 0}, // 左上角
                        {x: canvas.width - 1, y: 0}, // 右上角
                        {x: 0, y: canvas.height - 1}, // 左下角
                        {x: canvas.width - 1, y: canvas.height - 1} // 右下角
                    ];
                    
                    let isBlackBackground = true;
                    
                    for (const pixel of cornerPixels) {
                        const index = (pixel.y * canvas.width + pixel.x) * 4;
                        const r = data[index];
                        const g = data[index + 1];
                        const b = data[index + 2];
                        
                        // 计算亮度 (0-255)
                        const brightness = (r + g + b) / 3;
                        
                        // 如果亮度超过阈值（不是黑色背景）
                        if (brightness > 50) {
                            isBlackBackground = false;
                            break;
                        }
                    }
                    
                    // 如果是黑色背景，添加白色背景
                    if (isBlackBackground) {
                        // 创建新的Canvas，添加白色背景
                        const newCanvas = document.createElement('canvas');
                        newCanvas.width = this.width;
                        newCanvas.height = this.height;
                        const newCtx = newCanvas.getContext('2d');
                        
                        // 绘制白色背景
                        newCtx.fillStyle = '#ffffff';
                        newCtx.fillRect(0, 0, newCanvas.width, newCanvas.height);
                        
                        // 绘制原图，使用globalCompositeOperation确保图片显示在白色背景上
                        newCtx.globalCompositeOperation = 'source-over';
                        newCtx.drawImage(this, 0, 0);
                        
                        // 返回处理后的图片数据
                        resolve(newCanvas.toDataURL('image/png'));
                    } else {
                        // 返回原图的Data URL
                        const canvas = document.createElement('canvas');
                        canvas.width = this.width;
                        canvas.height = this.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(this, 0, 0);
                        resolve(canvas.toDataURL('image/png'));
                    }
                };
                
                // 处理加载失败的情况
                img.onerror = function() {
                    // 加载失败时返回原始Data URL
                    resolve(imageData);
                };
                
                // 设置图片源
                img.src = imageData;
            });
        }

        // 图片处理函数
        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (file) {
                // 显示传输提示
                const chatContainer = document.getElementById('chatModal');
                const transferHint = document.createElement('div');
                transferHint.id = 'imageTransferHint';
                transferHint.style.position = 'absolute';
                transferHint.style.bottom = '50px';
                transferHint.style.left = '20px';
                transferHint.style.background = 'rgba(0, 0, 0, 0.7)';
                transferHint.style.color = '#4CAF50';
                transferHint.style.padding = '5px 10px';
                transferHint.style.borderRadius = '5px';
                transferHint.style.fontSize = '12px';
                transferHint.textContent = '传输图片可能需要一些时间...';
                chatContainer.appendChild(transferHint);
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const imageData = e.target.result;
                    // 检查是否处于多人游戏模式
                    if (gameState.currentScreen === 'multiplayerGame' && gameState.multiplayer) {
                        // 向所有玩家发送图片消息
                        // 生成消息ID
                    const messageId = Date.now() + Math.random().toString(36).substr(2, 9);
                    
                    const imageMessage = {
                        type: 'chat-image',
                        from: gameState.multiplayer.currentPlayerId,
                        image: imageData,
                        messageId: messageId
                    };
                        
                        // 发送给所有连接的玩家
                        if (gameState.multiplayer.connections) {
                            Object.values(gameState.multiplayer.connections).forEach(conn => {
                                if (conn.send) {
                                    conn.send(imageMessage);
                                }
                            });
                        }
                        
                        // 自己也显示图片
                        const player = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
                        if (player) {
                            addChatMessage(player.name, null, player.color, imageData, messageId);
                        }
                    } else {
                        // 单人游戏模式下只显示自己的图片
                        addChatMessage('我', null, '#4CAF50', imageData);
                    }
                    
                    // 移除传输提示
                    setTimeout(() => {
                        const transferHint = document.getElementById('imageTransferHint');
                        if (transferHint) {
                            transferHint.remove();
                        }
                    }, 2000);
                    
                    // 清空触发事件的文件输入
                    event.target.value = '';
                };
                reader.readAsDataURL(file);
            }
        }
        
        // 添加回车键发送消息
        document.addEventListener('DOMContentLoaded', function() {
            // 初始化回放系统
            initReplaySystem();
            // 为常规聊天输入框添加回车键监听
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendChatMessage();
                    }
                });
            }
            
            // 为聊天模态框输入框添加回车键监听
            const chatInputModal = document.getElementById('chatInputModal');
            if (chatInputModal) {
                chatInputModal.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendChatMessage();
                    }
                });
            }
        });
        // 显示游戏说明
        function showInstructions() {
            document.getElementById('instructionsModal').classList.remove('hidden');
        }
        
        // 显示UI设置面板
        function showUISettings() {
            
            let settings;
            try {
                // 加载保存的设置
                settings = gameState.uiSettings;
                // console.log('gameState.uiSettings:', settings);
            }catch (error) {
                console.error('Error loading UI settings:', error);
                // 如果加载失败，使用默认设置
                settings = gameState.uiSettings;
            }
            
            document.getElementById('showControlsCheckbox').checked = settings.showControls;
            document.getElementById('controlsPosition').value = settings.controlsPosition;
            document.getElementById('controlsSize').value = settings.controlsSize;
            document.getElementById('controlsOpacity').value = settings.controlsOpacity;
            
            document.getElementById('showGameInfoCheckbox').checked = settings.showGameInfo;
            document.getElementById('showLevelInfo').checked = settings.showLevelInfo;
            document.getElementById('showTimeInfo').checked = settings.showTimeInfo;
            document.getElementById('showMoveInfo').checked = settings.showMoveInfo;
            document.getElementById('showKeyInfo').checked = settings.showKeyInfo;
            document.getElementById('showRoomInfo').checked = settings.showRoomInfo;
            
            // 加载音乐设置
            document.getElementById('musicEnabledCheckbox').checked = settings.musicEnabled;
            document.getElementById('musicVolume').value = settings.musicVolume;
            
            // 重新生成音乐选择列表，包括自定义音乐
            const musicSelectionList = document.getElementById('musicSelectionList');
            // 清空现有选项
            musicSelectionList.innerHTML = `
                <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="musicSelected" value="game-music-1"> 游戏音乐 1
                        </label>
                    </div>
                <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="musicSelected" value="game-music-2"> 游戏音乐 2
                        </label>
                    </div>
                <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="musicSelected" value="game-music-3"> 游戏音乐 3
                        </label>
                    </div>
            `;
            // 添加自定义音乐
            if (settings.customMusic && Array.isArray(settings.customMusic) && settings.customMusic.length > 0) {
                settings.customMusic.forEach(music => {
                    const musicOption = document.createElement('div');
                    musicOption.className = 'music-option';
                    musicOption.innerHTML = `
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="musicSelected" value="custom-${music.id}">
                            <input type="checkbox" class="custom-music-checkbox" data-music-id="${music.id}">
                            自定义: ${music.name}
                        </label>
                    `;
                    musicSelectionList.appendChild(musicOption);
                });
            }
            // 设置当前选中的音乐
            const radioButtons = musicSelectionList.querySelectorAll('input[name="musicSelected"]');
            radioButtons.forEach(radio => {
                if (radio.value === settings.musicSelected) {
                    radio.checked = true;
                }
            });
            // 添加复选框事件监听器
            const checkboxes = musicSelectionList.querySelectorAll('.custom-music-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateDeleteButtonState);
            });
            // 添加单选按钮事件监听器
            radioButtons.forEach(radio => {
                radio.addEventListener('change', function() {
                    gameState.uiSettings.musicSelected = this.value;
                    if (gameState.musicPlayer.isPlaying) {
                        // 切换到新音乐
                        playMusic();
                    }
                    // 保存设置但不关闭模态框
                    localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
                });
            });
            
            // 更新删除按钮状态
            updateDeleteButtonState();
            
            // 添加音乐控制按钮的事件监听器
            document.getElementById('musicPlay').onclick = function() {
                playMusic();
            };
            document.getElementById('musicPause').onclick = function() {
                pauseMusic();
            };
            document.getElementById('musicStop').onclick = function() {
                stopMusic();
            };
            
            // 添加音乐设置的实时更新监听器
            document.getElementById('musicVolume').onchange = function() {
                const volume = parseInt(this.value);
                gameState.uiSettings.musicVolume = volume;
                if (gameState.musicPlayer.audio) {
                    gameState.musicPlayer.audio.volume = volume / 100;
                }
            };
            
            document.getElementById('musicEnabledCheckbox').onchange = function() {
                // 如果用户尝试启用音乐但音乐未解锁
                if (this.checked && !gameState.uiSettings.musicEnabled) {
                    // 显示解锁模态框
                    document.getElementById('musicUnlockModal').classList.remove('hidden');
                    alert("请先解锁音乐（划到最上面，输入密钥");
                    // 恢复复选框状态
                    this.checked = false;
                } else {
                    // 正常处理开关状态
                    gameState.uiSettings.musicEnabled = this.checked;
                    if (!this.checked) {
                        stopMusic();
                    }
                }
            };
            
            // 显示UI设置模态框
            const uiSettingsModal = document.getElementById('uiSettingsModal');
            
            if (uiSettingsModal) {
                uiSettingsModal.classList.remove('hidden');
                
            } else {
                console.error('uiSettingsModal元素不存在');
            }
        }
        
        // 音乐播放器功能
        function playMusic() {
            const settings = gameState.uiSettings;
            
            // 检查音乐是否已解锁
            if (!settings.musicEnabled) {
                // 显示解锁模态框
                document.getElementById('musicUnlockModal').classList.remove('hidden');
                return;
            }
            
            if (!settings.musicEnabled) {
                settings.musicEnabled = true;
                document.getElementById('musicEnabledCheckbox').checked = true;
            }
            
            if (!gameState.musicPlayer.audio) {
                gameState.musicPlayer.audio = new Audio();
                
                // 添加错误处理
                gameState.musicPlayer.audio.onerror = function(e) {
                    console.error('音乐加载错误:', e);
                    gameState.musicPlayer.isPlaying = false;
                };
            }
            
            // 设置当前音乐
            const musicUrl = getMusicUrl(settings.musicSelected);
            console.log('使用的音乐URL:', musicUrl);
            console.log('当前选择的音乐:', settings.musicSelected);
            if (!musicUrl) {
                console.error('获取音乐URL失败');
                return;
            }
            
            gameState.musicPlayer.audio.src = musicUrl;
            console.log('Audio对象的src设置为:', gameState.musicPlayer.audio.src);
            gameState.musicPlayer.audio.volume = settings.musicVolume / 100;
            gameState.musicPlayer.audio.loop = true;
            
            // 处理移动设备的自动播放限制
            try {
                const playPromise = gameState.musicPlayer.audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        gameState.musicPlayer.isPlaying = true;
                        gameState.musicPlayer.currentTrack = settings.musicSelected;
                    }).catch(error => {
                        console.error('音乐播放失败:', error);
                        gameState.musicPlayer.isPlaying = false;
                        // 在移动设备上，提示用户手动播放
                        alert('请点击屏幕任意位置开始播放音乐');
                    });
                } else {
                    gameState.musicPlayer.isPlaying = true;
                    gameState.musicPlayer.currentTrack = settings.musicSelected;
                }
            } catch (error) {
                console.error('音乐播放错误:', error);
                gameState.musicPlayer.isPlaying = false;
            }
        }
        
        function pauseMusic() {
            if (gameState.musicPlayer.audio && gameState.musicPlayer.isPlaying) {
                gameState.musicPlayer.audio.pause();
                gameState.musicPlayer.isPlaying = false;
            }
        }
        
        function stopMusic() {
            if (gameState.musicPlayer.audio) {
                gameState.musicPlayer.audio.pause();
                gameState.musicPlayer.audio.currentTime = 0;
                gameState.musicPlayer.isPlaying = false;
                gameState.musicPlayer.currentTrack = null;
            }
        }
        
        function deleteSelectedCustomMusic() {
            // 获取所有选中的自定义音乐复选框
            const checkedCheckboxes = document.querySelectorAll('.custom-music-checkbox:checked');
            
            // 检查是否有选中的音乐
            if (checkedCheckboxes.length === 0) {
                alert('请选择要删除的自定义音乐！');
                return;
            }
            
            // 确认删除操作
            if (!confirm(`确定要删除选中的 ${checkedCheckboxes.length} 首自定义音乐吗？此操作不可恢复！`)) {
                return;
            }
            
            // 提取要删除的音乐ID
            const idsToDelete = Array.from(checkedCheckboxes).map(cb => parseInt(cb.dataset.musicId));
            
            // 批量删除音乐
            idsToDelete.forEach(id => {
                // 从数组中移除指定ID的音乐
                gameState.uiSettings.customMusic = gameState.uiSettings.customMusic.filter(music => music.id !== id);
                
                // 如果当前选中的是被删除的音乐，切换到默认音乐
                if (gameState.uiSettings.musicSelected === `custom-${id}`) {
                    gameState.uiSettings.musicSelected = 'game-music-1';
                    
                    // 停止当前播放的音乐
                    if (gameState.musicPlayer && gameState.musicPlayer.audio) {
                        gameState.musicPlayer.audio.pause();
                        gameState.musicPlayer.audio.currentTime = 0;
                        gameState.musicPlayer.currentTrack = null;
                    }
                }
            });
            
            // 更新音乐选择列表
            const musicSelectionList = document.getElementById('musicSelectionList');
            // 清空现有选项
            musicSelectionList.innerHTML = `
                <div class="music-option">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="radio" name="musicSelected" value="game-music-1"> 游戏音乐 1
                    </label>
                </div>
                <div class="music-option">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="radio" name="musicSelected" value="game-music-2"> 游戏音乐 2
                    </label>
                </div>
                <div class="music-option">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="radio" name="musicSelected" value="game-music-3"> 游戏音乐 3
                    </label>
                </div>
            `;
            // 重新添加自定义音乐
            if (gameState.uiSettings.customMusic && Array.isArray(gameState.uiSettings.customMusic) && gameState.uiSettings.customMusic.length > 0) {
                gameState.uiSettings.customMusic.forEach(music => {
                    const musicOption = document.createElement('div');
                    musicOption.className = 'music-option';
                    musicOption.innerHTML = `
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" name="musicSelected" value="custom-${music.id}">
                            <input type="checkbox" class="custom-music-checkbox" data-music-id="${music.id}">
                            自定义: ${music.name}
                        </label>
                    `;
                    musicSelectionList.appendChild(musicOption);
                });
            }
            // 设置当前选中的音乐
            const radioButtons = musicSelectionList.querySelectorAll('input[name="musicSelected"]');
            radioButtons.forEach(radio => {
                if (radio.value === gameState.uiSettings.musicSelected) {
                    radio.checked = true;
                }
            });
            // 添加复选框事件监听器
            const checkboxes = musicSelectionList.querySelectorAll('.custom-music-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateDeleteButtonState);
            });
            // 添加单选按钮事件监听器
            radioButtons.forEach(radio => {
                radio.addEventListener('change', function() {
                    gameState.uiSettings.musicSelected = this.value;
                    if (gameState.musicPlayer.isPlaying) {
                        // 切换到新音乐
                        playMusic();
                    }
                    // 保存设置但不关闭模态框
                    localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
                });
            });
            
            // 更新删除按钮状态
            updateDeleteButtonState();
            
            // 保存设置但不关闭模态框
            try {
                localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    // 存储溢出时，移除自定义音乐并重试
                    const settingsWithoutMusic = {...gameState.uiSettings, customMusic: []};
                    try {
                        localStorage.setItem('uiSettings', JSON.stringify(settingsWithoutMusic));
                        alert('存储空间不足，已清空自定义音乐并保存其他设置');
                    } catch (e2) {
                        alert('存储空间已满，无法保存设置');
                    }
                } else {
                    console.error('保存设置时出错:', e);
                    alert('保存设置时出错: ' + e.message);
                }
            }
            
            alert(`已成功删除 ${checkedCheckboxes.length} 首自定义音乐！`);
        }
        
        // 更新删除按钮状态的函数
        function updateDeleteButtonState() {
            const checkedCheckboxes = document.querySelectorAll('.custom-music-checkbox:checked');
            const deleteBtn = document.getElementById('deleteCustomMusicBtn');
            const deleteAllBtn = document.getElementById('deleteAllMusicBtn');
            const customMusic = gameState.uiSettings.customMusic || [];
            
            if (deleteBtn) {
                // 当有自定义音乐被选中时启用删除按钮，否则禁用
                deleteBtn.disabled = checkedCheckboxes.length === 0;
            }
            
            if (deleteAllBtn) {
                // 当有自定义音乐时启用删除所有按钮，否则禁用
                deleteAllBtn.disabled = customMusic.length === 0;
            }
        }
        
        // 在页面加载完成后调用
        window.addEventListener('load', function() {
            // 初始化删除按钮状态
            updateDeleteButtonState();
            
            // 为现有自定义音乐添加兼容性处理
            if (gameState.uiSettings && gameState.uiSettings.customMusic) {
                gameState.uiSettings.customMusic.forEach(music => {
                    // 如果音乐数据不是压缩格式但包含完整的DataURL，则转换为压缩格式
                    if (!music.isCompressed && music.url.startsWith('data:audio/mp3;base64,')) {
                        const base64Prefix = 'data:audio/mp3;base64,';
                        music.url = music.url.substring(base64Prefix.length);
                        music.isCompressed = true;
                    }
                });
                // 保存更新后的设置
                localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
            }
        });
        
        function deleteCustomMusic(id) {
            // 确保gameState.uiSettings和customMusic数组存在
            if (!gameState.uiSettings || !gameState.uiSettings.customMusic) {
                return;
            }
            
            // 从数组中移除指定ID的音乐
            const initialLength = gameState.uiSettings.customMusic.length;
            gameState.uiSettings.customMusic = gameState.uiSettings.customMusic.filter(music => music.id !== id);
            
            // 如果有音乐被删除
            if (gameState.uiSettings.customMusic.length < initialLength) {
                // 如果当前选中的是被删除的音乐，切换到默认音乐
                if (gameState.uiSettings.musicSelected === `custom-${id}`) {
                    gameState.uiSettings.musicSelected = 'game-music-1';
                    
                    // 停止当前播放的音乐
                    if (gameState.musicPlayer && gameState.musicPlayer.audio) {
                        gameState.musicPlayer.audio.pause();
                        gameState.musicPlayer.audio.currentTime = 0;
                        gameState.musicPlayer.currentTrack = null;
                    }
                }
                
                // 更新音乐选择列表
                const musicSelectionList = document.getElementById('musicSelectionList');
                // 清空现有选项
                musicSelectionList.innerHTML = `
                    <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="radio" name="musicSelected" value="game-music-1"> 游戏音乐 1
                        </label>
                    </div>
                    <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="radio" name="musicSelected" value="game-music-2"> 游戏音乐 2
                        </label>
                    </div>
                    <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="radio" name="musicSelected" value="game-music-3"> 游戏音乐 3
                        </label>
                    </div>
                `;
                // 重新添加自定义音乐
                if (gameState.uiSettings.customMusic && Array.isArray(gameState.uiSettings.customMusic) && gameState.uiSettings.customMusic.length > 0) {
                    gameState.uiSettings.customMusic.forEach(music => {
                        const musicOption = document.createElement('div');
                        musicOption.className = 'music-option';
                        musicOption.innerHTML = `
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="radio" name="musicSelected" value="custom-${music.id}">
                                <input type="checkbox" class="custom-music-checkbox" data-music-id="${music.id}">
                                自定义: ${music.name}
                            </label>
                        `;
                        musicSelectionList.appendChild(musicOption);
                    });
                }
                // 设置当前选中的音乐
                const radioButtons = musicSelectionList.querySelectorAll('input[name="musicSelected"]');
                radioButtons.forEach(radio => {
                    if (radio.value === gameState.uiSettings.musicSelected) {
                        radio.checked = true;
                    }
                });
                // 添加复选框事件监听器
                const checkboxes = musicSelectionList.querySelectorAll('.custom-music-checkbox');
                checkboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', updateDeleteButtonState);
                });
                // 添加单选按钮事件监听器
                radioButtons.forEach(radio => {
                    radio.addEventListener('change', function() {
                        gameState.uiSettings.musicSelected = this.value;
                        if (gameState.musicPlayer.isPlaying) {
                            // 切换到新音乐
                            playMusic();
                        }
                        // 保存设置但不关闭模态框
                        localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
                    });
                });
                // 更新删除按钮状态
                updateDeleteButtonState();
                
                // 保存设置但不关闭模态框
                try {
                    localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
                } catch (e) {
                    if (e.name === 'QuotaExceededError') {
                        // 存储溢出时，移除自定义音乐并重试
                        const settingsWithoutMusic = {...gameState.uiSettings, customMusic: []};
                        try {
                            localStorage.setItem('uiSettings', JSON.stringify(settingsWithoutMusic));
                            alert('存储空间不足，已清空自定义音乐并保存其他设置');
                        } catch (e2) {
                            alert('存储空间已满，无法保存设置');
                        }
                    } else {
                        console.error('保存设置时出错:', e);
                        alert('保存设置时出错: ' + e.message);
                    }
                }
                
                alert('自定义音乐已删除！');
            }
        }
        
        function deleteAllCustomMusic() {
            // 确保gameState.uiSettings和customMusic数组存在
            if (!gameState.uiSettings || !gameState.uiSettings.customMusic || gameState.uiSettings.customMusic.length === 0) {
                alert('没有可删除的自定义音乐！');
                return;
            }
            
            // 确认删除操作
            if (!confirm('确定要删除所有自定义音乐吗？此操作不可恢复！')) {
                return;
            }
            
            // 清空自定义音乐数组
            gameState.uiSettings.customMusic = [];
            
            // 如果当前选中的是自定义音乐，切换到默认音乐
            if (gameState.uiSettings.musicSelected.startsWith('custom-')) {
                gameState.uiSettings.musicSelected = 'game-music-1';
                
                // 停止当前播放的音乐
                if (gameState.musicPlayer && gameState.musicPlayer.audio) {
                    gameState.musicPlayer.audio.pause();
                    gameState.musicPlayer.audio.currentTime = 0;
                    gameState.musicPlayer.currentTrack = null;
                }
            }
            
            // 更新音乐选择列表
            const musicSelectionList = document.getElementById('musicSelectionList');
            if (musicSelectionList) {
                // 清空现有选项
                musicSelectionList.innerHTML = `
                    <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="radio" name="musicSelected" value="game-music-1"> 游戏音乐 1
                        </label>
                    </div>
                    <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="radio" name="musicSelected" value="game-music-2"> 游戏音乐 2
                        </label>
                    </div>
                    <div class="music-option">
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="radio" name="musicSelected" value="game-music-3"> 游戏音乐 3
                        </label>
                    </div>
                `;
                // 设置当前选中的音乐
                const radioButtons = musicSelectionList.querySelectorAll('input[name="musicSelected"]');
                radioButtons.forEach(radio => {
                    if (radio.value === gameState.uiSettings.musicSelected) {
                        radio.checked = true;
                    }
                });
                // 添加单选按钮事件监听器
                radioButtons.forEach(radio => {
                    radio.addEventListener('change', function() {
                        gameState.uiSettings.musicSelected = this.value;
                        if (gameState.musicPlayer.isPlaying) {
                            // 切换到新音乐
                            playMusic();
                        }
                        // 保存设置但不关闭模态框
                        localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
                    });
                });
            }
            
            // 更新删除按钮状态
            updateDeleteButtonState();
            
            // 保存设置但不关闭模态框
            try {
                localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
            } catch (e) {
                console.error('保存设置时出错:', e);
                alert('保存设置时出错: ' + e.message);
            }
            
            alert('所有自定义音乐已删除！');
        }
        
        function importCustomMusic() {
            console.log('importCustomMusic函数被调用');
            
            // 确保gameState.uiSettings存在
            if (!gameState.uiSettings) {
                console.log('gameState.uiSettings不存在，正在初始化');
                gameState.uiSettings = JSON.parse(localStorage.getItem('uiSettings')) || {
                    showControls: true,
                    controlsPosition: 'bottom-left',
                    controlsSize: 100,
                    controlsOpacity: 60,
                    showGameInfo: true,
                    showLevelInfo: true,
                    showTimeInfo: true,
                    showMoveInfo: true,
                    showKeyInfo: true,
                    showRoomInfo: true,
                    showPlayerList: true,
                    musicEnabled: false,
                    musicVolume: 50,
                    musicSelected: 'game-music-1',
                    customMusic: [],
                    customX: null,
                    customY: null
                };
            }
    
            const musicName = document.getElementById('customMusicName').value.trim();
            const musicFile = document.getElementById('customMusicFile').files[0];
            
            console.log('获取到的音乐名称:', musicName);
            console.log('获取到的音乐文件:', musicFile);
            
            if (!musicName || !musicFile) {
                console.log('音乐名称或文件为空，取消导入');
                alert('请输入音乐名称并选择MP3文件！');
                return;
            }
            
            console.log('音乐文件类型:', musicFile.type);
            console.log('音乐文件名称:', musicFile.name);
            if (musicFile.type !== 'audio/mp3' && !musicFile.name.endsWith('.mp3')) {
                console.log('文件格式不是MP3，取消导入');
                alert('请选择MP3格式的音频文件！');
                return;
            }
            
            // 限制文件大小（20MB）
            const MAX_FILE_SIZE = 20 * 1024 * 1024;
            console.log('音乐文件大小:', musicFile.size, '字节');
            if (musicFile.size > MAX_FILE_SIZE) {
                console.log('文件大小超过20MB，取消导入');
                alert('音频文件大小不能超过20MB！');
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    // 确保customMusic数组存在
                    if (!gameState.uiSettings.customMusic) {
                        gameState.uiSettings.customMusic = [];
                    }
                    // 生成唯一ID
                    const maxId = gameState.uiSettings.customMusic.length > 0 ? 
                        Math.max(...gameState.uiSettings.customMusic.map(music => music.id)) : 0;
                    const newId = maxId + 1;
                    
                    // 添加到自定义音乐数组 - 压缩保存（移除DataURL头部）
                    let musicData = e.target.result;
                    // 移除DataURL头部，只保存base64字符串
                    const base64Prefix = 'data:audio/mp3;base64,';
                    if (musicData.startsWith(base64Prefix)) {
                        musicData = musicData.substring(base64Prefix.length);
                    }
                    gameState.uiSettings.customMusic.push({
                        id: newId,
                        name: musicName,
                        url: musicData, // 只保存base64字符串
                        fileName: musicFile.name,
                        isCompressed: true // 标记为已压缩
                    });
                    
                    // 更新音乐选择列表
                    const musicSelectionList = document.getElementById('musicSelectionList');
                    if (musicSelectionList) {
                        // 创建新的音乐选项
                        const musicOption = document.createElement('div');
                        musicOption.className = 'music-option';
                        musicOption.innerHTML = `
                            <label style="display: flex; align-items: center; gap: 10px;">
                                <input type="radio" name="musicSelected" value="custom-${newId}">
                                <input type="checkbox" class="custom-music-checkbox" data-music-id="${newId}">
                                自定义: ${musicName}
                            </label>
                        `;
                        musicSelectionList.appendChild(musicOption);
                        
                        // 添加复选框事件监听器
                        const checkbox = musicOption.querySelector('.custom-music-checkbox');
                        if (checkbox) {
                            checkbox.addEventListener('change', updateDeleteButtonState);
                        }
                        
                        // 添加单选按钮事件监听器
                        const radioButton = musicOption.querySelector('input[name="musicSelected"]');
                        if (radioButton) {
                            radioButton.addEventListener('change', function() {
                                gameState.uiSettings.musicSelected = this.value;
                                if (gameState.musicPlayer.isPlaying) {
                                    // 切换到新音乐
                                    playMusic();
                                }
                                // 保存设置但不关闭模态框
                                localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
                            });
                        }
                    }
                    
                    // 自动选择新导入的音乐
                    gameState.uiSettings.musicSelected = `custom-${newId}`;
                    // 设置单选按钮为选中状态
                    const newRadio = document.querySelector(`input[name="musicSelected"][value="custom-${newId}"]`);
                    if (newRadio) {
                        newRadio.checked = true;
                    }
                    
                    // 更新删除按钮状态
                    updateDeleteButtonState();
                    
                    // 保存设置但不关闭模态框
                    localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
                    
                    // 清空输入
                    document.getElementById('customMusicName').value = '';
                    document.getElementById('customMusicFile').value = '';
                    
                    alert('自定义音乐导入成功！');
                } catch (error) {
                    console.error('处理音乐文件时出错:', error);
                    alert('处理音乐文件时出错: ' + error.message);
                }
            };
            
            reader.onerror = function(error) {
                console.error('读取音乐文件失败:', error);
                alert('读取音乐文件失败: ' + error.message);
            };
            
            reader.readAsDataURL(musicFile);

        }        
        function getMusicUrl(trackId) {
            // 检查是否是自定义音乐
            if (trackId.startsWith('custom-')) {
                const customMusicId = parseInt(trackId.split('-')[1]);
                const customMusic = gameState.uiSettings.customMusic.find(music => music.id === customMusicId);
                if (customMusic) {
                    // 如果URL已经是完整的DataURL格式，直接返回
                    if (customMusic.url.startsWith('data:')) {
                        return customMusic.url;
                    }
                    // 否则添加正确的DataURL头部
                    return 'data:audio/mp3;base64,' + customMusic.url;
                }
                return null;
            }
            
            // 预设音乐文件
            const musicFiles = {
                'game-music-1': 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3',
                'game-music-2': 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3',
                'game-music-3': 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3'
            };
            return musicFiles[trackId] || musicFiles['game-music-1'];
        }
        
        // 保存UI设置
        function saveUISettings() {
            // 确保gameState.uiSettings存在
            const oldSettings = gameState.uiSettings || {};
            
            // 获取当前选择的位置
            const controlsPosition = document.getElementById('controlsPosition').value;
            
            // 保存自定义位置坐标，如果是自定义位置且坐标为null，则设置默认值
            let customX = oldSettings.customX;
            let customY = oldSettings.customY;
            
            if (controlsPosition === 'custom' && (customX === null || customY === null)) {
                // 设置默认位置为屏幕中央偏下
                customX = window.innerWidth / 2 - 50;
                customY = window.innerHeight / 2 - 50;
            }
            
            gameState.uiSettings = {
                showControls: document.getElementById('showControlsCheckbox').checked,
                controlsPosition: controlsPosition,
                controlsSize: parseInt(document.getElementById('controlsSize').value),
                controlsOpacity: parseInt(document.getElementById('controlsOpacity').value),
                showGameInfo: document.getElementById('showGameInfoCheckbox').checked,
                showLevelInfo: document.getElementById('showLevelInfo').checked,
                showTimeInfo: document.getElementById('showTimeInfo').checked,
                showMoveInfo: document.getElementById('showMoveInfo').checked,
                showKeyInfo: document.getElementById('showKeyInfo').checked,
                showRoomInfo: document.getElementById('showRoomInfo').checked,
            showPlayerList: document.getElementById('showPlayerListCheckbox').checked,
            // 保存音乐设置
            musicEnabled: document.getElementById('musicEnabledCheckbox').checked,
            musicVolume: parseInt(document.getElementById('musicVolume').value),
            // 从单选按钮中获取选中的音乐
            musicSelected: document.querySelector('input[name="musicSelected"]:checked')?.value || 'game-music-1',
            // 保留自定义位置坐标
            customX: customX,
            customY: customY,
            // 保存自定义音乐，如果存在的话
            customMusic: oldSettings.customMusic || []
            };
            try {
                localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
                document.getElementById('uiSettingsModal').classList.add('hidden');
                applyUISettings();
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    // 存储溢出时，移除自定义音乐并重试
                    const settingsWithoutMusic = {...gameState.uiSettings, customMusic: []};
                    try {
                        localStorage.setItem('uiSettings', JSON.stringify(settingsWithoutMusic));
                        alert('存储空间不足，已清空自定义音乐并保存其他设置');
                        document.getElementById('uiSettingsModal').classList.add('hidden');
                        applyUISettings();
                    } catch (e2) {
                        // 如果仍然失败，进一步简化设置
                        const minimalSettings = {
                            showControls: gameState.uiSettings.showControls,
                            controlsPosition: gameState.uiSettings.controlsPosition,
                            controlsSize: gameState.uiSettings.controlsSize,
                            controlsOpacity: gameState.uiSettings.controlsOpacity,
                            customX: gameState.uiSettings.customX,
                            customY: gameState.uiSettings.customY
                        };
                        try {
                            localStorage.setItem('uiSettings', JSON.stringify(minimalSettings));
                            alert('存储空间严重不足，仅保存了核心控制面板设置');
                            document.getElementById('uiSettingsModal').classList.add('hidden');
                            applyUISettings();
                        } catch (e3) {
                            alert('存储空间已满，无法保存设置');
                        }
                    }
                } else {
                    // 其他错误
                    console.error('保存设置时出错:', e);
                    alert('保存设置时出错: ' + e.message);
                }
            }
        }
class LevelEditor {
    constructor() {
        this.currentLevel = null;
        this.isTesting = false;
        this.initEditor();
    }
    
    initEditor() {
        // 创建Canvas
        this.canvas = document.createElement('canvas');
        this.canvas.width = 800;
        this.canvas.height = 600;
        document.getElementById('editorContainer').appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');
        
        // 网格绘制
        this.cellSize = 32;
        this.drawGrid();
        
        // 工具选择
        this.selectedTool = 'wall';
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.selectedTool = btn.dataset.tool;
            });
        });
        
        // 画布交互
        this.canvas.addEventListener('mousedown', this.handleCanvasClick.bind(this));
    }
    
    startNewLevel() {
        const creator = prompt("输入你的创作者名称:");
        if(!creator || creator.length < 2) {
            alert("创作者名称至少需要2个字符");
            return;
        }
        
        const levelName = prompt("输入关卡名称:");
        if(!levelName) {
            alert("必须输入关卡名称");
            return;
        }
        
        this.currentLevel = {
            meta: {
                version: 2,
                creator: creator,
                name: levelName,
                created: Date.now(),
                verified: false
            },
            data: {
                tiles: Array(20).fill().map(() => Array(20).fill(0)), // 20x20空网格
                entities: [],
                start: { x: 1, y: 1 },
                end: { x: 15, y: 15 }
            }
        };
        
        this.renderMap();
    }
    
    handleCanvasClick(e) {
        if(!this.currentLevel || this.isTesting) return;
        
        const rect = this.canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / this.cellSize);
        const y = Math.floor((e.clientY - rect.top) / this.cellSize);
        
        // 边界检查
        if(x < 0 || y < 0 || x >= 20 || y >= 20) return;
        
        switch(this.selectedTool) {
            case 'wall':
                this.currentLevel.data.tiles[y][x] = 1;
                break;
            case 'start':
                this.currentLevel.data.start = { x, y };
                break;
            case 'spike':
                this.currentLevel.data.entities.push({
                    type: 'spike',
                    x, y,
                    damage: 1
                });
                break;
            // 其他工具...
        }
        
        this.renderMap();
    }
    
    renderMap() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // 绘制网格
        this.drawGrid();
        
        // 绘制地块
        for(let y = 0; y < 20; y++) {
            for(let x = 0; x < 20; x++) {
                if(this.currentLevel.data.tiles[y][x] === 1) {
                    this.ctx.fillStyle = '#886644';
                    this.ctx.fillRect(
                        x * this.cellSize, 
                        y * this.cellSize, 
                        this.cellSize, 
                        this.cellSize
                    );
                }
            }
        }
        
        // 绘制实体
        this.currentLevel.data.entities.forEach(entity => {
            switch(entity.type) {
                case 'spike':
                    this.drawSpike(entity.x, entity.y);
                    break;
                // 其他实体...
            }
        });
        
        // 绘制起点终点
        this.drawStartEnd();
    }
    
    async testLevel() {
        if(!this.currentLevel) return;
        this.isTesting = true;
        
        // 必须通过验证才能分享
        const success = await simulateGameTest(this.currentLevel);
        
        if(success) {
            this.currentLevel.meta.verified = true;
            const shareCode = LevelEncryptor.encrypt(
                this.currentLevel,
                this.currentLevel.meta.creator
            );
            
            alert(`测试成功！你的分享码: ${shareCode}`);
        } else {
            alert("测试失败，必须亲自通关才能分享");
        }
        
        this.isTesting = false;
    }
}
class LevelLoader {
    static loadFromCode(shareCode, creatorName) {
        // 1. 解密数据
        const levelData = LevelEncryptor.decrypt(shareCode, creatorName);
        if(!levelData) {
            throw new Error("无效的分享码或创作者名");
        }
        
        // 2. 验证数据结构
        if(!this.validateLevel(levelData)) {
            throw new Error("关卡数据损坏");
        }
        
        // 3. 验证创作者是否完成过关
        if(!levelData.meta.verified) {
            throw new Error("该关卡未通过创作者验证");
        }
        
        return levelData;
    }
    
    static validateLevel(levelData) {
        return levelData.meta &&
               levelData.meta.version >= 2 &&
               levelData.data &&
               Array.isArray(levelData.data.tiles) &&
               levelData.data.start &&
               levelData.data.end;
    }
}
class LocalLevelManager {
    static STORAGE_KEY = 'savedLevels_v2';
    
    static saveLevel(levelData) {
        const levels = this.getSavedLevels();
        levels.push({
            name: levelData.meta.name,
            code: LevelEncryptor.encrypt(
                levelData, 
                levelData.meta.creator
            ),
            creator: levelData.meta.creator,
            timestamp: Date.now()
        });
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(levels));
    }
    
    static getSavedLevels() {
        return JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '[]');
    }
    
    static deleteLevel(code) {
        const levels = this.getSavedLevels()
            .filter(l => l.code !== code);
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(levels));
    }
    
    static exportAllLevels() {
        const levels = this.getSavedLevels();
        const blob = new Blob([JSON.stringify(levels)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'my_levels_backup.json';
        a.click();
    }
}


const ENCRYPTION_CONFIG = {
    salt: "GAME_LEVEL_SALT_V1", // 修改此值使旧分享码失效
    iv: CryptoJS.enc.Hex.parse("0102030405060708")
};

class LevelEncryptor {
    static encrypt(levelData, creatorName) {
        // 1. 准备数据
        const jsonStr = JSON.stringify(levelData);
        
        // 2. 生成基于创作者名的密钥
        const key = this._generateKey(creatorName);
        
        // 3. AES-CBC加密
        const encrypted = CryptoJS.AES.encrypt(jsonStr, key, {
            iv: ENCRYPTION_CONFIG.iv,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC
        });
        
        // 4. 转为URL安全的Base64
        return encrypted.toString()
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+$/, '');
    }
    
    static decrypt(encryptedCode, creatorName) {
        try {
            // 1. 还原标准Base64
            const standardB64 = encryptedCode
                .replace(/-/g, '+')
                .replace(/_/g, '/') + 
                '='.repeat((4 - encryptedCode.length % 4) % 4);
                
            // 2. 生成密钥
            const key = this._generateKey(creatorName);
            
            // 3. 解密
            const decrypted = CryptoJS.AES.decrypt(standardB64, key, {
                iv: ENCRYPTION_CONFIG.iv,
                padding: CryptoJS.pad.Pkcs7,
                mode: CryptoJS.mode.CBC
            });
            
            // 4. 转为JSON对象
            return JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
        } catch(e) {
            console.error("解密失败:", e);
            return null;
        }
    }
    
    static _generateKey(creatorName) {
        return CryptoJS.PBKDF2(
            creatorName + ENCRYPTION_CONFIG.salt,
            CryptoJS.enc.Hex.parse("0102030405060708"),
            { keySize: 256/32, iterations: 100 }
        );
    }
}
// 应用UI设置
function makeDraggable(element, handle) {
    let isDragging = false;
    let offsetX, offsetY;

    const startDrag = (clientX, clientY) => {
        isDragging = true;
        const rect = element.getBoundingClientRect();
        offsetX = clientX - rect.left;
        offsetY = clientY - rect.top;
        element.style.transition = 'none';
        document.body.style.userSelect = 'none';
    };

    const moveDrag = (clientX, clientY) => {
        if (!isDragging) return;
        
        let newLeft = clientX - offsetX;
        let newTop = clientY - offsetY;
        
        // 边界检查
        newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - element.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, window.innerHeight - element.offsetHeight));
        
        element.style.left = `${newLeft}px`;
        element.style.top = `${newTop}px`;
    };

    const endDrag = () => {
        if (!isDragging) return;
        isDragging = false;
        document.body.style.userSelect = '';
        
        // 保存新位置
        gameState.uiSettings.customX = parseInt(element.style.left);
        gameState.uiSettings.customY = parseInt(element.style.top);
        
        try {
            localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
        } catch (e) {
            if (e.name === 'QuotaExceededError') {
                // 存储溢出时，移除自定义音乐并重试
                const settingsWithoutMusic = {...gameState.uiSettings, customMusic: []};
                try {
                    localStorage.setItem('uiSettings', JSON.stringify(settingsWithoutMusic));
                    console.log('存储空间不足，已清空自定义音乐并保存控制面板位置');
                } catch (e2) {
                    // 如果仍然失败，仅保存控制面板位置的最小设置
                    const minimalSettings = {
                        showControls: gameState.uiSettings.showControls,
                        controlsPosition: gameState.uiSettings.controlsPosition,
                        controlsSize: gameState.uiSettings.controlsSize,
                        controlsOpacity: gameState.uiSettings.controlsOpacity,
                        customX: gameState.uiSettings.customX,
                        customY: gameState.uiSettings.customY
                    };
                    try {
                        localStorage.setItem('uiSettings', JSON.stringify(minimalSettings));
                        console.log('存储空间严重不足，仅保存了核心控制面板设置');
                    } catch (e3) {
                        console.warn('存储空间已满，无法保存控制面板位置');
                    }
                }
            } else {
                console.error('保存控制面板位置时出错:', e);
            }
        }
    };

    // 鼠标事件
    handle.addEventListener('mousedown', (e) => {
        startDrag(e.clientX, e.clientY);
    });

    document.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
    document.addEventListener('mouseup', endDrag);

    // 触摸事件
    handle.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            startDrag(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        if (isDragging) moveDrag(e.touches[0].clientX, e.touches[0].clientY);
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', endDrag);
}

        // 处理控制按钮点击


function handleControlButtonClick(key) {
    // 检查是否是有效的方向键
    if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
        // 直接调用核心移动函数，传入原始按键
        // movePlayer 内部会处理反转逻辑
        movePlayer(key);
    }
}

        // =============== 控制台功能 ===============
function toggleConsole() {
    consoleVisible = !consoleVisible;
    const consoleDiv = document.getElementById('console');
    
    if (consoleVisible) {
        consoleDiv.classList.remove('console-hidden');
        document.getElementById('consoleInput').focus();
        gameState.developerMode = true; // 打开控制台时激活开发者模式
        showNotification('开发者模式已激活！');
    } else {
        consoleDiv.classList.add('console-hidden');
    }
}

function handleConsoleInput(e) {
    // 只阻止特定键的默认行为
    if (e.key === 'Enter') {
        const input = document.getElementById('consoleInput');
        const command = input.value.trim();
        input.value = '';
            
        if (command) {
            consoleHistory.push(command);
            historyIndex = consoleHistory.length;
            executeCommand(command);
        }
    } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (consoleHistory.length > 0) {
            if (historyIndex > 0) historyIndex--;
            document.getElementById('consoleInput').value = consoleHistory[historyIndex] || '';
        }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (consoleHistory.length > 0) {
                    if (historyIndex < consoleHistory.length - 1) historyIndex++;
                    document.getElementById('consoleInput').value = consoleHistory[historyIndex] || '';
                } else {
                    document.getElementById('consoleInput').value = '';
                }
            }
            // 其他按键不阻止默认行为，允许正常输入
        }
function sendKickRequest(playerId, reason) {
    // 找到房主连接
    let hostConnection = null;
    for (const id in gameState.multiplayer.players) {
        if (gameState.multiplayer.players[id].isHost) {
            hostConnection = gameState.multiplayer.connections[id];
            break;
        }
    }
    
    if (hostConnection) {
        hostConnection.send({
            type: 'kick-request',
            playerId: playerId,
            requestorId: gameState.multiplayer.currentPlayerId,
            reason: reason
        });
    }
}
function sendPrivateMessage(playerId, message) {
    if (gameState.multiplayer.connections[playerId]) {
        try {
            gameState.multiplayer.connections[playerId].send({
                type: 'private-message',
                from: gameState.multiplayer.currentPlayerId,
                message: message,
                timestamp: Date.now()
            });
            
            // 给自己也显示一条发送成功的消息
            // showMessageToSelf(`你 → ${gameState.multiplayer.players[playerId].name}: ${message}`);
        } catch (err) {
            console.error('发送消息失败:', err);
        }
    }
}
// 给自己显示消息
function showMessageToSelf(message) {
    const consoleOutput = document.getElementById('consoleOutput');
    consoleOutput.innerHTML += `\n[私聊] ${message}`;
    consoleOutput.scrollTop = consoleOutput.scrollHeight;
    
    // 如果是弹窗形式
    alert(message);
}


function executeCommand(command) {
            const output = document.getElementById('consoleOutput');
            output.innerHTML += `\n> ${command}`;
            output.scrollTop = output.scrollHeight;
            
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);
            
            switch(cmd) {
                case 'help':
                    output.innerHTML += '\n可用命令:';
                    output.innerHTML += '\n- help: 显示帮助信息';
                    output.innerHTML += '\n- dev [password]: 进入开发者模式';
                    output.innerHTML += '\n- win: 立即完成当前关卡';
                    output.innerHTML += '\n- level [n]: 跳转到第n关 (1-80)';
                    output.innerHTML += '\n- unlockall: 解锁所有关卡';
                    output.innerHTML += '\n- reset: 重置当前关卡';
                    output.innerHTML += '\n- clear: 清空控制台输出';
                    output.innerHTML += '\n- twoplayer: 进入多人游戏页面';
                    output.innerHTML += '\n- tp [x] [y]: 传送至一个位置';
                    output.innerHTML += '\n- tp select: 传送至一个位置（地图选择）';
                    output.innerHTML += '\n- tp [playername] select: 传送玩家到选择的位置';
                    output.innerHTML += '\n- kick [playername]: 踢出玩家（房主权限）';
                    output.innerHTML += '\n- protect [playername]: 保护玩家（无敌状态，无法被踢出）';
                    output.innerHTML += '\n- unprotect [playername]: 取消保护玩家';
                    output.innerHTML += '\n- players: 显示玩家列表';
                    output.innerHTML += '\n- msg: 向玩家发出信息';
                    break;
                    
                case 'dev':
                    if (args.length > 0 && args[0] === 'dev') {
                        gameState.devMode = true;
                        output.innerHTML += '\n开发者模式已激活！';
                    } else {
                        output.innerHTML += '\n需要密码！输入 "dev [password]" 激活开发者模式';
                    }
                    break;
                   
                case 'tp':
                    if (!gameState.devMode) {
                        output.innerHTML += '\n请先激活开发者模式 (输入 "dev [password]")';
                        break;
                    }
            
                    if (args.length === 0) {
                        output.innerHTML += '\n用法: tp [玩家] [x] [y] 或 tp [玩家] select';
                        output.innerHTML += '\n示例: tp 5 10 - 传送到坐标(5,10)';
                        output.innerHTML += '\n       tp player1 5 10 - 传送player1到坐标(5,10)';
                        output.innerHTML += '\n       tp select - 进入地图选择模式';
                        output.innerHTML += '\n       tp player1 select - 为player1进入地图选择模式';
                        output.innerHTML += '\n使用 "players" 命令查看所有玩家';
                        break;
                    }
            
                    // 解析玩家参数
                    let targetPlayerId = null;
                    let coordArgs = args;
                    
                    // 检查第一个参数是否是玩家名或ID
                    if (args.length >= 3 || (args.length === 2 && args[1] === 'select')) {
                        const playerIdentifier = args[0];
                        
                        // 查找玩家
                        if (gameState.currentScreen === 'singlePlayerGame') {
                            // 单人游戏只有自己
                            if (playerIdentifier === 'me' || playerIdentifier === 'self') {
                                targetPlayerId = 'singleplayer';
                            } else {
                                output.innerHTML += '\n单人模式下只能传送自己，使用 "me" 或省略玩家参数';
                                break;
                            }
                        } else if (gameState.currentScreen === 'multiplayerGame') {
                            // 在多人游戏中查找玩家
                            const players = gameState.multiplayer.players;
                            for (const id in players) {
                                if (players[id].name === playerIdentifier || id === playerIdentifier) {
                                    targetPlayerId = id;
                                    break;
                                }
                            }
                            
                            if (!targetPlayerId) {
                                output.innerHTML += `\n未找到玩家: ${playerIdentifier}`;
                                output.innerHTML += '\n使用 "players" 命令查看所有玩家';
                                break;
                            }
                        }
                        
                        // 移除玩家参数，保留坐标参数
                        coordArgs = args.slice(1);
                    }
            
                    if (coordArgs[0] === 'select') {
                        // 进入地图选择模式
                        startMapSelection(targetPlayerId);
                        output.innerHTML += `\n已进入地图选择模式，点击地图上的位置进行传送${targetPlayerId ? ' 目标玩家: ' + targetPlayerId : ''}`;
                    } else if (coordArgs.length === 2) {
                        // 直接传送到指定坐标
                        const x = parseInt(coordArgs[0]);
                        const y = parseInt(coordArgs[1]);
                
                        if (isNaN(x) || isNaN(y)) {
                            output.innerHTML += '\n坐标必须是数字';
                            break;
                        }
                    
                        const success = teleportPlayer(x, y, targetPlayerId);
                        if (success) {
                            output.innerHTML += `\n已传送${targetPlayerId ? '玩家 ' + targetPlayerId : '自己'}到坐标(${x},${y})`;
                        }
                    } else {
                        output.innerHTML += '\n用法: tp [玩家] [x] [y] 或 tp [玩家] select';
                    }
                    break;
                case 'msg':
                case 'message':
                    if (!gameState.devMode) {
                        output.innerHTML += '\n请先激活开发者模式 (输入 "dev [password]")';
                        break;
                    }
                    
                    if (args.length < 2) {
                        output.innerHTML += '\n用法: msg [玩家名或ID] [消息内容]';
                        output.innerHTML += '\n示例: msg player1 你好！';
                        output.innerHTML += '\n使用 "players" 命令查看所有玩家';
                        break;
                    }
                    
                    const recipient = args[0];
                    const message = args.slice(1).join(' ');
                    
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // 查找玩家
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === recipient || id === recipient) {
                                playerId = id;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            // 发送消息
                            sendPrivateMessage(playerId, message);
                            output.innerHTML += `\n已向 ${recipient} 发送消息: ${message}`;
                        } else {
                            output.innerHTML += `\n未找到玩家: ${recipient}`;
                        }
                    } else {
                        output.innerHTML += '\n此命令只能在多人游戏中使用';
                    }
                    break;                    
                case 'players':
                    if (!gameState.devMode) {
                        output.innerHTML += '\n请先激活开发者模式 (输入 "dev [password]")';
                        break;
                    }
                    
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        output.innerHTML += '\n当前玩家: 自己 (单人模式)';
                    } else if (gameState.currentScreen === 'multiplayerGame') {
                        output.innerHTML += '\n玩家列表:';
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            const player = players[id];
                            const isCurrent = id === gameState.multiplayer.currentPlayerId;
                            const isProtected = gameState.multiplayer.protectedPlayers[id];
                            output.innerHTML += `\n- ${player.name} (ID: ${id})${isCurrent ? ' [当前玩家]' : ''}${isProtected ? ' [受保护]' : ''}`;
                        }
                    } else {
                        output.innerHTML += '\n此命令只能在游戏中使用';
                    }
                    break;
                    
                case 'twoplayer':
                    if (!gameState.devMode) {
                        output.innerHTML += '\n请激活开发者模式';
                        break;
                    }
                    showScreen('multiplayerSetup');
                    output.innerHTML += '\n已进入多人游戏设置';
                    break;
                    
                case 'kick':
                    if (!gameState.devMode) {
                        output.innerHTML += '\n请先激活开发者模式 (输入 "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\n用法: kick [玩家名或ID] [force]';
                        output.innerHTML += '\n示例: kick player1 - 向房主发送踢出请求';
                        output.innerHTML += '\n       kick player1 force - 强制踢出(无需房主确认)';
                        output.innerHTML += '\n使用 "players" 命令查看所有玩家';
                        break;
                    }
            
                    const playerToKick = args[0];
                    const forceKick = args[1] === 'force'; // 是否强制踢出
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // 查找玩家
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === playerToKick || id === playerToKick) {
                                playerId = id;
                                break;
                            }
                        }
                
                        if (playerId) {
                            // 检查玩家是否受保护
                            if (gameState.multiplayer.protectedPlayers[playerId]) {
                                output.innerHTML += '\n踢出失败：err75937 (玩家受保护)';
                            } else {
                                if (forceKick || !gameState.multiplayer.isHost) {
                                    // 强制踢出或非房主直接发送踢出请求
                                    sendKickRequest(playerId, '控制台踢出' + (forceKick ? '(强制)' : ''));
                                    output.innerHTML += `\n已发送踢出 ${playerToKick} 的请求` + (forceKick ? ' (强制)' : '');
                                } else {
                                    // 房主直接踢人
                                    kickPlayer(playerId, '控制台踢出');
                                    output.innerHTML += `\n已踢出玩家: ${playerToKick}`;
                                }
                            }
                        } else {
                            output.innerHTML += `\n未找到玩家: ${playerToKick}`;
                        }
                    } else {
                        output.innerHTML += '\n此命令只能在多人游戏中使用';
                    }
                    break;
                case 'protect':
                    if (!gameState.devMode) {
                        output.innerHTML += '\n请先激活开发者模式 (输入 "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\n用法: protect [玩家名或ID]';
                        output.innerHTML += '\n示例: protect player1';
                        output.innerHTML += '\n使用 "players" 命令查看所有玩家';
                        break;
                    }
                    
                    const playerToProtect = args[0];
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // 查找玩家
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === playerToProtect || id === playerToProtect) {
                                playerId = id;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            gameState.multiplayer.protectedPlayers[playerId] = true;
                            output.innerHTML += `\n已保护玩家: ${playerToProtect}`;
                            
                            // 广播保护状态
                            broadcast({
                                type: 'player-protected',
                                playerId: playerId,
                                protected: true
                            });
                        } else {
                            output.innerHTML += `\n未找到玩家: ${playerToProtect}`;
                        }
                    } else {
                        output.innerHTML += '\n此命令只能在多人游戏中使用';
                    }
                    break;
                    
                case 'unprotect':
                    if (!gameState.devMode) {
                        output.innerHTML += '\n请先激活开发者模式 (输入 "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\n用法: unprotect [玩家名或ID]';
                        output.innerHTML += '\n示例: unprotect player1';
                        output.innerHTML += '\n使用 "players" 命令查看所有玩家';
                        break;
                    }
                    
                    const playerToUnprotect = args[0];
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // 查找玩家
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === playerToUnprotect || id === playerToUnprotect) {
                                playerId = id;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            delete gameState.multiplayer.protectedPlayers[playerId];
                            output.innerHTML += `\n已取消保护玩家: ${playerToUnprotect}`;
                            
                            // 广播保护状态
                            broadcast({
                                type: 'player-protected',
                                playerId: playerId,
                                protected: false
                            });
                        } else {
                            output.innerHTML += `\n未找到玩家: ${playerToUnprotect}`;
                        }
                    } else {
                        output.innerHTML += '\n此命令只能在多人游戏中使用';
                    }
                    break;
                    
                case 'win':
                    if (!gameState.devMode) {
                        output.innerHTML += '\n请先激活开发者模式 (输入 "dev [password]")';
                        break;
                    }
                    
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        // 完成当前关卡
                        singlePlayerGame.player.x = singlePlayerGame.exit.x;
                        singlePlayerGame.player.y = singlePlayerGame.exit.y;
                        checkSinglePlayerExit();
                        output.innerHTML += '\n当前关卡已通关！';
                    } else {
                        output.innerHTML += '\n只能在游戏关卡中使用此命令';
                    }
                    break;
                    
                case 'level':
                    if (!gameState.devMode) {
                        output.innerHTML += '\n请先激活开发者模式 (输入 "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\n需要关卡号 (1-80)';
                        break;
                    }
                    
                    const levelNum = parseInt(args[0]);
                    if (isNaN(levelNum) || levelNum < 1 || levelNum > 80) {
                        output.innerHTML += '\n无效的关卡号 (必须介于1-80)';
                        break;
                    }
                    
                    gameState.currentLevel = levelNum;
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        initSinglePlayerGame();
                        output.innerHTML += `\n已跳转到第 ${levelNum} 关`;
                    } else {
                        showScreen('singlePlayerGame');
                        output.innerHTML += `\n已开始第 ${levelNum} 关`;
                    }
                    break;
                    
                case 'unlockall':
                    if (!gameState.devMode) {
                        output.innerHTML += '\n请先激活开发者模式 (输入 "dev [password]")';
                        break;
                    }
                    
                    gameState.unlockedLevel = 80;
                    localStorage.setItem('unlockedLevel', 80);
                    output.innerHTML += '\n所有关卡已解锁！';
                    if (gameState.currentScreen === 'singlePlayerLevelSelect') {
                        generateLevelButtons();
                    }
                    break;
                    
                case 'reset':
                    if (!gameState.devMode) {
                        output.innerHTML += '\n请先激活开发者模式 (输入 "dev [password]")';
                        break;
                    }
                    
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        resetSinglePlayerLevel();
                        output.innerHTML += '\n当前关卡已重置';
                    } else {
                        output.innerHTML += '\n只能在游戏关卡中使用此命令';
                    }
                    break;
                    
                case 'clear':
                    output.innerHTML = '> 控制台已清空';
                    break;
                case 'kick-request':
                        console.log(data);
                        // 只有房主能处理踢人请求
                        if (gameState.multiplayer.isHost) {
                            const playerId = data.playerId;
                            const requestorId = data.requestorId;
                            const reason = data.reason || '未知原因';
                            
                            // 检查玩家是否受保护
                            if (gameState.multiplayer.protectedPlayers[playerId]) {
                                // 发送踢出失败消息给请求者
                                if (gameState.multiplayer.connections[requestorId]) {
                                    gameState.multiplayer.connections[requestorId].send({
                                        type: 'kick-failed',
                                        playerId: playerId,
                                        reason: 'err75937'
                                    });
                                }
                            } else {
                                // 踢出玩家
                                kickPlayer(playerId, reason + ' (由玩家请求)');
                                
                                // 通知请求者踢出成功
                                if (gameState.multiplayer.connections[requestorId]) {
                                    gameState.multiplayer.connections[requestorId].send({
                                        type: 'kick-success',
                                        playerId: playerId
                                    });
                                }
                            }
                        }
                        break;
                        
                    case 'kick-success':
                        console.log(data);
                        document.getElementById('consoleOutput').innerHTML += `\n玩家 ${data.playerId} 已被房主踢出`;
                        break;
                    case 'eventsystem':
                        if (args.length > 0) {
                            EventSystem.triggerById(args[0]);
                            output.innerHTML += `\n当前触发了事件: ${args[0]}`;
                        }
                        break;
                        default:
                            output.innerHTML += `\n未知命令: ${command}\n输入 "help" 查看可用命令`;
                    }
            
            output.scrollTop = output.scrollHeight;
        }

function startMapSelection(targetPlayerId = null) {
    // 保存当前游戏状态和目标玩家
    gameState.mapSelectionMode = true;
    gameState.mapSelectionTarget = targetPlayerId;
    
    // 添加地图点击事件监听
    if (gameState.currentScreen === 'singlePlayerGame') {
        singlePlayerGame.canvas.addEventListener('click', handleMapClick);
        document.getElementById('consoleOutput').innerHTML += 
            '\n地图选择模式已激活，点击地图上的位置进行传送';
        console.log('地图选择模式已激活');
        showNotification('地图选择模式已激活，点击地图上的位置进行传送');
    } else if (gameState.currentScreen === 'multiplayerGame') {
        multiplayerCanvas.addEventListener('click', handleMapClick);
        document.getElementById('consoleOutput').innerHTML += 
            `\n地图选择模式已激活，点击地图上的位置进行传送${targetPlayerId ? ' 目标玩家: ' + targetPlayerId : ''}`;
    } else {
        document.getElementById('consoleOutput').innerHTML += 
            '\n地图选择模式只能在游戏中进行';
        gameState.mapSelectionMode = false;
    }
}

function handleMapClick(e) {
    if (!gameState.mapSelectionMode) return;
    
    let canvas, cellSize, maze;
    
    // 根据当前游戏模式获取正确的画布和参数
    if (gameState.currentScreen === 'singlePlayerGame') {
        canvas = singlePlayerGame.canvas;
        cellSize = singlePlayerGame.cellSize;
        maze = singlePlayerGame.maze;
    } else if (gameState.currentScreen === 'multiplayerGame') {
        canvas = document.getElementById('multiplayerCanvas');
        // 计算多人游戏的单元格大小
        const mazeWidth = gameState.multiplayer.maze[0].length;
        cellSize = canvas.width / mazeWidth;
        maze = gameState.multiplayer.maze;
    } else {
        return;
    }
    
    // 获取画布相对于视口的位置
    const rect = canvas.getBoundingClientRect();
    
    // 计算点击位置相对于画布的坐标
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    
    // 转换为迷宫坐标
    const x = Math.floor(clickX / cellSize);
    const y = Math.floor(clickY / cellSize);
    
    // 验证坐标是否有效
    if (x < 0 || x >= maze[0].length || y < 0 || y >= maze.length) {
        document.getElementById('consoleOutput').innerHTML += 
            `\n错误: 坐标(${x},${y})超出迷宫范围`;
        return;
    }
    
    // 检查是否是墙
    if (maze[y][x] === 1) {
        document.getElementById('consoleOutput').innerHTML += 
            `\n错误: 坐标(${x},${y})是墙，无法传送`;
        return;
    }
    
    // 传送玩家
    const success = teleportPlayer(x, y, gameState.mapSelectionTarget);
    
    if (success) {
        document.getElementById('consoleOutput').innerHTML += 
            `\n已传送到坐标(${x},${y})`;
    }
    
    // 退出地图选择模式
    gameState.mapSelectionMode = false;
    gameState.mapSelectionTarget = null;
    showNotification(`传送成功！你已到达坐标(${x},${y})。`);
    
    
    // 移除点击事件监听
    canvas.removeEventListener('click', handleMapClick);
    
    document.getElementById('consoleOutput').innerHTML += 
        `\n地图选择模式已关闭`;
}

// =============== 玩家传送功能 ===============
function teleportPlayer(x, y, targetPlayerId = null) {
    // 检查坐标是否有效
    if (!isValidPosition(x, y)) {
        document.getElementById('consoleOutput').innerHTML += 
            `\n错误: 坐标(${x},${y})无效或不可到达`;
        return false;
    }
    
    if (gameState.currentScreen === 'singlePlayerGame') {
        // 单人游戏只能传送自己
        if (targetPlayerId && targetPlayerId !== 'singleplayer') {
            document.getElementById('consoleOutput').innerHTML += 
                '\n单人模式下只能传送自己';
            return false;
        }
        
        singlePlayerGame.player.x = x;
        singlePlayerGame.player.y = y;
        drawSinglePlayerMaze();
        
        // 检查是否到达出口
        checkSinglePlayerExit();
        
    } else if (gameState.currentScreen === 'multiplayerGame') {
        // 确定要传送的玩家
        let playerId;
        if (targetPlayerId) {
            playerId = targetPlayerId;
        } else {
            playerId = gameState.multiplayer.currentPlayerId;
        }
        
        const player = gameState.multiplayer.players[playerId];
        
        if (!player) {
            document.getElementById('consoleOutput').innerHTML += 
                `\n错误: 找不到玩家 ID ${playerId}`;
            return false;
        }
           
        player.x = x;
        player.y = y;
        
        // 广播
        broadcast({
            type: 'player-teleport',
            playerId: playerId,
            x: x,
            y: y
        });
        
        drawMultiplayerMaze();
        updatePlayerList();
        
        // 检查是否到达出口
        if (x === gameState.multiplayer.exit.x && y === gameState.multiplayer.exit.y) {
            player.reachedExit = true;
            
            // 广播到达出口
            broadcast({
                type: 'player-reached-exit',
                playerId: playerId
            });
            
            // 检查是否所有玩家都到达出口
            checkAllPlayersReachedExit();
        }
    }
    
    return true;
}

// =============== 位置验证 ===============
function isValidPosition(x, y) {
    let maze;
    
    if (gameState.currentScreen === 'singlePlayerGame') {
        maze = singlePlayerGame.maze;
    } else if (gameState.currentScreen === 'multiplayerGame') {
        maze = gameState.multiplayer.maze;
    } else {
        return false;
    }
    
    // 检查迷宫是否有效
    if (!maze || maze.length === 0) {
        return false;
    }
    
    // 检查坐标是否在迷宫范围内
    if (x < 0 || x >= maze[0].length || y < 0 || y >= maze.length) {
        return false;
    }
    
    // 检查是否是墙
    if (maze[y][x] === 1) {
        return false;
    }
    
    return true;
}

        // =============== 单人游戏逻辑 ===============

        function generateLevelButtons() {
            const container = document.getElementById('levelContainer');
            container.innerHTML = '';
            container.style.touchAction = 'pan-y'; // 确保触摸行为优化
            
            // 添加"接着玩关卡X"按钮
            const saveData = findLatestSave();
            if (saveData) {
                const continueButton = document.createElement('button');
                continueButton.className = 'level-button continue';
                continueButton.textContent = `接着玩关卡 ${saveData.currentLevel}`;
                continueButton.onclick = () => {
                    loadGame();
                    showScreen('singlePlayerGame');
                };
                container.appendChild(continueButton);
            }
            // 添加"新关卡"按钮，让用户自己添加关卡
            const newLevelButton = document.createElement('button');
            newLevelButton.className = 'level-button new-level';
            newLevelButton.textContent = '新关卡';
            newLevelButton.onclick = () => {
                // 使用当前最大关卡数+1作为新关卡
                const currentLevels = Math.max(1, ...gameState.completedLevels, gameState.unlockedLevel);
                gameState.currentLevel = currentLevels;
                showScreen('singlePlayerGame');
            };
            container.appendChild(newLevelButton);
            
            // 显示已完成的关卡历史记录（如果有）
            if (gameState.completedLevels.length > 0) {
                const historyDiv = document.createElement('div');
                historyDiv.className = 'level-history';
                historyDiv.innerHTML = '<h3>已完成关卡</h3>';
                
                // 排序并显示已完成的关卡
                [...gameState.completedLevels].sort((a, b) => a - b).forEach(level => {
                    const levelButton = document.createElement('button');
                    levelButton.className = 'level-button completed';
                    levelButton.textContent = level;
                    levelButton.onclick = () => {
                        gameState.currentLevel = level;
                        showScreen('singlePlayerGame');
                    };
                    historyDiv.appendChild(levelButton);
                });
                
                container.appendChild(historyDiv);
            }
        }
        
        // 找到最近的存档
        function findLatestSave() {
            let latestSave = null;
            let latestTime = 0;
            
            for (let i = 0; i < gameState.saveSlots.length; i++) {
                const save = gameState.saveSlots[i];
                if (save && save.timestamp && save.currentLevel) {
                    const saveTime = new Date(save.timestamp).getTime();
                    if (saveTime > latestTime) {
                        latestTime = saveTime;
                        latestSave = save;
                    }
                }
            }
            
            return latestSave;
        }

function initSinglePlayerGame(isLoadingSave = false) {
    window.removeEventListener('keydown', handleSinglePlayerKeyDown);
    singlePlayerGame.canvas = document.getElementById('singlePlayerCanvas');
    singlePlayerGame.ctx = singlePlayerGame.canvas.getContext('2d');
    singlePlayerGame.movingEnemies = [];
    singlePlayerGame.isUnlocking = false;
    singlePlayerGame.unlockTimeLeft = 10;
    clearInterval(singlePlayerGame.unlockTimer);
    
    // 重置路径提示状态
    gameState.showPathHint = false;
    if (gameState.pathHintTimer) {
        clearTimeout(gameState.pathHintTimer);
        gameState.pathHintTimer = null;
    }
    
    if (!isLoadingSave) {
        singlePlayerGame.moveCount = 0;
        singlePlayerGame.doorPosition = null;
        singlePlayerGame.keyPosition = null;
        singlePlayerGame.hasKey = false;
        singlePlayerGame.coinsCollected = 0;
        singlePlayerGame.trapHits = 0;
        const difficulty = Math.min(
            Math.floor(gameState.currentLevel / 7), 
            singlePlayerGame.difficultySettings.length - 1
        );
        const settings = singlePlayerGame.difficultySettings[difficulty];
        singlePlayerGame.maze = generateDifficultMaze(gameState.currentLevel, settings);
        singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
        singlePlayerGame.hasKey = false;
    } else {
        if (!singlePlayerGame.coinsCollected) singlePlayerGame.coinsCollected = 0;
        if (!singlePlayerGame.trapHits) singlePlayerGame.trapHits = 0;
    }
    if (!window.EventSystemInitialized) {
        EventSystem.init();
        window.EventSystemInitialized = true;
    }
    document.getElementById('regularNextButton').style.display = 'none';
    document.getElementById('unsolvableNextButton').style.display = 'none';
    document.getElementById('levelDisplay').textContent = `关卡: ${gameState.currentLevel}`;
    document.getElementById('moveCount').textContent = `移动: ${singlePlayerGame.moveCount}`;
    document.getElementById('keyStatus').textContent = `钥匙: ${singlePlayerGame.hasKey ? '已获得' : '未获得'}`;
    
    // 在每日挑战模式下显示金币信息
    if (gameState.currentChallenge === 'daily') {
        document.getElementById('coinDisplay').style.display = 'flex';
        document.getElementById('coinDisplay').textContent = `金币: ${singlePlayerGame.coinsCollected || 0}`;
    } else {
        document.getElementById('coinDisplay').style.display = 'none';
    }
    
    // 重置加载存档标志
    gameState.isLoadingSave = false;
    
    // 隐藏特殊元素提示
    document.getElementById('keyInfo').classList.add('hidden');
    document.getElementById('unlockTimer').classList.add('hidden');
    document.getElementById('enemyInfo').classList.add('hidden');
    
    // 启动自动保存
    startAutoSave();
    
    // 根据关卡难度设置生成迷宫
    const difficulty = Math.min(
        Math.floor(gameState.currentLevel / 7), 
        singlePlayerGame.difficultySettings.length - 1
    );
    const settings = singlePlayerGame.difficultySettings[difficulty];
    if (gameState.autoSave) {
        loadGame(); // 尝试加载上次的存档
    }
    // 生成标准迷宫
    else if (gameState.specialLevels.includes(gameState.currentLevel)) {
        singlePlayerGame.maze = generateSpiralMaze(settings.size);
        // 设置起点和终点
        const size = settings.size;
        singlePlayerGame.player = { x: 1, y: size - 2 };
        singlePlayerGame.exit = { x: Math.floor(size/2), y: Math.floor(size/2) };
        // 添加移动敌人
        addMovingEnemies(settings.size, gameState.currentLevel === 60 ? 5 : 3);
        // 显示敌人警告
        document.getElementById('enemyInfo').classList.remove('hidden');
        
        // 添加钥匙和门
        addKeyAndDoor(size);
        document.getElementById('keyInfo').classList.remove('hidden');
    } 
    else {
        singlePlayerGame.maze = generateDifficultMaze(gameState.currentLevel, settings);
    }
    
    // 设置玩家和出口位置（非特殊关卡）
    if (!gameState.specialLevels.includes(gameState.currentLevel)) {
        singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
        singlePlayerGame.exit = findExitPosition(singlePlayerGame.maze);
    }
    
    // 调整画布大小
    resizeSinglePlayerCanvas();
    
    // 开始游戏
    startSinglePlayerTimer();
    drawSinglePlayerMaze();
    
    // 添加键盘事件监听
    window.addEventListener('keydown', handleSinglePlayerKeyDown);
    
    // 启动移动陷阱
    if (settings.movingTraps > 0 || 
        gameState.specialLevels.includes(gameState.currentLevel)) {
        startMovingTraps();
    }
    updateNextLevelButtons();
    // 应用UI设置
    applyUISettings();
    if (gameState.specialLevels.includes(gameState.currentLevel)) {
        document.getElementById('enemyInfo').classList.remove('hidden');
    }
}
class GameRecorder {
    constructor() {
        this.frames = [];
        this.startTime = 0;
        this.isRecording = false;
    }

    startRecording(canvas) {
        this.frames = [];
        this.startTime = Date.now();
        this.isRecording = true;
        
        // 使用requestAnimationFrame捕获画面
        const captureFrame = () => {
            if(!this.isRecording) return;
            this.frames.push({
                timestamp: Date.now() - this.startTime,
                imageData: canvas.toDataURL('image/webp', 0.8)
            });
            requestAnimationFrame(captureFrame);
        };
        captureFrame();
    }
    static getAllRecords() {
        return JSON.parse(localStorage.getItem('gameRecords') || "[]")
            .map((record, index) => ({ ...record, id: index }))
            .sort((a,b) => new Date(b.metadata.timestamp) - new Date(a.metadata.timestamp));
    }
    static deleteRecord(id) {
        const records = this.getAllRecords();
        const newRecords = records.filter(r => r.id !== id);
        localStorage.setItem('gameRecords', JSON.stringify(newRecords));
    }
    static getStorageUsage() {
        const records = this.getAllRecords();
        const used = JSON.stringify(records).length / (1024 * 1024);
        const max = parseInt(localStorage.getItem('maxRecordStorage') || "300");
        return { used: used.toFixed(1), max, percent: (used/max*100).toFixed(1) };
    }
    stopRecording() {
        this.isRecording = false;
        this.saveToLocalStorage();
    }

    saveToLocalStorage() {
        const recordData = {
            version: 1.0,
            metadata: {
                level: gameState.currentLevel,
                timestamp: new Date().toISOString(),
                duration: Date.now() - this.startTime,
                playerName: gameState.playerName
            },
            frames: this.frames
        };
        
        // 存储管理
        const records = JSON.parse(localStorage.getItem('gameRecords') || "[]");
        records.push(recordData);
        
        // 自动清理旧录像
        let totalSize = 0;
        const cleanRecords = records.reverse().filter(record => {
            totalSize += JSON.stringify(record).length;
            return totalSize < document.getElementById('maxStorage').value * 1024 * 1024;
        }).reverse();
        
        localStorage.setItem('gameRecords', JSON.stringify(cleanRecords));
    }

    replay(recordId) {
        const record = JSON.parse(localStorage.getItem('gameRecords'))[recordId];
        const replayCanvas = document.createElement('canvas');
        // 实现回放逻辑...
    }
}
class ReplayPlayer {
    constructor() {
        this.currentFrame = 0;
        this.isPlaying = false;
        this.playbackSpeed = 1;
        this.animationFrame = null;
    }
    load(replayData) {
        this.replayData = replayData;
        this.canvas = document.getElementById('replayCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = replayData.metadata.width || 800;
        this.canvas.height = replayData.metadata.height || 600;
        
        document.getElementById('replayTitle').textContent = 
            `关卡${replayData.metadata.level} - ${new Date(replayData.metadata.timestamp).toLocaleString()}`;
        
        this.showFrame(0);
    }
    showFrame(index) {
        this.currentFrame = Math.max(0, Math.min(index, this.replayData.frames.length-1));
        const frame = this.replayData.frames[this.currentFrame];
        
        const img = new Image();
        img.onload = () => {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(img, 0, 0);
            this.updateProgress();
        };
        img.src = frame.imageData;
    }
    play() {
        if(this.isPlaying) return;
        this.isPlaying = true;
        document.getElementById('playBtn').textContent = '⏸️ 暂停';
        
        const startTime = Date.now() - (this.currentFrame * 1000 / this.playbackSpeed);
        
        const playLoop = () => {
            if(!this.isPlaying) return;
            
            const elapsed = (Date.now() - startTime) * this.playbackSpeed;
            const targetFrame = Math.floor(elapsed / 1000 * 60); // 假设60fps
            
            if(targetFrame < this.replayData.frames.length) {
                this.showFrame(targetFrame);
                this.animationFrame = requestAnimationFrame(playLoop);
            } else {
                this.stop();
            }
        };
        
        playLoop();
    }
    stop() {
        this.isPlaying = false;
        cancelAnimationFrame(this.animationFrame);
        document.getElementById('playBtn').textContent = '▶️ 播放';
    }
    updateProgress() {
        const progress = (this.currentFrame / this.replayData.frames.length) * 100;
        document.getElementById('replayProgress').value = progress;
        
        const currentTime = (this.currentFrame / 60).toFixed(1);
        const totalTime = (this.replayData.frames.length / 60).toFixed(1);
        document.getElementById('timeDisplay').textContent = 
            `${formatTime(currentTime)} / ${formatTime(totalTime)}`;
    }
}
// 全局播放器实例
const replayPlayer = new ReplayPlayer();
// 打开回放界面
function showReplayModal() {
    document.getElementById('replayModal').classList.remove('hidden');
    renderReplayList();
    updateStorageInfo();
}
function closeReplayModal() {
    document.getElementById('replayModal').classList.add('hidden');
    replayPlayer.stop();
}
function renderReplayList(filter = 'all') {
    const listEl = document.getElementById('replayList');
    listEl.innerHTML = '';
    
    const records = GameRecorder.getAllRecords();
    
    // 应用筛选
    const filteredRecords = filter === 'recent' 
        ? records.filter(r => new Date(r.metadata.timestamp) > Date.now() - 7*86400000)
        : records;
    
    if(filteredRecords.length === 0) {
        listEl.innerHTML = '<div class="no-records">暂无录像记录</div>';
        return;
    }
    
    filteredRecords.forEach(record => {
        const item = document.createElement('div');
        item.className = 'replay-item';
        item.innerHTML = `
            <div class="replay-meta">
                <strong>关卡 ${record.metadata.level}</strong>
                <span>${new Date(record.metadata.timestamp).toLocaleString()}</span>
            </div>
            <div>
                时长：${formatTime(record.metadata.duration/1000)} | 
                玩家：${record.metadata.playerName || '匿名'}
            </div>
            <div class="replay-actions">
                <button onclick="playReplay(${record.id})">播放</button>
                <button onclick="deleteReplay(${record.id})">删除</button>
            </div>
        `;
        listEl.appendChild(item);
    });
}
function playReplay(id) {
    const records = GameRecorder.getAllRecords();
    const record = records.find(r => r.id === id);
    if(!record) return;
    
    document.getElementById('replayList').classList.add('hidden');
    document.getElementById('playerContainer').classList.remove('hidden');
    
    replayPlayer.load(record);
}
function exitPlayer() {
    replayPlayer.stop();
    document.getElementById('replayList').classList.remove('hidden');
    document.getElementById('playerContainer').classList.add('hidden');
}
function togglePlay() {
    if(replayPlayer.isPlaying) {
        replayPlayer.stop();
    } else {
        replayPlayer.play();
    }
}
function seekForward() {
    replayPlayer.showFrame(replayPlayer.currentFrame + 5*60); // 前进5秒(假设60fps)
}
function seekBack() {
    replayPlayer.showFrame(replayPlayer.currentFrame - 5*60); // 后退5秒
}
function deleteReplay(id) {
    if(confirm('确定删除此录像吗？')) {
        GameRecorder.deleteRecord(id);
        renderReplayList(document.getElementById('replayFilter').value);
        updateStorageInfo();
    }
}
function updateStorageInfo() {
    const usage = GameRecorder.getStorageUsage();
    document.getElementById('storageInfo').textContent = 
        `已使用：${usage.used}MB/${usage.max}MB (${usage.percent}%)`;
}
// 工具函数
function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}
// 在关卡生成逻辑中添加
function generateMovingPlatforms(level) {
    const platformCount = Math.min(Math.floor(level/5), 5);
    singlePlayerGame.movingPlatforms = [];
    
    for(let i=0; i<platformCount; i++) {
        singlePlayerGame.movingPlatforms.push({
            id: i,
            x: Math.floor(Math.random() * (mazeWidth-4)) + 2,
            y: Math.floor(Math.random() * (mazeHeight-4)) + 2,
            path: generatePlatformPath(),
            speed: 0.5 + Math.random(),
            passengers: []
        });
    }
}

function generatePlatformPath() {
    // 生成移动路径：直线/方形/圆形
    const pathType = Math.floor(Math.random() * 3);
    const centerX = Math.floor(Math.random() * mazeWidth);
    const centerY = Math.floor(Math.random() * mazeHeight);
    
    switch(pathType) {
        case 0: // 水平
            return { type: 'horizontal', start: centerX-3, end: centerX+3, y: centerY };
        case 1: // 竖直
            return { type: 'vertical', start: centerY-3, end: centerY+3, x: centerX };
        case 2: // 圆形
            return { type: 'circular', centerX, centerY, radius: 2 };
    }
}
// 在drawSinglePlayerMaze中添加
function drawMovingPlatforms() {
    const ctx = singlePlayerGame.ctx;
    singlePlayerGame.movingPlatforms.forEach(platform => {
        // 更新位置
        updatePlatformPosition(platform);
        
        // 绘制平台
        ctx.fillStyle = '#8BC34A';
        ctx.fillRect(
            platform.x * singlePlayerGame.cellSize,
            platform.y * singlePlayerGame.cellSize,
            singlePlayerGame.cellSize * 2,
            singlePlayerGame.cellSize
        );
        
        // 检测玩家碰撞
        checkPlayerOnPlatform(platform);
    });
}

function updatePlatformPosition(platform) {
    switch(platform.path.type) {
        case 'horizontal':
            platform.x += platform.speed * (platform.movingForward ? 1 : -1);
            if(platform.x > platform.path.end) platform.movingForward = false;
            if(platform.x < platform.path.start) platform.movingForward = true;
            break;
        case 'vertical':
            platform.y += platform.speed * (platform.movingForward ? 1 : -1);
            if(platform.y > platform.path.end) platform.movingForward = false;
            if(platform.y < platform.path.start) platform.movingForward = true;
            break;
        case 'circular':
            const angle = Date.now()/1000 * platform.speed;
            platform.x = platform.path.centerX + Math.cos(angle) * platform.path.radius;
            platform.y = platform.path.centerY + Math.sin(angle) * platform.path.radius;
            break;
    }
}


        // 添加钥匙和门（用于特殊关卡）
        function addKeyAndDoor(size) {
            // 随机放置钥匙（避开起点和终点）
            let keyX, keyY;
            do {
                keyX = Math.floor(Math.random() * (size - 4)) + 2;
                keyY = Math.floor(Math.random() * (size - 4)) + 2;
            } while (singlePlayerGame.maze[keyY][keyX] === 1 || 
                     (keyX === 1 && keyY === size - 2) || 
                     (keyX === Math.floor(size/2) && keyY === Math.floor(size/2)));
            
            // 在钥匙位置放置钥匙（元素值8）
            singlePlayerGame.maze[keyY][keyX] = 8;
            singlePlayerGame.keyPosition = {x: keyX, y: keyY};
            
            // 在出口前放置门（元素值9）
            let doorX = singlePlayerGame.exit.x;
            let doorY = singlePlayerGame.exit.y;
            
            // 确定门的位置（在出口旁边）
            if (doorX < size-1 && singlePlayerGame.maze[doorY][doorX+1] === 0) {
                doorX++;
            } else if (doorX > 0 && singlePlayerGame.maze[doorY][doorX-1] === 0) {
                doorX--;
            } else if (doorY < size-1 && singlePlayerGame.maze[doorY+1][doorX] === 0) {
                doorY++;
            } else if (doorY > 0 && singlePlayerGame.maze[doorY-1][doorX] === 0) {
                doorY--;
            }
            
            singlePlayerGame.maze[doorY][doorX] = 9;
            singlePlayerGame.doorPosition = {x: doorX, y: doorY};
        }

        // 生成螺旋迷宫（用于第30和60关）
        function generateSpiralMaze(size) {
            // 确保奇数尺寸
            if (size % 2 === 0) size++;
            
            const maze = Array(size).fill().map(() => Array(size).fill(1));
            
            // 创建螺旋路径
            let x = 0, y = 0;
            let dx = 0, dy = 1;
            let steps = size - 1;
            let currentSteps = 0;
            let stepCount = 0;
            let turnCount = 0;
            
            for (let i = 0; i < size * size; i++) {
                maze[y][x] = 0;
                
                // 检查是否到达中心
                if (steps <= 0) break;
                
                currentSteps++;
                if (currentSteps === steps) {
                    currentSteps = 0;
                    turnCount++;
                    
                    // 每两次转向减少步长
                    if (turnCount % 2 === 0) {
                        steps--;
                    }
                    
                    // 转向
                    const temp = dx;
                    dx = dy;
                    dy = -temp;
                }
                
                x += dx;
                y += dy;
            }
            
            // 确保出口在中心
            const center = Math.floor(size / 2);
            maze[center][center] = 0;
            
            // 确保起点在左下角
            maze[size - 2][1] = 0;
            
            return maze;
        }
        
        // 添加移动敌人（用于螺旋关卡）
        function addMovingEnemies(size, count) {
            singlePlayerGame.movingEnemies = [];
            
            for (let i = 0; i < count; i++) {
                // 随机位置（避开起点和终点）
                let x, y;
                do {
                    x = Math.floor(Math.random() * (size - 4)) + 2;
                    y = Math.floor(Math.random() * (size - 4)) + 2;
                } while (singlePlayerGame.maze[y][x] === 1 || 
                         (x === 1 && y === size - 2) || 
                         (x === Math.floor(size/2) && y === Math.floor(size/2)));
                
                singlePlayerGame.movingEnemies.push({
                    x, y,
                    dx: Math.random() > 0.5 ? 1 : -1,
                    dy: Math.random() > 0.5 ? 1 : -1,
                    speed: 0.3 + Math.random() * 0.4,
                    color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                    lastMove: 0
                });
            }
        }

        // 验证迷宫是否有解
        function validateMaze(maze) {
            // 创建访问标记数组
            const visited = Array(maze.length).fill().map(() => Array(maze[0].length).fill(false));
            const queue = [{x: 1, y: 1}];
            visited[1][1] = true;
            
            const exit = findExitPosition(maze);
            
            while (queue.length > 0) {
                const cell = queue.shift();
                
                // 如果到达出口，返回true
                if (cell.x === exit.x && cell.y === exit.y) {
                    return true;
                }
                
                // 检查所有方向
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = cell.x + dir.dx;
                    const ny = cell.y + dir.dy;
                    
                    // 检查是否在边界内
                    if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length) {
                        // 检查是否是墙或未被访问
                        if (maze[ny][nx] !== 1 && !visited[ny][nx]) {
                            visited[ny][nx] = true;
                            queue.push({x: nx, y: ny});
                        }
                    }
                }
            }
            
            return false;
        }
        
        // 将validateMaze、findExitPosition和findCriticalPath复制到全局作用域供多人游戏使用
        window.validateMaze = validateMaze;
        window.findExitPosition = findExitPosition;
        window.findCriticalPath = findCriticalPath;
        
        // 备用迷宫生成（确保有解）
        function generateBackupMaze(size) {
            const maze = Array(size).fill().map(() => Array(size).fill(1));
            
            // 创建一条从起点到终点的路径
            for (let y = 1; y < size - 1; y++) {
                for (let x = 1; x < size - 1; x++) {
                    // 创建十字交叉路径
                    if (x === Math.floor(size/2) || y === Math.floor(size/2)) {
                        maze[y][x] = 0;
                    }
                }
            }
            
            // 确保起点和终点
            maze[1][1] = 0;
            maze[size-2][size-1] = 0;
            
            return maze;
        }

function generateDifficultMaze(level, settings) {
    const size = settings.size;
    const seed = level;
    const random = new Random(seed);
    
    // 创建迷宫 (1=墙, 0=路, 2=陷阱, 3=传送门, 4=移动陷阱, 5=单向通道, 8=钥匙, 9=门)
    const maze = Array(size).fill().map(() => Array(size).fill(1));
    
    // 使用改进的随机Prim算法生成迷宫
    const walls = [];
    maze[1][1] = 0;
    walls.push(...getCellWalls(1, 1, maze));
    
    while (walls.length > 0) {
        const wallIndex = Math.floor(random.next() * walls.length);
        const wall = walls[wallIndex];
        walls.splice(wallIndex, 1);
        
        const opposite = getOppositeCell(wall, maze);
        
        if (opposite.x > 0 && opposite.x < size-1 && 
            opposite.y > 0 && opposite.y < size-1 && 
            maze[opposite.y][opposite.x] === 1) {
            
            maze[wall.y][wall.x] = 0;
            maze[opposite.y][opposite.x] = 0;
            walls.push(...getCellWalls(opposite.x, opposite.y, maze));
        }
    }
    
    // 确保出口可达
    ensureExitPath(maze, random);
    
    // 添加陷阱（避开关键路径）
    const criticalPath = findCriticalPath(maze);
    for (let i = 0; i < settings.traps; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(random.next() * (size-2)) + 1;
            y = Math.floor(random.next() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || criticalPath.some(p => p.x === x && p.y === y)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y][x] = 2;
        }
    }
    
    // 添加传送门
    if (level > 10) {
        addTeleporters(maze, random, Math.min(4, Math.floor(level/10)));
    }
    
    // 添加移动陷阱
    singlePlayerGame.movingTraps = [];
    for (let i = 0; i < settings.movingTraps; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(random.next() * (size-2)) + 1;
            y = Math.floor(random.next() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || criticalPath.some(p => p.x === x && p.y === y)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y][x] = 4;
            singlePlayerGame.movingTraps.push({
                x, y, 
                dx: Math.random() > 0.5 ? 1 : -1,
                dy: Math.random() > 0.5 ? 1 : -1,
                speed: 0.5 + Math.random() * 0.5
            });
        }
    }
    
    // 添加单向通道
    for (let i = 0; i < settings.oneWayPaths; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(random.next() * (size-2)) + 1;
            y = Math.floor(random.next() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || criticalPath.some(p => p.x === x && p.y === y)) && attempts < 50);
        
        if (attempts < 50) {
            // 5表示单向通道 (1=右, 2=左, 3=下, 4=上)
            maze[y][x] = 50 + Math.floor(random.next() * 4) + 1;
        }
    }
    
    // 添加金币 (10=金币)
    const coinCount = Math.max(1, Math.floor(size / 3)); // 根据迷宫大小设置金币数量
    for (let i = 0; i < coinCount; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(random.next() * (size-2)) + 1;
            y = Math.floor(random.next() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || criticalPath.some(p => p.x === x && p.y === y)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y][x] = 10; // 10表示金币
        }
    }
    
    // 用户自定义关卡系统，所有关卡都是可解的
    
    return maze;
    
    // 辅助函数：获取单元格的墙
    function getCellWalls(x, y, maze) {
        const walls = [];
        const directions = [
            {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
            {dx: 0, dy: 1}, {dx: 0, dy: -1}
        ];
        
        for (const dir of directions) {
            const nx = x + dir.dx;
            const ny = y + dir.dy;
            
            if (nx >= 0 && nx < maze[0].length && 
                ny >= 0 && ny < maze.length && 
                maze[ny][nx] === 1) {
                walls.push({x: nx, y: ny});
            }
        }
        
        return walls;
    }
    
    // 辅助函数：获取对面的单元格
    function getOppositeCell(wall, maze) {
        const directions = [
            {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
            {dx: 0, dy: 1}, {dx: 0, dy: -1}
        ];
        
        for (const dir of directions) {
            const nx = wall.x + dir.dx;
            const ny = wall.y + dir.dy;
            
            if (nx >= 0 && nx < maze[0].length && 
                ny >= 0 && ny < maze.length && 
                maze[ny][nx] === 0) {
                return {x: wall.x - dir.dx, y: wall.y - dir.dy};
            }
        }
        
        return {x: -1, y: -1};
    }
}
        
        // 找到关键路径（从起点到终点的最短路径）
        function findCriticalPath(maze) {
            const start = {x: 1, y: 1};
            const exit = findExitPosition(maze);
            
            // BFS寻找最短路径
            const visited = Array(maze.length).fill().map(() => Array(maze[0].length).fill(false));
            const queue = [{...start, path: []}];
            visited[start.y][start.x] = true;
            
            while (queue.length > 0) {
                const cell = queue.shift();
                const newPath = [...cell.path, {x: cell.x, y: cell.y}];
                
                if (cell.x === exit.x && cell.y === exit.y) {
                    return newPath;
                }
                
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = cell.x + dir.dx;
                    const ny = cell.y + dir.dy;
                    
                    if (nx >= 0 && nx < maze[0].length && 
                        ny >= 0 && ny < maze.length && 
                        !visited[ny][nx] && maze[ny][nx] !== 1) {
                        visited[ny][nx] = true;
                        queue.push({x: nx, y: ny, path: newPath});
                    }
                }
            }
            
            return [];
        }
        
        function ensureExitPath(maze, random) {
            const size = maze.length;
            const exit = findExitPosition(maze);
            
            // 使用BFS确保起点到出口有路径
            const visited = Array(size).fill().map(() => Array(size).fill(false));
            const queue = [{x: 1, y: 1}];
            visited[1][1] = true;
            
            let found = false;
            
            while (queue.length > 0) {
                const cell = queue.shift();
                
                if (cell.x === exit.x && cell.y === exit.y) {
                    found = true;
                    break;
                }
                
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = cell.x + dir.dx;
                    const ny = cell.y + dir.dy;
                    
                    if (nx >= 0 && nx < size && ny >= 0 && ny < size && 
                        !visited[ny][nx] && maze[ny][nx] !== 1) {
                        visited[ny][nx] = true;
                        queue.push({x: nx, y: ny});
                    }
                }
            }
            
            // 如果路径不存在，打开一条路径
            if (!found) {
                let x = 1, y = 1;
                while (x !== exit.x || y !== exit.y) {
                    if (x < exit.x) x++;
                    else if (x > exit.x) x--;
                    else if (y < exit.y) y++;
                    else if (y > exit.y) y--;
                    
                    maze[y][x] = 0;
                }
            }
        }
        
        function addTeleporters(maze, random, count) {
            const size = maze.length;
            singlePlayerGame.teleporters = [];
            
            for (let i = 0; i < count * 2; i++) {
                let x, y;
                do {
                    x = Math.floor(random.next() * (size-2)) + 1;
                    y = Math.floor(random.next() * (size-2)) + 1;
                } while (maze[y][x] !== 0 || singlePlayerGame.teleporters.some(t => t.x === x && t.y === y));
                
                maze[y][x] = 3;
                singlePlayerGame.teleporters.push({x, y, id: Math.floor(i/2)});
            }
        }

        function findStartPosition(maze) {
            return { x: 1, y: 1 };
        }

        function findExitPosition(maze) {
            const size = maze.length;
            const random = new Random(gameState.currentLevel);
            
            // 在边缘寻找合适的位置作为出口
            const edgePositions = [];
            
            // 右侧边缘 (x = size-1)
            for (let y = 1; y < size-1; y++) {
                if (maze[y][size-2] === 0) {
                    edgePositions.push({x: size-1, y});
                }
            }
            
            // 下侧边缘 (y = size-1)
            for (let x = 1; x < size-1; x++) {
                if (maze[size-2][x] === 0) {
                    edgePositions.push({x, y: size-1});
                }
            }
            
            if (edgePositions.length > 0) {
                const exit = edgePositions[Math.floor(random.next() * edgePositions.length)];
                maze[exit.y][exit.x] = 0;
                return exit;
            }
            
            // 如果没有合适位置，使用右下角
            maze[size-2][size-1] = 0;
            return {x: size-1, y: size-2};
        }

function resizeSinglePlayerCanvas() {
    // 检查maze是否已正确初始化
    if (!singlePlayerGame.maze || singlePlayerGame.maze.length === 0) {
        console.error("Maze not initialized in resizeSinglePlayerCanvas");
        
        // 设置默认画布大小
        singlePlayerGame.canvas.width = 300;
        singlePlayerGame.canvas.height = 300;
        return;
    }
    
    const maxWidth = window.innerWidth - 40;
    const maxHeight = window.innerHeight - 180;
    
    const mazeWidth = singlePlayerGame.maze[0].length;
    const mazeHeight = singlePlayerGame.maze.length;
    
    singlePlayerGame.cellSize = Math.min(
        40,
        Math.floor(maxWidth / mazeWidth),
        Math.floor(maxHeight / mazeHeight)
    );
    
    singlePlayerGame.canvas.width = mazeWidth * singlePlayerGame.cellSize;
    singlePlayerGame.canvas.height = mazeHeight * singlePlayerGame.cellSize;
}

        function drawSinglePlayerMaze() {
            const ctx = singlePlayerGame.ctx;
            ctx.clearRect(0, 0, singlePlayerGame.canvas.width, singlePlayerGame.canvas.height);
            
            // 绘制迷宫
            for (let y = 0; y < singlePlayerGame.maze.length; y++) {
                for (let x = 0; x < singlePlayerGame.maze[y].length; x++) {
                    const cellValue = singlePlayerGame.maze[y][x];
                    
                    // 根据单元格值设置颜色
                    switch(cellValue) {
                        case 1: // 墙
                            ctx.fillStyle = '#333';
                            break;
                        case 2: // 陷阱
                            ctx.fillStyle = '#FF0';
                            break;
                        case 3: // 传送门
                            ctx.fillStyle = '#0FF';
                            break;
                        case 4: // 移动陷阱
                            ctx.fillStyle = '#F0F';
                            break;
                        case 8: // 钥匙
                            ctx.fillStyle = 'gold';
                            break;
                        case 9: // 门
                            ctx.fillStyle = '#8B4513';
                            break;
                        default: // 路
                            if (cellValue >= 50 && cellValue <= 54) {
                                ctx.fillStyle = '#F90'; // 单向通道
                            } else {
                                ctx.fillStyle = '#111';
                            }
                    }
                    
                    ctx.fillRect(x * singlePlayerGame.cellSize, y * singlePlayerGame.cellSize, 
                                singlePlayerGame.cellSize, singlePlayerGame.cellSize);
                    
                    // 绘制特殊元素的图案
                    if (cellValue === 2) { // 陷阱
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            singlePlayerGame.cellSize/4,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (cellValue === 8) { // 钥匙
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            singlePlayerGame.cellSize/4,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        ctx.fillStyle = 'gold';
                        ctx.font = 'bold ' + (singlePlayerGame.cellSize/2) + 'px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('🔑', 
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2
                        );
                    } else if (cellValue === 9) { // 门
                        ctx.fillStyle = '#5D4037';
                        ctx.fillRect(
                            x * singlePlayerGame.cellSize, 
                            y * singlePlayerGame.cellSize, 
                            singlePlayerGame.cellSize, 
                            singlePlayerGame.cellSize
                        );
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/4, 
                            y * singlePlayerGame.cellSize, 
                            singlePlayerGame.cellSize/2, 
                            singlePlayerGame.cellSize
                        );
                    } else if (cellValue >= 50 && cellValue <= 54) { // 单向通道
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold ' + (singlePlayerGame.cellSize/2) + 'px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        let arrow = '';
                        switch(cellValue) {
                            case 51: arrow = '→'; break; // 右
                            case 52: arrow = '←'; break; // 左
                            case 53: arrow = '↓'; break; // 下
                            case 54: arrow = '↑'; break; // 上
                        }
                        
                        ctx.fillText(arrow, 
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2
                        );
                    }
                }
            }
            
            // 绘制出口
            ctx.fillStyle = '#F00';
            ctx.fillRect(singlePlayerGame.exit.x * singlePlayerGame.cellSize, 
                        singlePlayerGame.exit.y * singlePlayerGame.cellSize, 
                        singlePlayerGame.cellSize, singlePlayerGame.cellSize);
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold ' + (singlePlayerGame.cellSize/2) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('出', 
                singlePlayerGame.exit.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                singlePlayerGame.exit.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2
            );
            
            // 绘制玩家
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(
                singlePlayerGame.player.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                singlePlayerGame.player.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                singlePlayerGame.cellSize/2 - 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // 绘制移动敌人（特殊关卡）
            for (const enemy of singlePlayerGame.movingEnemies) {
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(
                    enemy.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                    enemy.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                    singlePlayerGame.cellSize/2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // 绘制敌人眼睛
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(
                    enemy.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/3,
                    enemy.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/3,
                    singlePlayerGame.cellSize/8,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
            
            // 动态绘制路径提示
            if (gameState.showPathHint) {
                const path = findPathToExit(
                    singlePlayerGame.maze,
                    singlePlayerGame.player.x,
                    singlePlayerGame.player.y,
                    singlePlayerGame.exit.x,
                    singlePlayerGame.exit.y
                );
                if (path) drawPathHint(path);
            }
        }

        function startSinglePlayerTimer() {
            clearInterval(singlePlayerGame.timerInterval);
            singlePlayerGame.startTime = Date.now();
            singlePlayerGame.moveCount = 0;
            singlePlayerGame.unlockTimeLeft = 10
            updateSinglePlayerTimer();
            singlePlayerGame.timerInterval = setInterval(updateSinglePlayerTimer, 1000);
        }
function saveGameData() {
    try {
        // 确保gameState对象及其属性存在
        if (!gameState.achievements) gameState.achievements = { allLevelsCompleted: false, multiplayerWins: 0, trapHits: 0, chineseEmojiUsed: false };
        if (!gameState.gameStats) gameState.gameStats = { timeChallengeBest: 0, puzzleLevelsCompleted: 0, totalLevelsCompleted: 0, totalPlayTime: 0, totalMoves: 0, totalTrapsTriggered: 0, totalCoinsCollected: 0, averageMovesPerLevel: 0, completionRate: 0 };
        if (!gameState.settings) gameState.settings = { autoSave: true };
        
        // 安全地序列化数据
        localStorage.setItem('achievements', JSON.stringify(gameState.achievements));
        localStorage.setItem('gameStats', JSON.stringify(gameState.gameStats));
        localStorage.setItem('gameSettings', JSON.stringify(gameState.settings));
    } catch (error) {
        console.error('保存游戏数据失败:', error);
    }
}

// 全局变量跟踪当前打开的模态框
let currentModal = null;
function confirmLoadGame(slot) {
    if (gameState.currentScreen !== 'singlePlayerLevelSelect' && 
        gameState.currentScreen !== 'mainMenu') {
        if (!confirm('是否放弃当前进度并加载存档？')) {
            return;
        }
    }
    
    if (loadGame(slot)) {
        const modal = document.getElementById('saveLoadModal');
        if (modal) modal.remove();
        
        // 根据当前界面做不同处理
        if (gameState.currentScreen === 'singlePlayerGame') {
            // 重新初始化游戏但保留加载的位置
            initSinglePlayerGame(true); // 传入true表示是加载存档
        } else {
            showScreen('singlePlayerGame');
        }
    }
}

function showSaveLoadMenu() {
    // 先关闭任何现有的存档对话框
    const existingModal = document.getElementById('saveLoadModal');
    if (existingModal) {
        document.body.removeChild(existingModal);
    }

    const modal = document.createElement('div');
    modal.id = 'saveLoadModal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    `;
    
    modal.innerHTML = `
        <div style="background: #333; padding: 20px; border-radius: 10px; max-width: 500px; width: 90%;">
            <h3 style="color: white; margin-top: 0; text-align: center;">存档/读档</h3>
            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                <button onclick="saveGame(0)" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">保存到存档1</button>
                <button onclick="confirmLoadGame(0)" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">读取存档1</button>
                <button onclick="deleteSave(0)" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">删除存档1</button>
            </div>
            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                <button onclick="saveGame(1)" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">保存到存档2</button>
                <button onclick="confirmLoadGame(1)" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">读取存档2</button>
                <button onclick="deleteSave(1)" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">删除存档2</button>
            </div>
            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                <button onclick="saveGame(2)" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">保存到存档3</button>
                <button onclick="confirmLoadGame(2)" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">读取存档3</button>
                <button onclick="deleteSave(2)" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">删除存档3</button>
            </div>
            <button id="saveLoadCloseBtn" style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 5px; width: 100%;">关闭</button>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // 添加点击事件监听器
    const closeBtn = document.getElementById('saveLoadCloseBtn');
    closeBtn.addEventListener('click', () => {
        modal.remove();
    });
}



function completeLevel() {
    // 1. 停止所有计时器和动画
    clearInterval(singlePlayerGame.timerInterval);
    clearInterval(singlePlayerGame.movingTrapsInterval);
    clearInterval(singlePlayerGame.unlockTimer);
    
    // 2. 强制隐藏所有按钮
    document.getElementById('regularNextButton').style.display = 'none';
    document.getElementById('unsolvableNextButton').style.display = 'none';
    
    // 3. 更新通关信息显示
    const elapsed = Math.floor((Date.now() - singlePlayerGame.startTime) / 1000);
    document.getElementById('singlePlayerCompleteTime').textContent = 
        `用时: ${Math.floor(elapsed/60)}:${(elapsed%60).toString().padStart(2,'0')}`;
    document.getElementById('singlePlayerCompleteMoves').textContent = 
        `移动次数: ${singlePlayerGame.moveCount}`;
    
    // 4. 更新游戏进度
    if (gameState.currentLevel === gameState.unlockedLevel) {
        gameState.unlockedLevel++;
        localStorage.setItem('unlockedLevel', gameState.unlockedLevel);
    }
    
    if (!gameState.completedLevels.includes(gameState.currentLevel)) {
        gameState.completedLevels.push(gameState.currentLevel);
        localStorage.setItem('completedLevels', JSON.stringify(gameState.completedLevels));
    }
    
    // 5. 显示通关面板
    document.getElementById('singlePlayerComplete').classList.remove('hidden');
    
    // 6. 解除键盘控制
    window.removeEventListener('keydown', handleSinglePlayerKeyDown);
    
    // 7. 保存数据
    recordAchievement('levelComplete', 1);

    addCoins(5);

    // 保存金币到 localStorage
    localStorage.setItem('playerCoins', gameState.coins);
    
    // 8. 检查每日挑战完成情况
    checkDailyChallengeCompletion();
}

function loadNextLevel() {
    if (gameState.currentLevel < 80) {
        gameState.currentLevel++;
        
        // 强制重置所有状态
        document.getElementById('singlePlayerComplete').classList.add('hidden');
        document.getElementById('regularNextButton').style.display = 'none';
        document.getElementById('unsolvableNextButton').style.display = 'none';
        
        initSinglePlayerGame();
    } else {
        alert('恭喜你完成了所有关卡！');
        showScreen('singlePlayerLevelSelect');
    }
}

function resetSinglePlayerLevel() {
    // 强制隐藏按钮
    document.getElementById('regularNextButton').style.display = 'none';
    document.getElementById('unsolvableNextButton').style.display = 'none';
    
    // 重置游戏状态
    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
    singlePlayerGame.moveCount = 0;
    singlePlayerGame.hasKey = false;
    singlePlayerGame.isUnlocking = false;
    singlePlayerGame.unlockTimeLeft = 10;
    clearInterval(singlePlayerGame.unlockTimer);
    
    // 重置路径提示状态
    gameState.showPathHint = false;
    if (gameState.pathHintTimer) {
        clearTimeout(gameState.pathHintTimer);
        gameState.pathHintTimer = null;
    }
    
    // 更新UI
    document.getElementById('moveCount').textContent = `移动: 0`;
    document.getElementById('keyStatus').textContent = `钥匙: 未获得`;
    document.getElementById('unlockTimer').classList.add('hidden');
    
    drawSinglePlayerMaze();
}

        function updateSinglePlayerTimer() {
            const elapsed = Math.floor((Date.now() - singlePlayerGame.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timeDisplay').textContent = 
                `时间: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('moveCount').textContent = `移动: ${singlePlayerGame.moveCount}`;
        }

        function startMovingTraps() {
            if (singlePlayerGame.movingTrapsInterval) {
                clearInterval(singlePlayerGame.movingTrapsInterval);
            }
            
            singlePlayerGame.movingTrapsInterval = setInterval(moveTraps, 500);
        }

        function moveTraps() {
            const maze = singlePlayerGame.maze;
            const size = maze.length;
            const now = Date.now();
            
            // 移动普通陷阱
            for (let i = 0; i < singlePlayerGame.movingTraps.length; i++) {
                const trap = singlePlayerGame.movingTraps[i];
                
                // 尝试移动
                let newX = trap.x + Math.round(trap.dx);
                let newY = trap.y + Math.round(trap.dy);
                
                // 检查边界和墙壁
                if (newX <= 0 || newX >= size-1 || newY <= 0 || newY >= size-1 || 
                    maze[newY][newX] === 1 || maze[newY][newX] >= 50) {
                    // 改变方向
                    trap.dx = Math.random() > 0.5 ? 1 : -1;
                    trap.dy = Math.random() > 0.5 ? 1 : -1;
                    continue;
                }
                
                // 更新陷阱位置
                maze[trap.y][trap.x] = 0; // 清除旧位置
                trap.x = newX;
                trap.y = newY;
                maze[newY][newX] = 4; // 设置新位置
                
                // 检查是否碰到玩家
                if (trap.x === singlePlayerGame.player.x && trap.y === singlePlayerGame.player.y) {
                    // 回到起点
                    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
                    // singlePlayerGame.hasKey = false;
                    // document.getElementById('keyStatus').textContent = `钥匙: 未获得`;
                }
            }
            
            // 移动敌人（特殊关卡）
            for (const enemy of singlePlayerGame.movingEnemies) {
                // 根据时间间隔移动
                if (now - enemy.lastMove < 500 / enemy.speed) continue;
                enemy.lastMove = now;
                
                // 追逐玩家
                const dx = singlePlayerGame.player.x - enemy.x;
                const dy = singlePlayerGame.player.y - enemy.y;
                
                // 优先移动方向（水平或垂直）
                if (Math.abs(dx) > Math.abs(dy)) {
                    enemy.dx = dx > 0 ? 1 : -1;
                    enemy.dy = 0;
                } else {
                    enemy.dx = 0;
                    enemy.dy = dy > 0 ? 1 : -1;
                }
                
                // 尝试移动
                let newX = enemy.x + enemy.dx;
                let newY = enemy.y + enemy.dy;
                
                // 检查是否可移动
                if (newX >= 0 && newX < size && newY >= 0 && newY < size && 
                    maze[newY][newX] !== 1 && maze[newY][newX] < 50) {
                    enemy.x = newX;
                    enemy.y = newY;
                }
                
                // 检查是否碰到玩家
                if (enemy.x === singlePlayerGame.player.x && enemy.y === singlePlayerGame.player.y) {
                    // 回到起点
                    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
                    // singlePlayerGame.hasKey = false;
                    // document.getElementById('keyStatus').textContent = `钥匙: 未获得`;
                }
            }
            
            // 敌人移动后，重新检查路径上是否还有敌人
            if (gameState.showPathHint) {
                const path = findPathToExit(
                    singlePlayerGame.maze,
                    singlePlayerGame.player.x,
                    singlePlayerGame.player.y,
                    singlePlayerGame.exit.x,
                    singlePlayerGame.exit.y
                );
                if (path) checkEnemiesOnPath(path);
            }
            
            drawSinglePlayerMaze();
        }
function movePlayer(rawKey, isFromSystem = false) {
    // 1. 应用反转状态
    let effectiveKey = rawKey;
    if (gameState.controlsReversed) {
        // 反转逻辑
        effectiveKey = {
            'ArrowUp': 'ArrowDown',
            'ArrowDown': 'ArrowUp',
            'ArrowLeft': 'ArrowRight',
            'ArrowRight': 'ArrowLeft'
        }[rawKey] || rawKey;
        console.log('控制反转中:', rawKey, '->', effectiveKey);
    }
    
    // 2. 根据最终确定的方向进行移动
    let newX = 0, newY = 0;
    
    switch(effectiveKey) {
        case 'ArrowUp': newY--; break;
        case 'ArrowDown': newY++; break;
        case 'ArrowLeft': newX--; break;
        case 'ArrowRight': newX++; break;
        default: return; // 不是方向键，不处理
    }
    // 3. 调用已存在的移动逻辑
    if (gameState.currentScreen === 'singlePlayerGame') {
        handleSinglePlayerMoveLogic(newX, newY);
    }
    else if (gameState.currentScreen === 'multiplayerGame') {
        handleMultiplayerMoveLogic(newX, newY);
    }
}

function handleSinglePlayerMoveLogic(dx, dy) {
    const originalPlayerX = singlePlayerGame.player.x;
    const originalPlayerY = singlePlayerGame.player.y;
    
    const newX = originalPlayerX + dx;
    const newY = originalPlayerY + dy;
    
    // 边界检查
    if (newY < 0 || newY >= singlePlayerGame.maze.length || 
        newX < 0 || newX >= singlePlayerGame.maze[0].length) {
        return;
    }

    const cellValue = singlePlayerGame.maze[newY][newX];

    // 墙
    if (cellValue === 1) return;

    // 单向通道
    if (cellValue >= 50 && cellValue <= 54) {
        let allowed = false;
        switch(cellValue) {
            case 51: allowed = (dx > 0); break; // 右
            case 52: allowed = (dx < 0); break; // 左
            case 53: allowed = (dy > 0); break; // 下
            case 54: allowed = (dy < 0); break; // 上
        }
        if (!allowed) return;
    }

    // 陷阱
    if (cellValue === 2 || cellValue === 4) {
        // 检查是否处于无敌状态
        if (!gameState.invincible) {
            recordAchievement('trapHit', 1);
            
            // 在每日挑战模式下，记录陷阱触发次数
            if (gameState.currentChallenge === 'daily' && singlePlayerGame.trapHits !== undefined) {
                singlePlayerGame.trapHits++;
            }
            
            singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
            singlePlayerGame.moveCount++;
            document.getElementById('moveCount').textContent = `移动: ${singlePlayerGame.moveCount}`;
            drawSinglePlayerMaze();
            return;
        }
        // 如果处于无敌状态，允许玩家继续移动
        showNotification('无敌护盾生效，免受陷阱伤害！');
    }

    // 传送门
    if (cellValue === 3 && singlePlayerGame.teleporters.length > 0) {
        const currentPortal = singlePlayerGame.teleporters.find(t => t.x === newX && t.y === newY);
        if (currentPortal) {
            const pairPortals = singlePlayerGame.teleporters.filter(t => 
                t.id === currentPortal.id && (t.x !== newX || t.y !== newY)
            );
            if (pairPortals.length > 0) {
                // 保存当前路径长度和传送门信息
                if (gameState.showPathHint) {
                    const currentPath = findPathToExit(
                        singlePlayerGame.maze, 
                        singlePlayerGame.player.x, 
                        singlePlayerGame.player.y,
                        singlePlayerGame.exit.x, 
                        singlePlayerGame.exit.y
                    );
                    if (currentPath) {
                        gameState.lastPathLength = currentPath.length;
                        gameState.lastPortal = currentPortal;
                    }
                }
                
                const targetPortal = pairPortals[Math.floor(Math.random() * pairPortals.length)];
                // 只更新坐标数值，这是安全的
                singlePlayerGame.player.x = targetPortal.x;
                singlePlayerGame.player.y = targetPortal.y;
                singlePlayerGame.moveCount++;
                document.getElementById('moveCount').textContent = `移动: ${singlePlayerGame.moveCount}`;
                drawSinglePlayerMaze();
                checkSinglePlayerExit();
                
                // 如果当前显示路径提示，重新计算并显示路径
                if (gameState.showPathHint) {
                    const newPath = findPathToExit(
                        singlePlayerGame.maze, 
                        singlePlayerGame.player.x, 
                        singlePlayerGame.player.y,
                        singlePlayerGame.exit.x, 
                        singlePlayerGame.exit.y
                    );
                    if (newPath && gameState.lastPortal && newPath.length > gameState.lastPathLength) {
                        // 新路径更长，改为返回传送门
                        const backToPortalPath = findPathToExit(
                            singlePlayerGame.maze, 
                            singlePlayerGame.player.x, 
                            singlePlayerGame.player.y,
                            gameState.lastPortal.x, 
                            gameState.lastPortal.y
                        );
                        if (backToPortalPath) {
                            drawPathHint(backToPortalPath);
                            // 更新路径长度
                            gameState.lastPathLength = backToPortalPath.length;
                        }
                    } else if (newPath) {
                        drawPathHint(newPath);
                        // 更新路径长度
                        gameState.lastPathLength = newPath.length;
                    }
                }
                
                return; // 传送逻辑结束，不再执行后续的普通移动逻辑
            }
        }
    }

    // 钥匙
    if (cellValue === 8) {
        singlePlayerGame.hasKey = true;
        document.getElementById('keyStatus').textContent = `钥匙: 已获得`;
        singlePlayerGame.maze[newY][newX] = 0; // 移除钥匙
    }

    // 金币
    if (cellValue === 10) {
        addCoins(1); // 收集1个金币
        singlePlayerGame.maze[newY][newX] = 0; // 移除金币
        
        // 在每日挑战模式下更新金币显示
        if (gameState.currentChallenge === 'daily') {
            document.getElementById('coinDisplay').textContent = `金币: ${singlePlayerGame.coinsCollected || 0}`;
        }
    }

    // 门
    if (cellValue === 9) {
        if (singlePlayerGame.hasKey) {
            startUnlockDoor();
            return;
        } else {
            alert("你需要钥匙才能打开这扇门！");
            return;
        }
    }
    
    // 所有检查通过，执行标准移动
    singlePlayerGame.player.x = newX;
    singlePlayerGame.player.y = newY;
    singlePlayerGame.moveCount++;
    document.getElementById('moveCount').textContent = `移动: ${singlePlayerGame.moveCount}`;
    drawSinglePlayerMaze();
    checkSinglePlayerExit();
    
    // 记录移动事件
    let direction = '';
    if (dx === 0 && dy === -1) direction = 'up';
    if (dx === 0 && dy === 1) direction = 'down';
    if (dx === -1 && dy === 0) direction = 'left';
    if (dx === 1 && dy === 0) direction = 'right';
    
    recordGameEvent('move', {
        direction: direction,
        playerX: singlePlayerGame.player.x,
        playerY: singlePlayerGame.player.y,
        moveCount: singlePlayerGame.moveCount,
        timestamp: Date.now()
    });
}


function handleSinglePlayerKeyDown(e) {
    // 检查按键是否是我们关心的方向键
    const key = e.key;
    if(!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
        return; // 不是方向键，不处理
    }
    
    // 【重要】不再阻止默认行为，避免影响页面滚动
    // if (typeof e.preventDefault === 'function') {
    //     e.preventDefault();
    // }
    movePlayer(key);
}



// 更新计时器显示
function updateUnlockTimer() {
    document.getElementById('unlockTimer').textContent = 
        `开门倒计时: ${singlePlayerGame.unlockTimeLeft}秒`;
}
function checkSinglePlayerExit() {
    // 检查玩家是否在出口位置
    if (singlePlayerGame.player.x === singlePlayerGame.exit.x && 
        singlePlayerGame.player.y === singlePlayerGame.exit.y) {
        
        // 如果是特殊关卡且有门的位置
        if (gameState.specialLevels.includes(gameState.currentLevel) && 
            singlePlayerGame.doorPosition) {
            
            // 检查门是否已经打开
            if (singlePlayerGame.maze[singlePlayerGame.doorPosition.y][singlePlayerGame.doorPosition.x] === 0) {
                // 门已打开，可以通关
                completeLevel();
            } else {
                // 门未打开，提示玩家需要钥匙
                alert("你需要找到钥匙并打开门才能通关！");
                // 将玩家移回门前的位置
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                let moved = false;
                for (const dir of directions) {
                    const nx = singlePlayerGame.exit.x + dir.dx;
                    const ny = singlePlayerGame.exit.y + dir.dy;
                    
                    if (nx >= 0 && nx < singlePlayerGame.maze[0].length && 
                        ny >= 0 && ny < singlePlayerGame.maze.length &&
                        singlePlayerGame.maze[ny][nx] === 0) {
                        singlePlayerGame.player.x = nx;
                        singlePlayerGame.player.y = ny;
                        moved = true;
                        break;
                    }
                }
                
                // 如果无法移动玩家，则重置到起点
                if (!moved) {
                    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
                }
                
                drawSinglePlayerMaze();
            }
        } else {
            // 普通关卡，直接通关
            completeLevel();
        }
    }
}

        // =============== 多人游戏Socket.IO功能 ===============
        // 定义setupAsHost函数
        function setupAsHost(roomId) {
            // 生成多人游戏迷宫
            console.log("生成多人游戏迷宫")
            gameState.multiplayer.maze = generateMultiplayerMaze();
            
            // 获取用户选择的颜色
            const playerColor = document.getElementById('playerColor').value;
            
            // 初始化玩家对象
            if (!gameState.multiplayer.players) {
                gameState.multiplayer.players = {};
            }
            
            // 添加自己作为玩家
            gameState.multiplayer.players[gameState.multiplayer.currentPlayerId] = {
                id: gameState.multiplayer.currentPlayerId,
                name: gameState.playerName,
                x: 1,
                y: 1,
                color: playerColor,
                reachedExit: false,
                isHost: gameState.multiplayer.isHost
            };
            
            // 设置房间代码显示
            document.getElementById('multiplayerRoomCode').textContent = 
                `房间: ${roomId}`;
            
            // 开始多人游戏
            console.log("开始多人游戏")
            startMultiplayerGame();
        }

        function connectToMultiplayerGame() {
    console.log("触发连接至多人联机游戏函数")
    
    // 显示状态提示并禁用按钮
    const statusElement = document.getElementById('roomStatus');
    const startBtn = document.getElementById('multiplayerStartBtn');
    const roomCodeInput = document.getElementById('roomCode').value.trim();
    
    if (roomCodeInput) {
        statusElement.textContent = '加入房间中...';
    } else {
        statusElement.textContent = '创建房间中...';
    }
    startBtn.disabled = true;
    
    gameState.playerName = document.getElementById('playerName').value.trim() || '玩家';
    
    // 获取房间密码
    const roomPassword = document.getElementById('roomPassword').value.trim();
    
    // 设置最大玩家数和密码
    if (roomCodeInput === '') {
        gameState.multiplayer.maxPlayers = parseInt(document.getElementById('maxPlayers').value);
        gameState.multiplayer.roomPassword = roomPassword;
    }
    
    // 初始化Socket.IO连接
    try {
        // 连接到Socket.IO服务器
        const socket = io();
        gameState.multiplayer.socket = socket;
        
        // 更新UI显示连接状态
        updateConnectionStatus('connecting');
        
        // 设置Socket.IO事件处理
        socket.on('connect', () => {
            console.log('Socket.IO连接建立，ID:', socket.id);
            gameState.multiplayer.currentPlayerId = socket.id;
            
            if (roomCodeInput) {
                // 加入现有房间
                console.log("加入现有房间")
                gameState.multiplayer.isHost = false;
                gameState.multiplayer.roomCode = roomCodeInput;
                
                socket.emit('joinRoom', {
                    roomId: roomCodeInput,
                    playerName: gameState.playerName,
                    password: roomPassword
                }, (response) => {
                    if (response.success) {
                                statusElement.textContent = '房间加入成功！';
                                gameState.multiplayer.roomCode = response.roomId;
                                // 调用setupAsHost函数，确保能进入游戏地图
                                setupAsHost(response.roomId);
                                startBtn.disabled = false;
                            } else {
                        statusElement.textContent = `加入失败: ${response.message}`;
                        statusElement.style.color = '#FF5252';
                        startBtn.disabled = false;
                        playSound("error");
                        showScreen('multiplayerSetup');
                    }
                });
            } else {
                // 创建新房间
                console.log("创建新房间")
                gameState.multiplayer.isHost = true;
                
                socket.emit('createRoom', {
                    playerName: gameState.playerName,
                    maxPlayers: gameState.multiplayer.maxPlayers,
                    roomName: `${gameState.playerName}的房间`,
                    isPrivate: !!roomPassword,
                    password: roomPassword
                }, (response) => {
                    if (response.success) {
                                statusElement.textContent = '房间创建成功！';
                                gameState.multiplayer.roomCode = response.roomId;
                                // 调用setupAsHost函数，确保能进入游戏地图
                                setupAsHost(response.roomId);
                                startBtn.disabled = false;
                            } else {
                        statusElement.textContent = `创建失败: ${response.message}`;
                        statusElement.style.color = '#FF5252';
                        startBtn.disabled = false;
                        playSound("error");
                        showScreen('multiplayerSetup');
                    }
                });
            }
        });
        
        // 监听断开连接事件
        socket.on('disconnect', () => {
            console.log('Socket.IO连接断开');
            updateConnectionStatus('disconnected');
            const statusElement = document.getElementById('roomStatus');
            statusElement.textContent = '连接已断开';
            statusElement.style.color = '#FF5252';
            startBtn.disabled = false;
        });
        
        // 监听错误事件
        socket.on('connect_error', (err) => {
            console.error('Socket.IO连接错误:', err);
            const statusElement = document.getElementById('roomStatus');
            statusElement.textContent = `连接失败: ${err.message}`;
            statusElement.style.color = '#FF5252';
            startBtn.disabled = false;
            playSound("error");
            showScreen('multiplayerSetup');
        });
        
        // 监听玩家加入事件
        socket.on('player-join', (playerData) => {
            console.log('玩家加入:', playerData);
            // 处理新玩家加入逻辑
            if (gameState.multiplayer.connections) {
                gameState.multiplayer.connections[playerData.id] = { playerName: playerData.name };
            }
            updatePlayerList();
        });
        
        // 监听玩家离开事件
        socket.on('player-leave', (playerId) => {
            console.log('玩家离开:', playerId);
            // 处理玩家离开逻辑
            if (gameState.multiplayer.connections && gameState.multiplayer.connections[playerId]) {
                delete gameState.multiplayer.connections[playerId];
            }
            updatePlayerList();
        });
    } catch (err) {
        console.error('初始化Socket.IO失败:', err);
        
        // 恢复按钮状态
        const statusElement = document.getElementById('roomStatus');
        const startBtn = document.getElementById('multiplayerStartBtn');
        statusElement.textContent = '连接初始化失败，请重试';
        statusElement.style.color = '#FF5252';
        startBtn.disabled = false;
        
        alert('连接初始化失败: ' + err);
    }
}



// 添加通知显示功能
function showNotification(message, duration = 2000) {
    // 移除现有的通知
    const existingNotification = document.getElementById('gameNotification');
    if (existingNotification) {
        existingNotification.remove();
    }

    // 创建新的通知元素
    const notification = document.createElement('div');
    notification.id = 'gameNotification';
    notification.textContent = message;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        animation: fadeIn 0.3s ease-out;
    `;

    document.body.appendChild(notification);

    // 自动消失
    setTimeout(() => {
        notification.style.animation = 'fadeOut 0.3s ease-out';
        setTimeout(() => notification.remove(), 300);
    }, duration);

    // 添加动画关键帧
    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        @keyframes fadeOut {
            from { opacity: 1; transform: translateX(-50%) translateY(0); }
            to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }
    `;
    document.head.appendChild(style);
}



// 退出确认
function showExitConfirmation() {
    const modal = document.createElement('div');
    modal.id = 'exitConfirmationModal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    `;
    
    modal.innerHTML = `
        <div style="background: #333; padding: 20px; border-radius: 10px; width: 300px; max-width: 90%;">
            <h3 style="color: white; margin-top: 0; text-align: center;">退出关卡</h3>
            <p style="color: #ccc; text-align: center;">是否要保存当前进度？</p>
            <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                <button id="saveAndExitBtn" style="padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px;">保存并退出</button>
                <button id="exitWithoutSavingBtn" style="padding: 10px; background: #f44336; color: white; border: none; border-radius: 5px;">不保存退出</button>
                <button id="cancelExitBtn" style="padding: 10px; background: #555; color: white; border: none; border-radius: 5px;">取消</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // 添加事件监听器
    document.getElementById('saveAndExitBtn').addEventListener('click', () => {
        saveGame();  // 退出时保存
        showScreen('singlePlayerLevelSelect');
        modal.remove();
    });
    
    document.getElementById('exitWithoutSavingBtn').addEventListener('click', () => {
        showScreen('singlePlayerLevelSelect');
        modal.remove();
    });
    
    document.getElementById('cancelExitBtn').addEventListener('click', () => {
        modal.remove();
    });
}

function handleMultiplayerData(data, peerId) {
            if (peerId === gameState.multiplayer.currentPlayerId && (data.type !== 'game-state')) {
                return;
            }
            switch(data.type) {
                case 'private-message':
                    // 收到私聊消息
                    console.log(data);
                    const sender = gameState.multiplayer.players[data.from];
                    if (sender) {
                        const msg = `${data.message}`;
                        showMessageToSelf(msg);
                        alert(msg); // 弹出提示
                    }
                    break;
                case 'chat-message':
                    // 收到聊天消息
                    const chatSender = gameState.multiplayer.players[data.from];
                    if (chatSender) {
                        // 使用消息中携带的颜色，如果没有则使用玩家默认颜色
                        const messageColor = data.color || chatSender.color;
                        addChatMessage(chatSender.name, data.message, messageColor, null, data.messageId);
                    }
                    break;
                case 'chat-image':
                    // 收到图片消息
                    const imageSender = gameState.multiplayer.players[data.from];
                    if (imageSender) {
                        addChatMessage(imageSender.name, null, imageSender.color, data.image, data.messageId);
                    }
                    break;
                case 'voice-message':
                    // 收到语音消息
                    const voiceSender = gameState.multiplayer.players[data.from];
                    if (voiceSender) {
                        addVoiceMessage(voiceSender.name, data.voice, data.duration, data.messageId);
                    }
                    break;
                case 'room-full':
                    disconnectMultiplayer();
                    showScreen('multiplayerSetup');
                    alert('房间已满，无法加入');
                    break;
                case 'password-error':
                    disconnectMultiplayer();
                    showScreen('multiplayerSetup');
                    alert('密码错误，无法加入房间');
                    break;
                case 'door-open':
                        gameState.multiplayer.maze[data.y][data.x] = 0;
                        document.getElementById('unlockTimer').classList.add('hidden');
                        gameState.multiplayer.isUnlocking = false;
                        drawMultiplayerMaze();
                    break;  
                case 'player-join':
                    // 新玩家加入
                    console.log(data);
                    
                    // 密码验证
                    if (gameState.multiplayer.isHost && gameState.multiplayer.roomPassword) {
                        const receivedPassword = data.password || '';
                        if (receivedPassword !== gameState.multiplayer.roomPassword) {
                            console.log('密码验证失败:', receivedPassword, '预期:', gameState.multiplayer.roomPassword);
                            gameState.multiplayer.connections[peerId].send({
                                type: 'password-error',
                                message: '密码错误，无法加入房间'
                            });
                            gameState.multiplayer.connections[peerId].close();
                            delete gameState.multiplayer.connections[peerId];
                            return;
                        }
                    }
                    
                    addPlayer(data.player);
                    // 如果是主机，发送当前游戏状态给新玩家
                    if (gameState.multiplayer.isHost) {
                        gameState.multiplayer.connections[peerId].send({
                            type: 'game-state',
                            maze: gameState.multiplayer.maze,
                            players: gameState.multiplayer.players,
                            exit: gameState.multiplayer.exit,
                            teleporters: gameState.multiplayer.teleporters,
                            maxPlayers: gameState.multiplayer.maxPlayers,
                            protectedPlayers: gameState.multiplayer.protectedPlayers
                        });
                    }
                    drawMultiplayerMaze();
                    break;
                case 'key-pickup':
                    if (gameState.multiplayer.players[data.playerId]) {
                        gameState.multiplayer.players[data.playerId].hasKey = true;
                        delete gameState.multiplayer.keyPosition;
                        drawMultiplayerMaze();
                    }
                    break;
                case 'game-state':
                        // 收到游戏状态（客户端）
                        gameState.multiplayer.maze = data.maze;
                        gameState.multiplayer.players = data.players;
                        gameState.multiplayer.exit = data.exit;
                        gameState.multiplayer.teleporters = data.teleporters;
                        gameState.multiplayer.movingEnemies = data.movingEnemies || [];
                        gameState.multiplayer.keyPosition = data.keyPosition || null;
                        gameState.multiplayer.doorPosition = data.doorPosition || null;
                        gameState.multiplayer.maxPlayers = data.maxPlayers;
                        gameState.multiplayer.protectedPlayers = data.protectedPlayers || {};
                        
                        // 添加自己到玩家列表
                        if (!gameState.multiplayer.players[gameState.multiplayer.currentPlayerId]) {
                            gameState.multiplayer.players[gameState.multiplayer.currentPlayerId] = {
                                id: gameState.multiplayer.currentPlayerId,
                                name: gameState.playerName,
                                x: 1,
                                y: 1,
                                color: getRandomColor(),
                                reachedExit: false
                            };
                        }
                        
                        // 开始游戏
                        startMultiplayerGame();
                        break;
                    
                case 'enemy-move':
                    // 更新敌人位置
                    if (data.enemies) {
                        gameState.multiplayer.movingEnemies = data.enemies;
                        drawMultiplayerMaze();
                    }
                    break;
                case 'player-move':
                    if (peerId === gameState.multiplayer.currentPlayerId) {
                        break;
                    }
                    // 玩家移动
                    if (gameState.multiplayer.players[peerId]) {
                        gameState.multiplayer.players[peerId].x = data.x;
                        gameState.multiplayer.players[peerId].y = data.y;
                        
                        // 检查是否到达出口
                        if (data.x === gameState.multiplayer.exit.x && 
                            data.y === gameState.multiplayer.exit.y) {
                            gameState.multiplayer.players[peerId].reachedExit = true;
                            
                            // 广播玩家到达出口
                            broadcast({
                                type: 'player-reached-exit',
                                playerId: peerId
                            });
                        }
                        
                        drawMultiplayerMaze();
                        updatePlayerList();
                    }
                    break;
                case 'key-pickup':
                        if (gameState.multiplayer.players[data.playerId]) {
                            gameState.multiplayer.players[data.playerId].hasKey = true;
                            delete gameState.multiplayer.keyPosition;
                            drawMultiplayerMaze();
                        }
                        break;
                        
                case 'door-open':
                        gameState.multiplayer.maze[data.y][data.x] = 0;
                        drawMultiplayerMaze();
                        break;
                        
                case 'enemy-move':
                        if (gameState.multiplayer.movingEnemies) {
                            gameState.multiplayer.movingEnemies = data.enemies;
                            drawMultiplayerMaze();
                        }
                        break;    
                case 'teleport-request':
                    // 处理传送请求（只有主机会收到）
                    console.log(data);
                    if (gameState.multiplayer.isHost) {
                        const teleporter = gameState.multiplayer.teleporters.find(t => 
                            t.x === data.teleporterX && t.y === data.teleporterY);
                        
                        if (teleporter && gameState.multiplayer.players[data.playerId]) {
                            // 传送玩家
                            gameState.multiplayer.players[data.playerId].x = teleporter.pairX;
                            gameState.multiplayer.players[data.playerId].y = teleporter.pairY;
                            
                            // 广播传送
                            broadcast({
                                type: 'player-teleport',
                                playerId: data.playerId,
                                x: teleporter.pairX,
                                y: teleporter.pairY
                            });
                            
                            drawMultiplayerMaze();
                            updatePlayerList();
                        }
                    }
                    break;
                    
                case 'player-teleport':
                    console.log(data);
                    // 处理玩家传送
                    if (gameState.multiplayer.players[data.playerId]) {
                        gameState.multiplayer.players[data.playerId].x = data.x;
                        gameState.multiplayer.players[data.playerId].y = data.y;
                        drawMultiplayerMaze();
                        updatePlayerList();
                    }
                    break;
                    
                case 'player-reached-exit':
                    console.log(data);
                    // 玩家到达出口
                    if (gameState.multiplayer.players[data.playerId]) {
                        gameState.multiplayer.players[data.playerId].reachedExit = true;
                        
                        // 检查是否所有玩家都到达出口
                        checkAllPlayersReachedExit();
                        
                        updatePlayerList();
                    }
                    break;
                    
                case 'player-joined':
                    console.log(data);
                    // 新玩家加入通知
                    if (!gameState.multiplayer.players[data.player.id]) {
                        gameState.multiplayer.players[data.player.id] = data.player;
                        updatePlayerList();
                        drawMultiplayerMaze();
                    }
                    break;
                    
                case 'player-kicked':
                    console.log(data);
                    // 玩家被踢出通知
                    if (data.playerId === gameState.multiplayer.currentPlayerId) {
                        alert(`你已被管理员踢出房间${data.reason ? `，原因：${data.reason}` : ''}`);
                        disconnectMultiplayer();
                        showScreen('mainMenu'); // 直接返回主页面
                    } else {
                        removePlayer(data.playerId);
                    }
                    break;
                    
                case 'player-protected':
                    console.log(data);
                    // 玩家保护状态更新
                    if (data.protected) {
                        gameState.multiplayer.protectedPlayers[data.playerId] = true;
                    } else {
                        delete gameState.multiplayer.protectedPlayers[data.playerId];
                    }
                    updatePlayerList();
                    break;
                case 'music-command':
                    console.log(data);
                    // 音乐控制命令
                    const audio = document.getElementById('gameAudio');
                    if (audio) {
                        if (data.command === 'play') {
                            // 如果有Base64音频数据，使用Base64数据
                            if (data.audioData) {
                                audio.src = data.audioData;
                            }
                            // 如果有URL参数，更新音频源
                            else if (data.url) {
                                audio.src = data.url;
                            }
                            // 尝试播放音乐
                            audio.play()
                                .then(() => {
                                    // 播放成功
                                    const musicInfo = data.fileName || data.url || '音乐';
                                    addChatMessage('系统', `背景音乐已开始播放: ${musicInfo}`, '#4CAF50');
                                })
                                .catch(error => {
                                    console.error('播放音乐失败:', error);
                                    // 第一次播放失败，显示确认弹窗
                                    const musicUrl = data.audioData || data.url;
                                    showMusicPlayConfirmModal(musicUrl);
                                });
                        } else if (data.command === 'stop') {
                            audio.pause();
                            audio.currentTime = 0;
                            addChatMessage('系统', '背景音乐已停止', '#4CAF50');
                        }
                    }
                    break;
                    
                case 'chat-recall':
                    console.log(data);
                    // 处理消息撤回
                    const chatContainers = [
                        document.getElementById('chatMessages'),
                        document.getElementById('chatMessagesModal')
                    ];
                    
                    chatContainers.forEach(chatMessages => {
                        if (chatMessages) {
                            const messageElement = chatMessages.querySelector(`[data-message-id="${data.messageId}"]`);
                            if (messageElement) {
                                // 检查是否是自己的消息
                                const isOwnMessage = messageElement.dataset.sender === gameState.multiplayer.currentPlayerId;
                                
                                if (isOwnMessage) {
                                    // 自己的消息：显示撤回提示
                                    messageElement.innerHTML = '<strong>系统消息:</strong> 消息已撤回';
                                    messageElement.style.color = '#888';
                                    
                                    // 3秒后自动删除撤回提示
                                    setTimeout(() => {
                                        if (messageElement.parentElement) {
                                            messageElement.parentElement.removeChild(messageElement);
                                        }
                                    }, 3000);
                                } else {
                                    // 别人的消息：隐藏内容并显示撤回通知
                                    // 隐藏所有子元素（文本、图片、音频、按钮）
                                    const allChildren = messageElement.children;
                                    for (let i = 0; i < allChildren.length; i++) {
                                        allChildren[i].style.display = 'none';
                                    }
                                    
                                    // 显示撤回通知
                                    const senderName = gameState.multiplayer.players[data.from]?.name || '玩家';
                                    messageElement.innerHTML = `<strong>系统消息:</strong> ${senderName} 撤回了一条消息`;
                                    
                                    // 3秒后自动删除撤回提示
                                    setTimeout(() => {
                                        if (messageElement.parentElement) {
                                            messageElement.parentElement.removeChild(messageElement);
                                        }
                                    }, 3000);
                                }
                            }
                        }
                    });
                    break;
                    
                case 'kick-player':
                    console.log(data);
                    // 踢出玩家请求（只有主机会收到）
                    if (gameState.multiplayer.isHost) {
                        const playerId = data.playerId;
                        const reason = data.reason || '未知原因';
                        
                        // 检查玩家是否受保护
                        if (gameState.multiplayer.protectedPlayers[playerId]) {
                            // 发送踢出失败消息
                            gameState.multiplayer.connections[data.requestorId].send({
                                type: 'kick-failed',
                                playerId: playerId,
                                reason: 'err75937'
                            });
                        } else {
                            // 踢出玩家
                            kickPlayer(playerId, reason);
                        }
                    }
                    break;
                    
                case 'kick-failed':
                    console.log(data);
                    // 踢出失败通知
                    alert(`踢出玩家失败: ${data.reason}`);
                    break;
            }
        }

        function addPlayer(player) {
            gameState.multiplayer.players[player.id] = {
                ...player,
                x: 1,
                y: 1,
                reachedExit: false
            };
            
            // 广播新玩家加入（除了自己）
            broadcast({
                type: 'player-joined',
                player: gameState.multiplayer.players[player.id]
            }, player.id);
            
            updatePlayerList();
            drawMultiplayerMaze();
        }

        function removePlayer(playerId) {
            delete gameState.multiplayer.players[playerId];
            delete gameState.multiplayer.connections[playerId];
            delete gameState.multiplayer.protectedPlayers[playerId];
            
            updatePlayerList();
            drawMultiplayerMaze();
        }


function broadcast(data, excludePlayerId = null) {
    for (const connId in gameState.multiplayer.connections) {
        if (connId !== excludePlayerId) {
            const connection = gameState.multiplayer.connections[connId];
            if (connection.open) {  // 只有连接打开时才发送
                try {
                    connection.send(data);
                } catch (err) {
                    console.error('广播错误:', err);
                    // 如果发送失败，处理连接失效的情况
                    removePlayer(connId);
                }
            }
        }
    }
}

        function startMultiplayerGame() {
            gameState.multiplayer.connected = true;
            gameState.multiplayer.moveCount = 0;
            gameState.multiplayer.hasKey = false;
            gameState.multiplayer.isUnlocking = false;
            gameState.multiplayer.unlockTimeLeft = 10;
            clearInterval(gameState.multiplayer.unlockTimer);
            
            // 如果是螺旋迷宫，显示敌人警告
            if (gameState.multiplayer.movingEnemies) {
                document.getElementById('enemyInfo').classList.remove('hidden');
                document.getElementById('keyInfo').classList.remove('hidden');
            } else {
                document.getElementById('enemyInfo').classList.add('hidden');
                document.getElementById('keyInfo').classList.add('hidden');
            }
                    
            // 设置房间代码显示
            document.getElementById('multiplayerRoomCode').textContent = 
                `房间: ${gameState.multiplayer.roomCode}`;
            document.getElementById('multiplayerMoveCount').textContent = `移动: 0`;
            updatePlayerCount();

            // 初始化画布
            console.log("初始化画布")
            initMultiplayerCanvas();
            // 开始计时
            console.log("开始计时")
            startMultiplayerTimer();
            
            // 更新连接状态
            console.log("更新连接状态")
            updateConnectionStatus('connected');
            
            // 显示游戏界面
            console.log("显示游戏画面")
            showScreen('multiplayerGame');
            
            // 移除单人游戏的键盘事件监听器，避免重复处理
            window.removeEventListener('keydown', handleSinglePlayerKeyDown);
            
            // 添加多人游戏的键盘事件监听器
            window.addEventListener('keydown', handleMultiplayerKeyDown);

            function gameLoop() {
                // updateMultiplayerGame();
                EventSystem.update();
                requestAnimationFrame(gameLoop);
            }
            
            // 启动游戏循环
            gameLoop();
            // 应用UI设置
            console.log("应用UI设置")
            applyUISettings();
        }

function handleMultiplayerMoveLogic(dx, dy) {
    // 1. 获取当前回合的玩家对象
    const currentPlayer = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
    if (!currentPlayer || currentPlayer.reachedExit) {
        return; // 如果玩家不存在或已经到达终点，则不做任何事
    }

    // 2. 计算新的目标位置
    const newX = currentPlayer.x + dx;
    const newY = currentPlayer.y + dy;

    // 3. 边界检查
    if (newY < 0 || newY >= gameState.multiplayer.maze.length || 
        newX < 0 || newX >= gameState.multiplayer.maze[0].length) {
        return;
    }

    const cellValue = gameState.multiplayer.maze[newY][newX];
    
    // 4. 规则检查
    // --------------------------------------------------

    // 4.1 墙
    if (cellValue === 1) return;

    // 4.2 陷阱
    if (cellValue === 2) {
        // 如果玩家是主机且受保护（无敌），则忽略陷阱
        if (currentPlayer.isHost && gameState.multiplayer.protectedPlayers[currentPlayer.id]) {
            console.log('主机玩家无敌，无视陷阱');
        } else {
            // 普通玩家，回到起点
            currentPlayer.x = 1;
            currentPlayer.y = 1;
            gameState.multiplayer.moveCount++;
            document.getElementById('multiplayerMoveCount').textContent = `移动: ${gameState.multiplayer.moveCount}`;
            console.log('踩到陷阱，回到起点！');
            
            // 【关键修复 1】即使回到起点，也需要广播这次移动，以更新所有玩家的视图
            if (currentPlayer.isHost) {
                // 主机玩家移动后，需要更新所有玩家的视图
                broadcast({
                    type: 'player-move',
                    playerId: currentPlayer.id,
                    x: currentPlayer.x,
                    y: currentPlayer.y
                });
            } else {
                // 普通玩家只需要更新自己的视图
                drawMultiplayerMaze();
                updatePlayerList();
            }
            return; // 陷阱处理结束，不再执行后续逻辑
        }
    }
    
    // 4.3 传送门
    if (cellValue === 3) {
        // 找到传送门对象
        const teleporter = gameState.multiplayer.teleporters.find(t => t.x === newX && t.y === newY);
        if (teleporter) {
            // 执行传送
            currentPlayer.x = teleporter.pairX;
            currentPlayer.y = teleporter.pairY;
            
            // 【关键修复 2】传送操作完成后，必须广播新位置
            broadcast({
                type: 'player-teleport',
                playerId: currentPlayer.id,
                x: currentPlayer.x,
                y: currentPlayer.y
            });
            
            gameState.multiplayer.moveCount++;
            document.getElementById('multiplayerMoveCount').textContent = `移动: ${gameState.multiplayer.moveCount}`;
            
            console.log('传送!');

            drawMultiplayerMaze();
            updatePlayerList();
            // 传送后检查是否到达出口
            checkPlayerAtExit(currentPlayer);
            return; // 传送逻辑结束
        }
    }

    // 4.4 钥匙
    if (cellValue === 8) {
        // 检查玩家是否受保护，防止其他玩家偷钥匙
        if (gameState.multiplayer.protectedPlayers[currentPlayer.id]) {
            console.log('玩家受保护，其他玩家无法捡钥匙');
        } else {
            currentPlayer.hasKey = true;
            gameState.multiplayer.maze[newY][newX] = 0; // 移除钥匙
            delete gameState.multiplayer.keyPosition;

            // 广播钥匙拾取事件
            broadcast({
                type: 'key-pickup',
                playerId: currentPlayer.id
            });
            console.log('拿到钥匙!');
        }
    }

    // 4.5 门
    if (cellValue === 9) {
        if (currentPlayer.hasKey) {
            startMultiplayerUnlockDoor();
            return; // 开门倒计时开始，本次移动结束
        } else {
            alert("你需要钥匙才能打开这扇门！");
            return; // 没有钥匙，开门失败，本次移动结束
        }
    }

    // 5. 执行标准移动
    // --------------------------------------------------
    // 如果通过了所有检查，说明是有效的普通移动
    currentPlayer.x = newX;
    currentPlayer.y = newY;
    
    gameState.multiplayer.moveCount++;
    document.getElementById('multiplayerMoveCount').textContent = `移动: ${gameState.multiplayer.moveCount}`;
    
    // 广播移动
    broadcast({
        type: 'player-move',
        playerId: currentPlayer.id,
        x: currentPlayer.x,
        y: currentPlayer.y
    });
    
    console.log('移动!');

    // 6. 绘制UI和检查出口
    drawMultiplayerMaze();
    updatePlayerList();
    
    // 检查是否到达出口
    checkPlayerAtExit(currentPlayer);
}

/**
 * 检查特定玩家是否到达了出口，并触发相应逻辑。
 * @param {object} player - 要检查的玩家对象
 */
function checkPlayerAtExit(player) {
    const exit = gameState.multiplayer.exit;
    if (player.x === exit.x && player.y === exit.y) {
        // 玩家到达出口
        player.reachedExit = true;
        console.log(`${player.name} 到达了出口！`);

        // 广播到达出口事件
        broadcast({
            type: 'player-reached-exit',
            playerId: player.id
        });

        // 检查是否所有人都到了
        checkAllPlayersReachedExit();
    }
}

        function initMultiplayerCanvas() {
            const canvas = document.getElementById('multiplayerCanvas');
            const ctx = canvas.getContext('2d');
            
            // 调整画布大小
            console.log("初始化画布")
            const maxWidth = window.innerWidth - 40;
            const maxHeight = window.innerHeight - 180;
            
            // 确保迷宫已初始化
            if (!gameState.multiplayer.maze || gameState.multiplayer.maze.length === 0) {
                console.error("多人游戏迷宫未初始化");
                canvas.width = 300;
                canvas.height = 300;
                return;
            }
            
            const mazeWidth = gameState.multiplayer.maze[0].length;
            const mazeHeight = gameState.multiplayer.maze.length;
            
            const cellSize = Math.min(30, Math.floor(maxWidth / mazeWidth), 
                                     Math.floor(maxHeight / mazeHeight));
            
            canvas.width = mazeWidth * cellSize;
            canvas.height = mazeHeight * cellSize;
            
            // 保存单元格大小供后续使用
            gameState.multiplayer.cellSize = cellSize;
            
            // 绘制初始迷宫
            drawMultiplayerMaze();
            
            // 更新玩家列表
            updatePlayerList();
        }

        function handleMultiplayerKeyDown(e) {
            if (!gameState.multiplayer.connected) return;
            
            // 检查是否在聊天输入框中输入，避免阻止输入
            const chatInput = document.getElementById('chatInput');
            const chatInputModal = document.getElementById('chatInputModal');
            if ((chatInput && document.activeElement === chatInput) || 
                (chatInputModal && document.activeElement === chatInputModal)) {
                return;
            }
            
            // 只在方向键时处理
            if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                return;
            }
            
            e.preventDefault();
            const player = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
            if (!player || player.reachedExit) return;
            
            let newX = player.x;
            let newY = player.y;
            
            switch(e.key) {
                case 'ArrowUp': newY--; break;
                case 'ArrowDown': newY++; break;
                case 'ArrowLeft': newX--; break;
                case 'ArrowRight': newX++; break;
                default: return;
            }
            
            // 检查移动是否有效
            if (newX >= 0 && newX < gameState.multiplayer.maze[0].length && 
                newY >= 0 && newY < gameState.multiplayer.maze.length) {
                
                const cellValue = gameState.multiplayer.maze[newY][newX];
                
                // 检查是否是墙
                if (cellValue === 1) return;
                
                // 检查是否是陷阱
                if (cellValue === 2) {
                    // 检查玩家是否受保护（无敌状态）
                    if (gameState.multiplayer.protectedPlayers[gameState.multiplayer.currentPlayerId]) {
                        // 无敌状态，忽略陷阱
                        console.log('无敌状态，忽略陷阱');
                    } else {
                        // 回到起点
                        player.x = 1;
                        player.y = 1;
                        gameState.multiplayer.moveCount++;
                        document.getElementById('multiplayerMoveCount').textContent = 
                            `移动: ${gameState.multiplayer.moveCount}`;
                        
                        // 广播移动
                        broadcast({
                            type: 'player-move',
                            playerId: gameState.multiplayer.currentPlayerId,
                            x: player.x,
                            y: player.y
                        });
                        
                        drawMultiplayerMaze();
                        
                    }
                }
                
                // 检查是否是传送门
                if (cellValue === 3) {
                    // 找到配对的传送门
                    const teleporter = gameState.multiplayer.teleporters.find(t => 
                        t.x === newX && t.y === newY);
                    
                    if (teleporter) {
                        // 如果是主机，直接处理传送
                        if (gameState.multiplayer.isHost) {
                            newX = teleporter.pairX;
                            newY = teleporter.pairY;
                            
                            player.x = newX;
                            player.y = newY;
                            
                            // 广播传送
                            broadcast({
                                type: 'player-teleport',
                                playerId: gameState.multiplayer.currentPlayerId,
                                x: newX,
                                y: newY
                            });
                            drawMultiplayerMaze();
                        } else {
                            // 如果是客户端，向主机发送传送请求
                            const conn = Object.values(gameState.multiplayer.connections)[0];
                            if (conn) {
                                conn.send({
                                    type: 'teleport-request',
                                    playerId: gameState.multiplayer.currentPlayerId,
                                    teleporterX: newX,
                                    teleporterY: newY
                                });
                            }
                            return; // 等待主机处理
                            drawMultiplayerMaze();
                        }
                    }
                } else {
                    // 普通移动
                    player.x = newX;
                    player.y = newY;
                }
                
                gameState.multiplayer.moveCount++;
                document.getElementById('multiplayerMoveCount').textContent = 
                    `移动: ${gameState.multiplayer.moveCount}`;
                
                // 广播移动
                broadcast({
                    type: 'player-move',
                    playerId: gameState.multiplayer.currentPlayerId,
                    x: player.x,
                    y: player.y
                });
                drawMultiplayerMaze();
                // 检查是否到达出口
                if (player.x === gameState.multiplayer.exit.x && player.y === gameState.multiplayer.exit.y) {
                    player.reachedExit = true;
                    
                    // 广播到达出口
                    broadcast({
                        type: 'player-reached-exit',
                        playerId: gameState.multiplayer.currentPlayerId
                    });
                    
                    // 检查是否所有玩家都到达出口
                    checkAllPlayersReachedExit();
                }
                drawMultiplayerMaze();
                if (cellValue === 8) {
                    gameState.multiplayer.hasKey = true;
                    // 移除钥匙
                    gameState.multiplayer.maze[newY][newX] = 0;
                    delete gameState.multiplayer.keyPosition;
                    
                    // 广播钥匙拾取
                    broadcast({
                        type: 'key-pickup',
                        playerId: gameState.multiplayer.currentPlayerId
                    });
                }
                
                // 检查是否是门
                if (cellValue === 9) {
                        if (gameState.multiplayer.hasKey) {
                            // 开始开门倒计时
                            startMultiplayerUnlockDoor();
                            
                        } else {
                            // 没有钥匙，不能通过
                            alert("你需要钥匙才能打开这扇门！");
                            
                        }
                drawMultiplayerMaze();
                updatePlayerList();
            }
        }
    }
function startUnlockDoor() {
    // 清除可能存在的旧定时器
    clearInterval(singlePlayerGame.unlockTimer);
    
    singlePlayerGame.isUnlocking = true;
    singlePlayerGame.unlockTimeLeft = 10;
    document.getElementById('unlockTimer').classList.remove('hidden');
    updateUnlockTimer();
    
    singlePlayerGame.unlockTimer = setInterval(() => {
        singlePlayerGame.unlockTimeLeft--;
        updateUnlockTimer();
        
        if (singlePlayerGame.unlockTimeLeft <= 0) {
            clearInterval(singlePlayerGame.unlockTimer);
            // 开门成功
            singlePlayerGame.maze[singlePlayerGame.doorPosition.y][singlePlayerGame.doorPosition.x] = 0;
            document.getElementById('unlockTimer').classList.add('hidden');
            singlePlayerGame.isUnlocking = false;
            
            drawSinglePlayerMaze();
            alert("门已打开！现在你可以进入出口了。");
        }
    }, 1000);
}


function startMultiplayerUnlockDoor() {
    // 清除可能存在的旧定时器
    clearInterval(gameState.multiplayer.unlockTimer);
    
    gameState.multiplayer.isUnlocking = true;
    gameState.multiplayer.unlockTimeLeft = 10;
    document.getElementById('unlockTimer').classList.remove('hidden');
    updateMultiplayerUnlockTimer();
    
    gameState.multiplayer.unlockTimer = setInterval(() => {
        gameState.multiplayer.unlockTimeLeft--;
        updateMultiplayerUnlockTimer();
        
        if (gameState.multiplayer.unlockTimeLeft <= 0) {
            clearInterval(gameState.multiplayer.unlockTimer);
            // 开门成功
            gameState.multiplayer.maze[
                gameState.multiplayer.doorPosition.y][
                gameState.multiplayer.doorPosition.x] = 0;
            document.getElementById('unlockTimer').classList.add('hidden');
            gameState.multiplayer.isUnlocking = false;
            
            // 如果是主机，广播开门
            if (gameState.multiplayer.isHost) {
                broadcast({
                    type: 'door-open',
                    x: gameState.multiplayer.doorPosition.x,
                    y: gameState.multiplayer.doorPosition.y
                });
            }
            
            drawMultiplayerMaze();
            alert("门已打开！");
        }
    }, 1000);
}

function updateUnlockTimer() {
    document.getElementById('unlockTimer').textContent = 
        `开门倒计时: ${singlePlayerGame.unlockTimeLeft}秒`;
}

function checkAllPlayersReachedExit() {
    const allReached = Object.values(gameState.multiplayer.players).every(p => p.reachedExit);
    if (allReached) {
        alert('所有玩家都到达了出口！游戏胜利！');
        
        // 记录多人游戏成就
        recordAchievement('multiplayerWin', 1);
    }
}

// 初始化函数
function initializeNewFeatures() {
    updateAchievementProgress();
    
    // 更新挑战界面数据
    document.getElementById('timeChallengeBest').textContent = 
        gameState.gameStats.timeChallengeBest > 0 ? 
        gameState.gameStats.timeChallengeBest + '秒' : '暂无';
    
    document.getElementById('puzzleCompleted').textContent = 
        gameState.gameStats.puzzleLevelsCompleted + '/10';
    
    
}
// 在页面加载时调用
window.addEventListener('load', initializeNewFeatures);

        function disconnectMultiplayer() {
            if (gameState.multiplayer.peer) {
                gameState.multiplayer.peer.destroy();
            }
            
            gameState.multiplayer.connected = false;
            gameState.multiplayer.connections = {};
            gameState.multiplayer.players = {};
            gameState.multiplayer.protectedPlayers = {};
            clearInterval(gameState.multiplayer.timerInterval);
            window.removeEventListener('keydown', handleMultiplayerKeyDown);
            showScreen('mainMenu');
            
            // 恢复开始游戏按钮状态并清除房间状态提示
            const startBtn = document.getElementById('multiplayerStartBtn');
            const statusElement = document.getElementById('roomStatus');
            if (startBtn) {
                startBtn.disabled = false;
            }
            if (statusElement) {
                statusElement.textContent = '';
            }
        }

        // 房间浏览器模态框逻辑
        function openRoomBrowserModal() {
            console.log('尝试打开房间浏览器模态框');
            
            try {
                const modal = document.getElementById('roomBrowserModal');
                if (!modal) {
                    console.error('未找到roomBrowserModal元素');
                    alert('房间浏览器无法打开：未找到必要的界面元素');
                    return;
                }
                
                console.log('找到模态框元素，当前类名:', modal.className);
                console.log('当前显示状态:', modal.style.display);
                
                // 移除hidden类，确保模态框可见
                if (modal.classList.contains('hidden')) {
                    console.log('移除hidden类');
                    modal.classList.remove('hidden');
                }
                
                // 强制设置显示样式
                modal.style.display = 'flex';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
                
                console.log('模态框样式设置完成，新的显示状态:', modal.style.display);
                console.log('新的类名:', modal.className);
                
                // 检查GAME_SERVER_URL是否定义
                if (typeof GAME_SERVER_URL === 'undefined') {
                    console.error('GAME_SERVER_URL未定义');
                    const statusElement = document.getElementById('roomBrowserStatus');
                    if (statusElement) {
                        statusElement.textContent = '配置错误：服务器URL未定义';
                        statusElement.style.color = '#FF5252';
                    }
                    return;
                }
                
                // 加载房间列表
                console.log('调用loadRoomsInModal加载房间列表');
                loadRoomsInModal();
            } catch (error) {
                console.error('打开房间浏览器时发生错误:', error);
                alert('房间浏览器无法打开：' + error.message);
            }
        }
        
        function closeRoomBrowserModal() {
            const modal = document.getElementById('roomBrowserModal');
            modal.style.display = 'none';
        }
        
        // 房间搜索功能
        async function loadRoomsInModal() {
            try {
                const statusElement = document.getElementById('roomBrowserStatus');
                statusElement.textContent = '正在加载房间列表...';
                statusElement.style.color = '#FF9800';
                
                const url = GAME_SERVER_URL + '/api/rooms';
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error('服务器响应错误');
                }
                
                const data = await response.json();
                
                if (data.success) {
                    displayRoomsInModal(data.rooms);
                    statusElement.textContent = `共找到 ${data.rooms.length} 个房间`;
                    statusElement.style.color = '#4CAF50';
                } else {
                    statusElement.textContent = '加载房间列表失败';
                    statusElement.style.color = '#FF5252';
                }
            } catch (error) {
                console.error('加载房间列表失败:', error);
                const statusElement = document.getElementById('roomBrowserStatus');
                statusElement.textContent = '无法连接到服务器';
                statusElement.style.color = '#FF5252';
            }
        }
        
        async function searchRoomsInModal() {
            try {
                const searchQuery = document.getElementById('roomBrowserSearch').value.trim();
                const statusElement = document.getElementById('roomBrowserStatus');
                
                if (!searchQuery) {
                    loadRoomsInModal();
                    return;
                }
                
                statusElement.textContent = '正在搜索房间...';
                statusElement.style.color = '#FF9800';
                
                const url = GAME_SERVER_URL + '/api/rooms/search?q=' + encodeURIComponent(searchQuery);
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error('服务器响应错误');
                }
                
                const data = await response.json();
                
                if (data.success) {
                    displayRoomsInModal(data.rooms);
                    statusElement.textContent = `搜索结果: ${data.rooms.length} 个房间`;
                    statusElement.style.color = '#4CAF50';
                } else {
                    statusElement.textContent = '搜索失败';
                    statusElement.style.color = '#FF5252';
                }
            } catch (error) {
                console.error('搜索房间失败:', error);
                const statusElement = document.getElementById('roomBrowserStatus');
                statusElement.textContent = '搜索失败，请检查网络连接';
                statusElement.style.color = '#FF5252';
            }
        }
        
        function displayRoomsInModal(rooms) {
            const roomListElement = document.getElementById('roomBrowserList');
            
            if (rooms.length === 0) {
                roomListElement.innerHTML = '<div style="text-align: center; padding: 20px; color: #999; font-size: 16px;">没有找到房间</div>';
                return;
            }
            
            roomListElement.innerHTML = '';
            
            rooms.forEach(room => {
                const roomItem = document.createElement('div');
                roomItem.className = 'room-item';
                
                const roomInfo = document.createElement('div');
                roomInfo.className = 'room-info';
                
                const roomName = document.createElement('div');
                roomName.className = 'room-name';
                roomName.textContent = room.name;
                
                const roomHost = document.createElement('div');
                roomHost.className = 'room-host';
                roomHost.textContent = `房主: ${room.hostName}`;
                
                const roomPlayers = document.createElement('div');
                roomPlayers.className = 'room-players';
                roomPlayers.textContent = `${room.players}/${room.maxPlayers} 人`;
                
                const statusSpan = document.createElement('span');
                statusSpan.className = `room-status ${room.status}`;
                statusSpan.textContent = room.status === 'waiting' ? '等待中' : '游戏中';
                
                roomPlayers.appendChild(statusSpan);
                roomInfo.appendChild(roomName);
                roomInfo.appendChild(roomHost);
                roomInfo.appendChild(roomPlayers);
                
                const joinBtn = document.createElement('button');
                joinBtn.className = 'join-button';
                joinBtn.textContent = '加入';
                console.log('创建加入按钮，房间ID:', room.id);
                
                // 确保按钮点击事件优先执行并阻止冒泡
                joinBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // 阻止事件冒泡到roomItem
                    console.log('加入按钮被点击，房间ID:', room.id);
                    joinRoomFromModal(room.id);
                });
                
                roomItem.appendChild(roomInfo);
                roomItem.appendChild(joinBtn);
                
                roomItem.addEventListener('click', (e) => {
                    // 确保点击目标不是加入按钮
                    console.log('房间项被点击，目标:', e.target);
                    console.log('目标类名:', e.target.className);
                    console.log('closest join-button:', e.target.closest('.join-button'));
                    
                    // 检查点击目标是否是按钮或按钮的子元素
                    const isButtonClick = e.target.classList.contains('join-button') || e.target.closest('.join-button');
                    if (!isButtonClick) {
                        console.log('点击的是房间项，不是按钮，调用 joinRoomFromModal，房间ID:', room.id);
                        joinRoomFromModal(room.id);
                    } else {
                        console.log('点击的是加入按钮，跳过房间项点击逻辑');
                    }
                });
                
                roomListElement.appendChild(roomItem);
            });
        }
        
        function joinRoomFromModal(roomId) {
            console.log('joinRoomFromModal 函数被调用，roomId:', roomId);
            
            // 检查元素是否存在
            const roomCodeElement = document.getElementById('roomCode');
            const statusElement = document.getElementById('roomStatus');
            
            console.log('roomCodeElement:', roomCodeElement);
            console.log('statusElement:', statusElement);
            
            if (roomCodeElement) {
                // 设置房间代码并自动加入
                roomCodeElement.value = roomId;
            }
            
            // 关闭模态框
            closeRoomBrowserModal();
            
            // 显示提示
            if (statusElement) {
                statusElement.textContent = `正在加入房间 ${roomId}...`;
                statusElement.style.color = '#FF9800';
            }
            
            // 自动连接到房间
            console.log('准备调用 connectToMultiplayerGame()');
            connectToMultiplayerGame();
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            
            switch(status) {
                case 'connecting':
                    statusElement.textContent = '连接中...';
                    statusElement.className = 'connection-status disconnected';
                    break;
                case 'connected':
                    statusElement.textContent = '已连接 多人联机测试';
                    statusElement.className = 'connection-status connected';
                    break;
                case 'disconnected':
                    statusElement.textContent = '断开连接 多人联机测试';
                    statusElement.className = 'connection-status disconnected';
                    break;
            }
        }

        function updatePlayerList() {
            const container = document.getElementById('playersContainer');
            container.innerHTML = '';
            
            for (const playerId in gameState.multiplayer.players) {
                const player = gameState.multiplayer.players[playerId];
                const div = document.createElement('div');
                div.className = 'player-item';
                
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                playerInfo.innerHTML = `
                    <div class="player-color" style="background-color:${player.color}"></div>
                    ${player.name} ${player.isHost ? '🏠' : ''} ${player.reachedExit ? '✓' : ''}
                    ${gameState.multiplayer.protectedPlayers[playerId] ? '🛡️' : ''}
                `;
                
                div.appendChild(playerInfo);
                
                // 如果是房主且不是自己，显示踢出按钮
                if (gameState.multiplayer.isHost && 
                    gameState.multiplayer.currentPlayerId !== playerId) {
                    const kickButton = document.createElement('button');
                    kickButton.className = 'kick-button';
                    kickButton.textContent = '踢出';
                    kickButton.onclick = () => {
                        if (confirm(`确定要踢出玩家 ${player.name} 吗？`)) {
                            // 检查玩家是否受保护
                            if (gameState.multiplayer.protectedPlayers[playerId]) {
                                alert('踢出失败：err75937 (玩家受保护)');
                            } else {
                                kickPlayer(playerId, '被管理员踢出');
                            }
                        }
                    };
                    div.appendChild(kickButton);
                }
                
                container.appendChild(div);
            }
            
            updatePlayerCount();
        }

        function updatePlayerCount() {
            const currentPlayers = Object.keys(gameState.multiplayer.players).length;
            const maxPlayers = gameState.multiplayer.maxPlayers;
            document.getElementById('multiplayerPlayerCount').textContent = 
                `玩家: ${currentPlayers}/${maxPlayers}`;
        }

function kickPlayer(playerId, reason) {
    // 检查是否是房主且不是强制踢出
    const isHost = gameState.multiplayer.players[playerId]?.isHost;
    if (isHost && !reason.includes('(强制)')) {
        // 使用系统消息显示错误
        addChatMessage('系统', '错误: 不能踢出房主(除非使用force参数)', '#FF5252');
        return;
    }
    
    // 发送踢出消息给该玩家
    if (gameState.multiplayer.connections[playerId]) {
        gameState.multiplayer.connections[playerId].send({
            type: 'player-kicked',
            playerId: playerId,
            reason: reason
        });
        gameState.multiplayer.connections[playerId].close();
    }
    
    // 广播给其他玩家
    broadcast({
        type: 'player-kicked',
        playerId: playerId,
        reason: reason
    });
    
    // 从列表中移除
    removePlayer(playerId);
}


        function resetMultiplayerPlayer() {
            const player = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
            if (player) {
                player.x = 1;
                player.y = 1;
                player.reachedExit = false;
                
                // 广播移动
                broadcast({
                    type: 'player-move',
                    playerId: gameState.multiplayer.currentPlayerId,
                    x: player.x,
                    y: player.y
                });
                
                drawMultiplayerMaze();
                updatePlayerList();
            }
        }
function addKeyAndDoormultiplayer(size, maze) {
    // 随机放置钥匙
    let keyX, keyY;
    do {
        keyX = Math.floor(Math.random() * (size - 4)) + 2;
        keyY = Math.floor(Math.random() * (size - 4)) + 2;
    } while (maze[keyY][keyX] === 1 || 
             (keyX === 1 && keyY === size - 2) || 
             (keyX === Math.floor(size/2) && keyY === Math.floor(size/2)));
    
    // 放置钥匙(8)
    maze[keyY][keyX] = 8;
    gameState.multiplayer.keyPosition = {x: keyX, y: keyY};
    
    // 在出口前放置门(9)
    let doorX = gameState.multiplayer.exit.x;
    let doorY = gameState.multiplayer.exit.y;
    
    // 确定门的位置
    if (doorX < size-1 && maze[doorY][doorX+1] === 0) {
        doorX++;
    } else if (doorX > 0 && maze[doorY][doorX-1] === 0) {
        doorX--;
    } else if (doorY < size-1 && maze[doorY+1][doorX] === 0) {
        doorY++;
    } else if (doorY > 0 && maze[doorY-1][doorX] === 0) {
        doorY--;
    }
    
    maze[doorY][doorX] = 9;
    gameState.multiplayer.doorPosition = {x: doorX, y: doorY};
}

function generateMultiplayerMaze() {
    const size = 15;
    let maze;
    let validMaze = false;
    let attempts = 0;
    
    // 10%概率生成螺旋迷宫(应敌人无法渲染，暂时关闭)
    const isSpiralMaze = false;
    // const isSpiralMaze = Math.random() < 0.1;
    // %100生成
    // const isSpiralMaze = true;
    if (isSpiralMaze) {
        maze = generateSpiralMaze(size);
        gameState.multiplayer.exit = { 
            x: Math.floor(size/2), 
            y: Math.floor(size/2) 
        };
        
        // 添加钥匙和门
        addKeyAndDoormultiplayer(size, maze);
    } else {
        // 普通迷宫
        while (!validMaze && attempts < 5) {
            maze = Array(size).fill().map(() => Array(size).fill(1));
            validMaze = tryGenerateValidMaze(maze, size);
            attempts++;
        }
        
        
        // 设置出口
        maze[size-2][size-1] = 0;
        gameState.multiplayer.exit = {x: size-1, y: size-2};
    }
    
    // 添加传送门
    addMultiplayerTeleporters(maze, size);
    
    return maze;
}

function tryGenerateValidMaze(maze, size) {
    // 使用随机Prim算法生成迷宫
    const walls = [];
    maze[1][1] = 0;
    walls.push(...getCellWalls(1, 1, maze));
    
    while (walls.length > 0) {
        const wallIndex = Math.floor(Math.random() * walls.length);
        const wall = walls[wallIndex];
        walls.splice(wallIndex, 1);
        
        const opposite = getOppositeCell(wall, maze);
        
        if (opposite.x > 0 && opposite.x < size-1 && 
            opposite.y > 0 && opposite.y < size-1 && 
            maze[opposite.y][opposite.x] === 1) {
            
            maze[wall.y][wall.x] = 0;
            maze[opposite.y][opposite.x] = 0;
            walls.push(...getCellWalls(opposite.x, opposite.y, maze));
        }
    }
    
    // 确保有一条从起点(1,1)到终点(size-2, size-1)的路径
    return validateMaze(maze);
}

function addMultiplayerTraps(maze, size) {
    // 添加陷阱（避开关键路径）
    const criticalPath = findCriticalPath(maze);
    for (let i = 0; i < 8; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(Math.random() * (size-2)) + 1;
            y = Math.floor(Math.random() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || 
                  criticalPath.some(p => p.x === x && p.y === y) || 
                  (x === 1 && y === 1)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y][x] = 2;
        }
    }
}

function addMultiplayerTeleporters(maze, size) {
    gameState.multiplayer.teleporters = [];
    for (let i = 0; i < 4; i++) {
        let x1, y1, x2, y2;
        let attempts = 0;
        do {
            x1 = Math.floor(Math.random() * (size-2)) + 1;
            y1 = Math.floor(Math.random() * (size-2)) + 1;
            x2 = Math.floor(Math.random() * (size-2)) + 1;
            y2 = Math.floor(Math.random() * (size-2)) + 1;
            attempts++;
        } while ((maze[y1][x1] !== 0 || maze[y2][x2] !== 0 || 
                 (x1 === 1 && y1 === 1) || (x2 === 1 && y2 === 1)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y1][x1] = 3;
            maze[y2][x2] = 3;
            gameState.multiplayer.teleporters.push({x: x1, y: y1, pairX: x2, pairY: y2});
            gameState.multiplayer.teleporters.push({x: x2, y: y2, pairX: x1, pairY: y1});
        }
    }
}



function getOppositeCell(wall, maze) {
    const directions = [
        {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
        {dx: 0, dy: 1}, {dx: 0, dy: -1}
    ];
    
    for (const dir of directions) {
        const nx = wall.x + dir.dx;
        const ny = wall.y + dir.dy;
        
        if (nx >= 0 && nx < maze[0].length && 
            ny >= 0 && ny < maze.length && 
            maze[ny][nx] === 0) {
            return {x: wall.x - dir.dx, y: wall.y - dir.dy};
        }
    }
    
    return {x: -1, y: -1};
}

function getCellWalls(x, y, maze) {
    const walls = [];
    const directions = [
        {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
        {dx: 0, dy: 1}, {dx: 0, dy: -1}
    ];
    
    for (const dir of directions) {
        const nx = x + dir.dx;
        const ny = y + dir.dy;
        
        if (nx >= 0 && nx < maze[0].length && 
            ny >= 0 && ny < maze.length && 
            maze[ny][nx] === 1) {
            walls.push({x: nx, y: ny});
        }
    }
    
    return walls;
}
        

        function drawMultiplayerMaze() {
            const canvas = document.getElementById('multiplayerCanvas');
            const ctx = canvas.getContext('2d');
            const cellSize = gameState.multiplayer.cellSize;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制迷宫
            for (let y = 0; y < gameState.multiplayer.maze.length; y++) {
                for (let x = 0; x < gameState.multiplayer.maze[y].length; x++) {
                    const cellValue = gameState.multiplayer.maze[y][x];
                    
                    switch(cellValue) {
                        case 1: // 墙
                            ctx.fillStyle = '#333';
                            break;
                        case 2: // 陷阱
                            ctx.fillStyle = '#FF0';
                            break;
                        case 3: // 传送门
                            ctx.fillStyle = '#0FF';
                            break;
                        default: // 路
                            ctx.fillStyle = '#111';
                    }
                    
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    
                    // 绘制陷阱图案
                    if (cellValue === 2) {
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            x * cellSize + cellSize/2,
                            y * cellSize + cellSize/2,
                            cellSize/4,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                       if (gameState.multiplayer.keyPosition) {
                            ctx.fillStyle = 'gold';
                            ctx.fillRect(
                                gameState.multiplayer.keyPosition.x * cellSize,
                                gameState.multiplayer.keyPosition.y * cellSize,
                                cellSize, cellSize
                            );
                        }
                        
                        // 绘制门
                        if (gameState.multiplayer.doorPosition) {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(
                                gameState.multiplayer.doorPosition.x * cellSize,
                                gameState.multiplayer.doorPosition.y * cellSize,
                                cellSize, cellSize
                            );
                        }
                        
                        // 绘制移动敌人（如果是螺旋迷宫）
                        if (gameState.multiplayer.movingEnemies) {
                            gameState.multiplayer.movingEnemies.forEach(enemy => {
                                ctx.fillStyle = enemy.color;
                                ctx.beginPath();
                                ctx.arc(
                                    enemy.x * cellSize + cellSize/2,
                                    enemy.y * cellSize + cellSize/2,
                                    cellSize/2 - 2,
                                    0,
                                    Math.PI * 2
                                );
                                ctx.fill();
                                
                                // 绘制敌人眼睛
                                ctx.fillStyle = '#FFF';
                                ctx.beginPath();
                                ctx.arc(
                                    enemy.x * cellSize + cellSize/3,
                                    enemy.y * cellSize + cellSize/3,
                                    cellSize/8,
                                    0,
                                    Math.PI * 2
                                );
                                ctx.fill();
                            });
                        }
                }
            
                
            
            
            // 绘制出口
            ctx.fillStyle = '#F00';
            ctx.fillRect(gameState.multiplayer.exit.x * cellSize, 
                        gameState.multiplayer.exit.y * cellSize, 
                        cellSize, cellSize);
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold ' + (cellSize/2) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('出', 
                gameState.multiplayer.exit.x * cellSize + cellSize/2,
                gameState.multiplayer.exit.y * cellSize + cellSize/2
            );
            
            // 绘制所有玩家
            for (const playerId in gameState.multiplayer.players) {
                const player = gameState.multiplayer.players[playerId];
                
                if (playerId === gameState.multiplayer.peer.id) {
                    // 绘制本地玩家使用皮肤系统
                    drawPlayerWithSkin(
                        ctx,
                        player.x * cellSize,
                        player.y * cellSize,
                        cellSize
                    );
                } else {
                    // 绘制其他玩家使用默认样式
                    ctx.fillStyle = player.color;
                    ctx.beginPath();
                    ctx.arc(
                        player.x * cellSize + cellSize/2,
                        player.y * cellSize + cellSize/2,
                        cellSize/2 - 2,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // 绘制玩家名字
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold ' + (cellSize/3) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                // 绘制文字背景以提高可读性
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                const textWidth = ctx.measureText(player.name).width;
                ctx.fillRect(
                    player.x * cellSize + cellSize/2 - textWidth/2 - 4,
                    player.y * cellSize - 2,
                    textWidth + 8,
                    cellSize/4 + 4
                );
                // 绘制文字
                ctx.fillStyle = '#FFF';
                ctx.fillText(player.name, 
                    player.x * cellSize + cellSize/2,
                    player.y * cellSize
                );
            }
        }
    }
function updateMultiplayerGame() {
    // 移动敌人
    const now = Date.now();
    const size = gameState.multiplayer.maze.length; // 获取迷宫大小
    
    if (gameState.multiplayer.movingEnemies) {
        gameState.multiplayer.movingEnemies.forEach(enemy => {
            // 根据时间间隔移动
            if (now - enemy.lastMove < 500 / enemy.speed) return;
            enemy.lastMove = now;
            
            // 追逐最近的玩家
            let closestPlayer = null;
            let minDistance = Infinity;
            
            for (const playerId in gameState.multiplayer.players) {
                const player = gameState.multiplayer.players[playerId];
                const distance = Math.sqrt(
                    Math.pow(player.x - enemy.x, 2) + 
                    Math.pow(player.y - enemy.y, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPlayer = player;
                }
            }
            
            if (closestPlayer) {
                // 计算移动方向
                enemy.dx = closestPlayer.x - enemy.x > 0 ? 1 : -1;
                enemy.dy = closestPlayer.y - enemy.y > 0 ? 1 : -1;
                
                // 尝试移动
                let newX = enemy.x + enemy.dx;
                let newY = enemy.y + enemy.dy;
                
                // 检查是否可以移动
                if (newX >= 0 && newX < size && newY >= 0 && newY < size && 
                    gameState.multiplayer.maze[newY][newX] !== 1) {
                    enemy.x = newX;
                    enemy.y = newY;
                    
                    // 检查是否碰到玩家
                    for (const playerId in gameState.multiplayer.players) {
                        const player = gameState.multiplayer.players[playerId];
                        
                        if (enemy.x === player.x && enemy.y === player.y && 
                            !gameState.multiplayer.protectedPlayers[playerId]) {
                            // 玩家被送回起点
                            player.x = 1;
                            player.y = 1;
                            
                            // 广播移动
                            broadcast({
                                type: 'player-move',
                                playerId: playerId,
                                x: player.x,
                                y: player.y
                            });
                        }
                    }
                }
            }
        });
        
        // 广播敌人移动
        broadcast({
            type: 'enemy-move',
            enemies: gameState.multiplayer.movingEnemies
        });
        
        drawMultiplayerMaze();
    }
}

        function updateMultiplayerUnlockTimer() {
            document.getElementById('unlockTimer').textContent = 
                `开门倒计时: ${gameState.multiplayer.unlockTimeLeft}秒`;
        }

        function startMultiplayerTimer() {
            clearInterval(gameState.multiplayer.timerInterval);
            gameState.multiplayer.startTime = Date.now();
            updateMultiplayerUnlockTimer();
            gameState.multiplayer.timerInterval = setInterval(updateMultiplayerUnlockTimer, 1000);
        }



        function getRandomColor() {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'];
            return colors[Math.floor(Math.random() * colors.length)];
        }




        // =============== 键盘快捷键 ===============
        document.addEventListener('keydown', function(e) {
            // Ctrl+Shift+C 打开/关闭控制台
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                toggleConsole();
            }
            
            // Ctrl+Shift+D 切换开发者模式
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                e.preventDefault();
                gameState.devMode = !gameState.devMode;
                console.log('开发者模式:', gameState.devMode ? '开启' : '关闭');
                
                // 显示提示
                const hint = document.createElement('div');
                hint.className = 'console-hint';
                hint.textContent = `开发者模式 ${gameState.devMode ? '开启' : '关闭'}`;
                document.body.appendChild(hint);
                
                setTimeout(() => {
                    hint.classList.add('hidden');
                    setTimeout(() => hint.remove(), 500);
                }, 2000);
            }
            
            // 控制台输入处理
            if (consoleVisible && e.key === 'Enter') {
                const input = document.getElementById('consoleInput');
                const command = input.value.trim();
                input.value = '';
                    
                if (command) {
                    consoleHistory.push(command);
                    historyIndex = consoleHistory.length;
                    executeCommand(command);
                }
            }
        });

        // 控制台输入框事件处理
        document.getElementById('consoleInput').addEventListener('keydown', handleConsoleInput);

        // 初始化关卡按钮
        generateLevelButtons();
        
        // 更新下一关按钮显示
function updateNextLevelButtons() {
    const regularBtn = document.getElementById('regularNextButton');
    const unsolvableBtn = document.getElementById('unsolvableNextButton');
    
    // 确保在任何时候调用这个函数都能正确设置按钮状态
    if (gameState.unsolvableLevels.includes(gameState.currentLevel)) {
        regularBtn.style.display = 'none';
        unsolvableBtn.style.display = 'block'; // 改为block以确保显示
    } else {
        regularBtn.style.display = 'block'; // 改为block以确保显示
        unsolvableBtn.style.display = 'none';
    }
}

// 音乐解锁相关函数
function setCookie(name, value, days) {
    const expires = new Date();
    expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
    const cookieString = name + '=' + encodeURIComponent(value) + ';expires=' + expires.toUTCString() + ';path=/';
    document.cookie = cookieString;
    console.log('Cookie设置:', name, '=', value, '过期时间:', expires.toUTCString());
    console.log('当前所有Cookie:', document.cookie);
}

function getCookie(name) {
    const cookieString = document.cookie;
    console.log('获取Cookie时的所有Cookie:', cookieString);
    const cookies = cookieString.split(';');
    for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.startsWith(name + '=')) {
            const value = decodeURIComponent(cookie.substring(name.length + 1));
            console.log('获取到Cookie:', name, '=', value);
            return value;
        }
    }
    console.log('未找到Cookie:', name);
    return null;
}

function validateMusicPassword() {
    const passwordInput = document.getElementById('musicPasswordInput');
    const errorMessage = document.getElementById('passwordError');
    
    if (passwordInput.value === '11musicgood') {
        // 密码正确，解锁音乐
        gameState.uiSettings.musicEnabled = true;
        setCookie('musicUnlocked', 'true', 365); // 保存一年
        
        // 更新UI
        document.getElementById('musicEnabledCheckbox').checked = true;
        
        // 关闭模态框
        document.getElementById('musicUnlockModal').classList.add('hidden');
        errorMessage.style.display = 'none';
        passwordInput.value = '';
        
        // 应用设置
        applyUISettings();
    } else {
        // 密码错误
        errorMessage.style.display = 'block';
        passwordInput.value = '';
    }
}

function checkMusicUnlockStatus() {
    console.log('检查音乐解锁状态...');
    const isUnlocked = getCookie('musicUnlocked');
    console.log('音乐解锁状态:', isUnlocked);
    if (isUnlocked === 'true') {
        gameState.uiSettings.musicEnabled = true;
        console.log('音乐已解锁');
    } else {
        gameState.uiSettings.musicEnabled = false;
        console.log('音乐未解锁');
    }
}

        // 检查音乐解锁状态
        checkMusicUnlockStatus();
        // 初始应用UI设置
        applyUISettings();
document.addEventListener('touchstart', function(e) {
    // 检查点击的是否是目标按钮
    if (e.target.id === 'multiplayerBtn' || e.target.parentElement.id === 'multiplayerBtn') {
        e.preventDefault();
        showScreen('multiplayerSetup');
    }
    
    if (e.target.id === 'startMultiplayerBtn' || e.target.parentElement.id === 'startMultiplayerBtn') {
        e.preventDefault();
        connectToMultiplayerGame();
    }
    
    if (e.target.id === 'backToMenuBtn' || e.target.parentElement.id === 'backToMenuBtn') {
        e.preventDefault();
        showScreen('mainMenu');
    }
}, { passive: false });

// 控制台功能实现
// 存储控制台消息的数组
const consoleMessages = [];

// 重写控制台方法以拦截消息
(function() {
    // 保存原始控制台方法
    const originalLog = console.log;
    const originalWarn = console.warn;
    const originalError = console.error;
    const originalInfo = console.info;
    const originalDebug = console.debug;
    
    // 统一的消息处理函数
    function logMessage(type, args) {
        // 格式化消息
        const timestamp = new Date().toLocaleTimeString();
        let message = '';
        
        // 将参数转换为字符串
        for (let i = 0; i < args.length; i++) {
            if (args[i] === undefined) {
                message += 'undefined';
            } else if (args[i] === null) {
                message += 'null';
            } else if (typeof args[i] === 'object') {
                try {
                    message += JSON.stringify(args[i], null, 2);
                } catch (e) {
                    message += args[i].toString();
                }
            } else {
                message += args[i].toString();
            }
            if (i < args.length - 1) {
                message += ' ';
            }
        }
        
        // 存储消息
        consoleMessages.push({
            type: type,
            message: message,
            timestamp: timestamp
        });
        
        // 限制消息数量，避免内存占用过大
        if (consoleMessages.length > 1000) {
            consoleMessages.shift();
        }
    }
    
    // 重写控制台方法
    console.log = function() {
        logMessage('log', arguments);
        originalLog.apply(console, arguments);
    };
    
    console.warn = function() {
        logMessage('warn', arguments);
        originalWarn.apply(console, arguments);
    };
    
    console.error = function() {
        logMessage('error', arguments);
        // originalError.apply(console, arguments);
    };
    
    console.info = function() {
        logMessage('info', arguments);
        originalInfo.apply(console, arguments);
    };
    
    console.debug = function() {
        logMessage('debug', arguments);
        originalDebug.apply(console, arguments);
    };
})();

// 密码验证功能

// 完全重写控制台功能的实现，确保所有函数都能正常工作
// 1. 密码验证功能
window.openConsolePasswordModal = function() {
    console.log('[DEBUG] openConsolePasswordModal函数被调用');
    try {
        const modal = document.getElementById('consolePasswordModal');
        if (modal) {
            // 确保所有其他屏幕都被隐藏
            const screens = [
                'mainMenu', 'singlePlayerLevelSelect', 'singlePlayerGame', 
                'singlePlayerComplete', 'multiplayerSetup', 'multiplayerGame',
                'achievementsScreen', 'moreChallengesScreen', 'statisticsScreen',
                'shopModal'
            ];
            
            screens.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.classList.add('hidden');
                }
            });
            
            modal.classList.remove('hidden');
            // 自动聚焦到密码输入框
            const input = document.getElementById('consolePasswordInput');
            if (input) {
                input.focus();
            }
        } else {
            console.error('未找到 consolePasswordModal 元素');
            alert('控制台密码模态框未找到，请刷新页面重试');
        }
    } catch (e) {
        console.error('打开密码模态框时出错:', e);
        alert('打开控制台时出错: ' + e.message);
    }
};

window.closeConsolePasswordModal = function() {
    try {
        const modal = document.getElementById('consolePasswordModal');
        if (modal) {
            modal.classList.add('hidden');
            
            // 恢复主菜单
            const mainMenu = document.getElementById('mainMenu');
            if (mainMenu) {
                mainMenu.classList.remove('hidden');
            }
        }
        const input = document.getElementById('consolePasswordInput');
        if (input) input.value = '';
    } catch (e) {
        console.error('关闭密码模态框时出错:', e);
    }
};

window.checkConsolePassword = function() {
    try {
        // 直接绕过密码验证，显示提示并打开控制台
        alert('控制台已打开');
        window.closeConsolePasswordModal();
        window.openConsoleModal();
    } catch (e) {
        console.error('打开控制台时出错:', e);
        alert('打开控制台时出错: ' + e.message);
    }
};

// 2. 控制台内容显示功能
window.openConsoleModal = function() {
    try {
        const modal = document.getElementById('consoleModal');
        if (modal) {
            modal.classList.remove('hidden');
            // 打开控制台时开启开发者模式
            gameState.developerMode = true;
            console.log('开发者模式已开启');
            
            // 显示所有控制台消息
            const consoleContent = document.getElementById('consoleContent');
            if (consoleContent) {
                consoleContent.innerHTML = '';
                
                
                consoleMessages.forEach(msg => {
                    const div = document.createElement('div');
                    div.style.marginBottom = '5px';
                    switch (msg.type) {
                    case 'log': div.style.color = '#fff'; break;
                    case 'warn': div.style.color = '#FFC107'; break;
                    case 'error': div.style.color = '#F44336'; break;
                    case 'info': div.style.color = '#2196F3'; break;
                    case 'debug': div.style.color = '#9C27B0'; break;
                    case 'command': div.style.color = '#4CAF50'; break;
                    case 'result': div.style.color = '#8BC34A'; break;
                    default: div.style.color = '#fff';
                }
                    let feedbackButton = '';
                if (msg.type === 'error') {
                    // 使用编码后的消息内容避免引号和特殊字符问题
                    const encodedMessage = encodeURIComponent(msg.message);
                    feedbackButton = `<button style="margin-left: 10px; padding: 2px 8px; background-color: #F44336; color: white; border: none; border-radius: 3px; font-size: 12px; cursor: pointer;" onclick="sendErrorFeedback('${encodedMessage}')">反馈</button>`;
                }
                div.innerHTML = `<span style="color: #9E9E9E; font-size: 12px;">[${msg.timestamp}]</span> <span style="font-weight: bold;">${msg.type.toUpperCase()}:</span> ${msg.message}${feedbackButton}`;
                    consoleContent.appendChild(div);
                });
                
                consoleContent.scrollTop = consoleContent.scrollHeight;
            
            // 自动聚焦到命令输入框
            const input = document.getElementById('consoleCommandInput');
            if (input) {
                setTimeout(() => {
                    input.focus();
                }, 100);
            }
            
        } else {
            console.error('未找到 consoleContent 元素');
            alert('控制台内容区域未找到');
        }
    } else {
        console.error('未找到 consoleModal 元素');
        alert('控制台模态框未找到，请刷新页面重试');
    }
    } catch (e) {
        console.error('打开控制台时出错:', e);
        alert('打开控制台时出错: ' + e.message);
    }
};

window.closeConsoleModal = function() {
    
    try {
        const modal = document.getElementById('consoleModal');
        if (modal) {
            modal.classList.add('hidden');
            
            // 恢复之前显示的屏幕，这里直接显示主菜单
            const mainMenu = document.getElementById('mainMenu');
            if (mainMenu) {
                mainMenu.classList.remove('hidden');
            }
        }
    } catch (e) {
        console.error('关闭控制台时出错:', e);
    }
};

// 控制台刷新功能
window.refreshConsole = function() {
    
    try {
        const consoleContent = document.getElementById('consoleContent');
        if (consoleContent) {
            consoleContent.innerHTML = '';
        
            
            consoleMessages.forEach(msg => {
                const div = document.createElement('div');
                div.style.marginBottom = '5px';
                
                switch (msg.type) {
                    case 'log': div.style.color = '#fff'; break;
                    case 'warn': div.style.color = '#FFC107'; break;
                    case 'error': div.style.color = '#F44336'; break;
                    case 'info': div.style.color = '#2196F3'; break;
                    case 'debug': div.style.color = '#9C27B0'; break;
                    case 'command': div.style.color = '#4CAF50'; break;
                    case 'result': div.style.color = '#8BC34A'; break;
                    default: div.style.color = '#fff';
                }
                
                let feedbackButton = '';
                if (msg.type === 'error') {
                    // 使用编码后的消息内容避免引号和特殊字符问题
                    const encodedMessage = encodeURIComponent(msg.message);
                    feedbackButton = `<button style="margin-left: 10px; padding: 2px 8px; background-color: #F44336; color: white; border: none; border-radius: 3px; font-size: 12px; cursor: pointer;" onclick="window.sendErrorFeedback('${encodedMessage}')">反馈</button>`;
                }
                div.innerHTML = `<span style="color: #9E9E9E; font-size: 12px;">[${msg.timestamp}]</span> <span style="font-weight: bold;">${msg.type.toUpperCase()}:</span> ${msg.message}${feedbackButton}`;
                consoleContent.appendChild(div);
            });
            
            consoleContent.scrollTop = consoleContent.scrollHeight;
        } else {
            console.error('未找到 consoleContent 元素');
            alert('未找到控制台内容元素');
        }
    } catch (e) {
        console.error('刷新控制台时出错:', e);
        alert('刷新控制台时出错: ' + e.message);
    }
};

// 错误反馈功能
window.sendErrorFeedback = function(encodedErrorMessage) {
    try {
        // 解码错误消息
        const errorMessage = decodeURIComponent(encodedErrorMessage);
        
        // 查找最近执行的命令
        let recentCommand = "无最近命令";
        for (let i = consoleMessages.length - 1; i >= 0; i--) {
            if (consoleMessages[i].type === 'command') {
                recentCommand = consoleMessages[i].message;
                break;
            }
        }
        
        // 获取错误发生位置的游戏状态信息
        let gameStatus = "当前游戏状态：\n";
        try {
            // 尝试使用gameState对象获取游戏状态
            if (typeof gameState !== 'undefined') {
                if (gameState.currentScreen) gameStatus += `- 当前屏幕：${gameState.currentScreen}\n`;
                if (gameState.currentLevel) gameStatus += `- 当前关卡：${gameState.currentLevel}\n`;
                if (gameState.playerName) gameStatus += `- 玩家名称：${gameState.playerName}\n`;
                if (gameState.coins !== undefined) gameStatus += `- 金币数量：${gameState.coins}\n`;
                if (gameState.unlockedLevel) gameStatus += `- 已解锁关卡：${gameState.unlockedLevel}\n`;
                if (gameState.devMode) gameStatus += `- 开发模式：${gameState.devMode ? '已启用' : '未启用'}\n`;
                if (gameState.uiSettings) gameStatus += `- UI设置：${gameState.uiSettings}\n`;
                if (gameState.gameStats) gameStatus += `- 游戏统计：${gameState.gameStats ? '已启用' : '未启用'}\n`;
                if (gameState.controlsReversed) gameStatus += `- 控制反转：${gameState.controlsReversed ? '已启用' : '未启用'}\n`;
                if (gameState.currentLevel) gameStatus += `- 当前关卡：${gameState.currentLevel}\n\n\n`;
                
                if (gameState.multiplayer) {
                    gameStatus += `- 多人游戏模式：${gameState.multiplayer.connected ? '已连接' : '未连接'}\n`;
                    if (gameState.multiplayer.roomCode) gameStatus += `- 房间代码：${gameState.multiplayer.roomCode}\n`;
                }
                
                // 尝试获取玩家位置信息
                if (typeof player !== 'undefined' && player.x !== undefined && player.y !== undefined) {
                    gameStatus += `- 玩家位置：(${player.x}, ${player.y})\n`;
                }
            } else {
                // 备用方案：使用全局变量
                if (typeof currentGameMode !== 'undefined') gameStatus += `- 游戏模式：${currentGameMode}\n`;
                if (typeof currentLevel !== 'undefined') gameStatus += `- 当前关卡：${currentLevel}\n`;
                if (typeof player !== 'undefined' && player.x !== undefined && player.y !== undefined) gameStatus += `- 玩家位置：(${player.x}, ${player.y})\n`;
                if (typeof currentScreen !== 'undefined') gameStatus += `- 当前屏幕：${currentScreen}\n`;
                
            }
        } catch (e) {
            gameStatus += `- 无法获取游戏状态信息：${e.message}\n`;
        }
        
        // 获取浏览器信息
        const browserInfo = "浏览器信息：\n" +
                          `- 用户代理：${navigator.userAgent}\n` +
                          `- 语言：${navigator.language}\n` +
                          `- 平台：${navigator.platform}\n`;
        
        // 获取系统信息
        const systemInfo = "系统信息：\n" +
                          `- 屏幕分辨率：${window.screen.width}x${window.screen.height}\n` +
                          `- 窗口大小：${window.innerWidth}x${window.innerHeight}\n`;
        
        // 构建邮件内容
        const currentTime = new Date().toLocaleString();
        const subject = encodeURIComponent("迷宫探险游戏错误反馈");
        const body = encodeURIComponent(`迷宫探险游戏错误反馈\n报告时间：${currentTime}\n\n错误内容：\n${errorMessage}\n\n最近执行的命令：\n${recentCommand}\n\n${gameStatus}${browserInfo}${systemInfo}\n\n感谢您的反馈！`);
        
        // 构建mailto链接
        const mailtoLink = `mailto:YXF52013141@outlook.com?subject=${subject}&body=${body}`;
        
        // 打开邮件客户端
        window.open(mailtoLink);
        
        console.log('错误反馈已发送');
        alert('错误反馈已准备就绪，请在邮件客户端中点击发送！');
        
    } catch (e) {
        console.error('发送错误反馈时出错:', e);
        alert('发送错误反馈时出错: ' + e.message);
    }
};
// JavaScript命令执行功能
window.executeConsoleCommand = function() {
    
    try {
        const input = document.getElementById('consoleCommandInput');
        if (!input) {
            console.error('未找到 consoleCommandInput 元素');
            alert('未找到命令输入框');
            return;
        }
        
        const command = input.value.trim();
        if (!command) {
            console.log('命令为空，不执行');
            return;
        }
        
        console.log('执行命令:', command);
        
        // 添加安全检查
        const dangerousKeywords = ['document.write', 'location.href', 'eval', 'window.open', 'setTimeout.*eval'];
        for (const keyword of dangerousKeywords) {
            const regex = new RegExp(keyword, 'i');
            if (regex.test(command)) {
                console.warn('检测到危险命令，禁止执行:', command);
                alert('该命令包含危险操作，禁止执行！');
                input.value = '';
                return;
            }
        }
        
        // 记录命令
        const timestamp = new Date().toLocaleTimeString();
        consoleMessages.push({
            type: 'command',
            message: '> ' + command,
            timestamp: timestamp
        });
        
        // 执行命令
        let result;
        try {
            result = eval(command);
            
            
            // 记录结果
            let resultMsg = '';
            if (result === undefined) {
                resultMsg = 'undefined';
            } else if (typeof result === 'object') {
                try {
                    resultMsg = JSON.stringify(result, null, 2);
                } catch (e) {
                    resultMsg = result.toString();
                }
            } else {
                resultMsg = result.toString();
            }
        } catch (e) {
            console.error('命令执行错误:', e);
            
            // 记录错误
            consoleMessages.push({
                type: 'error',
                message: 'Error: ' + e.message,
                timestamp: timestamp
            });
        }
        
        // 限制消息数量
        if (consoleMessages.length > 1000) {
            consoleMessages.shift();
        }
        
        // 刷新控制台显示
        window.refreshConsole();
        
        // 清空输入框
        input.value = '';
        
    } catch (e) {
        console.error('执行命令时发生严重错误:', e);
        alert('执行命令时发生错误: ' + e.message);
    }
};

// 皮肤系统函数
function updateCoinsDisplay() {
    const coinsElement = document.getElementById('currentCoins');
    if (coinsElement) {
        coinsElement.textContent = gameState.playerData.coins;
    }
}

function updateSkinShop() {
    gameState.playerData.skins.available.forEach(skin => {
        const skinElement = document.getElementById(`skin-${skin.id}`);
        if (skinElement) {
            const statusElement = skinElement.querySelector('.achievement-status');
            const isUnlocked = gameState.playerData.skins.unlocked.includes(skin.id);
            const isCurrent = gameState.playerData.skins.current === skin.id;
            
            if (statusElement) {
                if (isUnlocked) {
                    if (isCurrent) {
                        statusElement.innerHTML = '<button disabled>当前使用</button>';
                    } else {
                        statusElement.innerHTML = `<button onclick="selectSkin('${skin.id}')">使用</button>`;
                    }
                } else {
                    statusElement.innerHTML = `<button onclick="buySkin('${skin.id}')">购买 (${skin.price}金币)</button>`;
                }
            }
        }
    });
}

function buySkin(skinId) {
    const skin = gameState.playerData.skins.available.find(s => s.id === skinId);
    if (!skin) return;
    
    if (gameState.playerData.coins >= skin.price) {
        gameState.playerData.coins -= skin.price;
        if (!gameState.playerData.skins.unlocked.includes(skinId)) {
            gameState.playerData.skins.unlocked.push(skinId);
        }
        selectSkin(skinId);
        updateCoinsDisplay();
        updateSkinShop();
        saveGame();
        showNotification(`成功购买皮肤：${skin.name}！`, 3000);
    } else {
        showNotification('金币不足！', 3000);
    }
}

function selectSkin(skinId) {
    gameState.playerData.skins.current = skinId;
    updateSkinShop();
    saveGame();
    showNotification('已切换皮肤！', 3000);
}

function getCurrentSkin() {
    const currentSkinId = gameState.playerData.skins.current;
    return gameState.playerData.skins.available.find(skin => skin.id === currentSkinId) || { id: 'default', icon: '👤' };
}

function drawPlayerWithSkin(ctx, x, y, size) {
    const skin = getCurrentSkin();
    
    ctx.fillStyle = '#FFD700';
    ctx.beginPath();
    ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.font = `${size}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(skin.icon, x + size/2, y + size/2);
}

    </script>
<!-- 皮肤商店界面 -->
    <div id="skinShopScreen" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">返回</button>
        <h2 class="level-select-title">皮肤商店</h2>
        <div style="text-align: center; margin-bottom: 20px;">
            <p>当前金币：<span id="currentCoins">0</span></p>
        </div>
        <div class="achievements-container">
            <div class="achievement-item" id="skin-default">
                <div class="achievement-icon">👤</div>
                <div class="achievement-info">
                    <h3>默认角色</h3>
                    <p>初始角色</p>
                    <p>价格：免费</p>
                </div>
                <div class="achievement-status"><button onclick="selectSkin('default')">使用</button></div>
            </div>
            <div class="achievement-item" id="skin-warrior">
                <div class="achievement-icon">⚔️</div>
                <div class="achievement-info">
                    <h3>勇士</h3>
                    <p>勇敢的战士</p>
                    <p>价格：100金币</p>
                </div>
                <div class="achievement-status"><button onclick="buySkin('warrior')">购买</button></div>
            </div>
            <div class="achievement-item" id="skin-mage">
                <div class="achievement-icon">🧙</div>
                <div class="achievement-info">
                    <h3>法师</h3>
                    <p>神秘的魔法师</p>
                    <p>价格：200金币</p>
                </div>
                <div class="achievement-status"><button onclick="buySkin('mage')">购买</button></div>
            </div>
            <div class="achievement-item" id="skin-ninja">
                <div class="achievement-icon">🥷</div>
                <div class="achievement-info">
                    <h3>忍者</h3>
                    <p>隐秘的刺客</p>
                    <p>价格：300金币</p>
                </div>
                <div class="achievement-status"><button onclick="buySkin('ninja')">购买</button></div>
            </div>
            <div class="achievement-item" id="skin-robot">
                <div class="achievement-icon">🤖</div>
                <div class="achievement-info">
                    <h3>机器人</h3>
                    <p>未来科技产物</p>
                    <p>价格：500金币</p>
                </div>
                <div class="achievement-status"><button onclick="buySkin('robot')">购买</button></div>
            </div>
            <div class="achievement-item" id="skin-alien">
                <div class="achievement-icon">👽</div>
                <div class="achievement-info">
                    <h3>外星人</h3>
                    <p>来自外太空的访客</p>
                    <p>价格：800金币</p>
                </div>
                <div class="achievement-status"><button onclick="buySkin('alien')">购买</button></div>
            </div>
            <div class="achievement-item" id="skin-knight">
                <div class="achievement-icon">🛡️</div>
                <div class="achievement-info">
                    <h3>骑士</h3>
                    <p>高贵的守护者</p>
                    <p>价格：1200金币</p>
                </div>
                <div class="achievement-status"><button onclick="buySkin('knight')">购买</button></div>
            </div>
            <div class="achievement-item" id="skin-dragon">
                <div class="achievement-icon">🐉</div>
                <div class="achievement-info">
                    <h3>龙</h3>
                    <p>传说中的生物</p>
                    <p>价格：2000金币</p>
                </div>
                <div class="achievement-status"><button onclick="buySkin('dragon')">购买</button></div>
            </div>
        </div>
    </div>
    
    <script>
    // 音乐文件选择处理函数
    function handleMusicFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
            const audio = document.getElementById('gameAudio');
            const fileURL = URL.createObjectURL(file);
            
            // 更新音频元素的src
            audio.src = fileURL;
            
            // 尝试播放音乐
            audio.play()
                .then(() => {
                    // 播放成功
                    try {
                        addChatMessage('系统', `背景音乐已开始播放: ${file.name}`, '#4CAF50');
                    } catch (e) {
                        console.error('调用addChatMessage失败:', e);
                        alert(`背景音乐已开始播放: ${file.name}`);
                    }
                    
                    // 广播给其他玩家
                    try {
                        if (gameState.multiplayer && gameState.multiplayer.connections) {
                            // 注意：由于浏览器安全限制，我们不能直接发送文件给其他玩家
                            // 发送音乐播放通知，让其他玩家知道有音乐在播放
                            const playerName = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId]?.name || '玩家';
                            const musicNotification = {
                                type: 'chat-message',
                                from: gameState.multiplayer.currentPlayerId,
                                message: `[音乐] ${playerName} 正在播放音乐: ${file.name}`,
                                color: '#FFD700',
                                isSystem: true
                            };
                            Object.values(gameState.multiplayer.connections).forEach(conn => {
                                if (conn.send) {
                                    conn.send(musicNotification);
                                }
                            });
                        }
                    } catch (e) {
                        console.error('广播音乐通知失败:', e);
                    }
                })
                .catch(error => {
                    console.error('播放音乐失败:', error);
                    // 播放失败，显示确认弹窗
                    showMusicPlayConfirmModal(fileURL);
                });
        }
    }
    
    // 图片预览功能 - 全局函数
    function openImagePreview(imageData) {
        const modal = document.getElementById('imagePreviewModal');
        const previewImage = document.getElementById('previewImage');
        if (modal && previewImage) {
            previewImage.src = imageData;
            modal.style.display = 'flex';
        }
    }
    
    // 关闭图片预览 - 全局事件监听器
    document.getElementById('closePreview')?.addEventListener('click', function() {
        const modal = document.getElementById('imagePreviewModal');
        if (modal) {
            modal.style.display = 'none';
        }
    });
    
    // 点击模态框外部关闭预览 - 全局事件监听器
    document.getElementById('imagePreviewModal')?.addEventListener('click', function(e) {
        if (e.target === this) {
            this.style.display = 'none';
        }
    });
    
    // 图片下载功能 - 全局函数
    function downloadImage() {
        const previewImage = document.getElementById('previewImage');
        if (previewImage && previewImage.src) {
            const a = document.createElement('a');
            a.href = previewImage.src;
            a.download = `maze-adventure-${Date.now()}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    }
    
    // 绑定下载按钮事件
    document.getElementById('downloadImage')?.addEventListener('click', downloadImage);
    </script>
</body>
</html>
